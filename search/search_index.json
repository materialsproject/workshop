{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Materials Project Workshop 2020 (July 28 - 30) \u00b6 The Materials Project Workshop is two-day interactive workshop to learn to use th Materials Project (MP) open-source tools. Topics will include basic structure manipulation, querying data from MP using the API, automating DFT calculations, exploring new chemical systems and machine learning. A optional one-day python and MongoDB primer is provided for anyone new to python programming and using databases. We'll also provide a virtual poster-session for anyone interested in networking with other participants. Registration \u00b6 Registration is currently closed. Location \u00b6 The 2020 Materials Project Workshop will be fully virtual due to COVID related travel and congregation restrictions. We'll use a cloud-based python environment to enable interactive tutorials where we provide close support. Primer (optional) \u00b6 All times are in Pacific Daylight Time. Tuesday Morning -- Python/Jupyter Primer \u00b6 09:00-09:20 Intro - Logistics 09:20-10:20 Basics - Variables, Lists, Loops 10:20-10:40 Break 10:40-11:40 Control: Conditions, Funtions, Sets/Dictionaries 11:40-12:00 Open Discussion 12:00-13:00 Lunch Tuesday Afternoon -- MongoDB using Python primer \u00b6 13:00-13:20 Data Modeling - Python Types to JSON to MongoDB 13:20-14:00 Listing, Counting, Finding, and Dot Notation 14:00-14:20 Break 14:20-15:20 Advanced Filtering, Basic Aggregation, and Indexing 15:20-15:40 Open Discussion 15:40-16:00 Wrap-Up Main Workshop \u00b6 All times are in Pacific Daylight Time. Wednesday Morning \u00b6 09:00-09:20 Overview of the Materials Project 09:20-10:20 Using the Website Effectively 10:20-10:40 Break 10:40-11:40 Pymatgen Foundations 11:40-12:00 Open Discussion 12:00-13:00 Lunch Wednesday Afternoon \u00b6 13:00-14:00 Working with Surfaces in Pymatgen 14:00-14:20 Break 14:20-15:20 Using the Materials API 15:20-15:40 Open Discussion 15:40-16:00 Wrap-up Thursday Morning \u00b6 09:00-09:20 Intro 09:20-10:20 Automating DFT 10:20-10:40 Break 10:40-11:40 Exploring New Systems with Pymatgen 11:40-12:00 Open Discussion 12:00-13:00 Lunch Thursday Afternoon \u00b6 13:00-14:00 MPContribs : Share You Data via MPContribs 14:00-14:20 Break 14:20-15:40 Machine Learning with Matminer 15:40-16:00 Wrap-Up Still have questions? \u00b6 If you have any further questions, you can find some more helpful info and confact information here","title":"Home"},{"location":"#materials-project-workshop-2020-july-28-30","text":"The Materials Project Workshop is two-day interactive workshop to learn to use th Materials Project (MP) open-source tools. Topics will include basic structure manipulation, querying data from MP using the API, automating DFT calculations, exploring new chemical systems and machine learning. A optional one-day python and MongoDB primer is provided for anyone new to python programming and using databases. We'll also provide a virtual poster-session for anyone interested in networking with other participants.","title":"Materials Project Workshop 2020 (July 28 - 30)"},{"location":"#registration","text":"Registration is currently closed.","title":"Registration"},{"location":"#location","text":"The 2020 Materials Project Workshop will be fully virtual due to COVID related travel and congregation restrictions. We'll use a cloud-based python environment to enable interactive tutorials where we provide close support.","title":"Location"},{"location":"#primer-optional","text":"All times are in Pacific Daylight Time.","title":"Primer (optional)"},{"location":"#tuesday-morning-pythonjupyter-primer","text":"09:00-09:20 Intro - Logistics 09:20-10:20 Basics - Variables, Lists, Loops 10:20-10:40 Break 10:40-11:40 Control: Conditions, Funtions, Sets/Dictionaries 11:40-12:00 Open Discussion 12:00-13:00 Lunch","title":"Tuesday Morning -- Python/Jupyter Primer"},{"location":"#tuesday-afternoon-mongodb-using-python-primer","text":"13:00-13:20 Data Modeling - Python Types to JSON to MongoDB 13:20-14:00 Listing, Counting, Finding, and Dot Notation 14:00-14:20 Break 14:20-15:20 Advanced Filtering, Basic Aggregation, and Indexing 15:20-15:40 Open Discussion 15:40-16:00 Wrap-Up","title":"Tuesday Afternoon -- MongoDB using Python primer"},{"location":"#main-workshop","text":"All times are in Pacific Daylight Time.","title":"Main Workshop"},{"location":"#wednesday-morning","text":"09:00-09:20 Overview of the Materials Project 09:20-10:20 Using the Website Effectively 10:20-10:40 Break 10:40-11:40 Pymatgen Foundations 11:40-12:00 Open Discussion 12:00-13:00 Lunch","title":"Wednesday Morning"},{"location":"#wednesday-afternoon","text":"13:00-14:00 Working with Surfaces in Pymatgen 14:00-14:20 Break 14:20-15:20 Using the Materials API 15:20-15:40 Open Discussion 15:40-16:00 Wrap-up","title":"Wednesday Afternoon"},{"location":"#thursday-morning","text":"09:00-09:20 Intro 09:20-10:20 Automating DFT 10:20-10:40 Break 10:40-11:40 Exploring New Systems with Pymatgen 11:40-12:00 Open Discussion 12:00-13:00 Lunch","title":"Thursday Morning"},{"location":"#thursday-afternoon","text":"13:00-14:00 MPContribs : Share You Data via MPContribs 14:00-14:20 Break 14:20-15:40 Machine Learning with Matminer 15:40-16:00 Wrap-Up","title":"Thursday Afternoon"},{"location":"#still-have-questions","text":"If you have any further questions, you can find some more helpful info and confact information here","title":"Still have questions?"},{"location":"code_of_conduct/","text":"Code of Conduct \u00b6 This is a Civilized Place for Public Discussion \u00b6 Please treat this workshop with the same respect you would a public park. We, too, are a shared community resource \u2014 a place to share skills, knowledge, and interests through ongoing conversation. These are not hard and fast rules, merely aids to the human judgment of our community. Use these guidelines to keep this a clean, well-lighted place for civilized public discourse. Inclusivity \u00b6 We want to be unequivocal in recognizing that the scientific community has serious issues with representation, with people being excluded or marginalized on the basis of sex, race, and other personal characteristics. There is absolutely no place for sexism, racism, or any other kind of discrimination or prejudice in modern science, and we want to take an active role to ensure our community is a fair, equitable, and welcoming place. Our community is stronger and more effective when it recognizes all voices equally and treats everyone with respect. There will be zero tolerance for harassment and any behavior that is discriminatory on the basis of age, disability, gender, relationship status, maternity, race, ethnicity, religion, sex or sexual orientation, or other personal characteristics. If any such behavior is noticed, members of the workshop are encouraged to let us know so that appropriate action can be taken. Improve the Discussion \u00b6 Help us make this a great place for discussion by always working to improve the discussion in some way, however small. If you are not sure your response adds to the conversation, think over what you want to say and try again later. The topics discussed here matter to us, and we want you to act as if they matter to you, too. Be respectful of the topics and the people discussing them, even if you disagree with some of what is being said. Be Agreeable, Even When You Disagree \u00b6 You may wish to respond to something by disagreeing with it. That\u2019s fine. But, remember to criticize ideas, not people. Please avoid: Name-calling. Ad hominem attacks. Responding to a post\u2019s tone instead of its actual content. Knee-jerk contradiction. Instead, provide reasoned counter-arguments that improve the conversation. Your Participation Counts \u00b6 The conversations we have here set the tone for everyone. Help us influence the future of this community by choosing to engage in discussions that make this workshop an interesting place to be \u2014 and avoiding those that do not. Let\u2019s try to leave our park better than we found it. If You See a Problem, Report It \u00b6 Instructors have special authority; they are responsible for this workshop. But so are you. With your help, moderators can be community facilitators, not just janitors or police. When you see bad behavior, don\u2019t reply. It encourages bad behavior by acknowledging it, consumes your energy, and wastes everyone\u2019s time. Just report it. In order to maintain our community, instructors reserve the right to remove any content and any user account for any reason at any time. Instructors do not preview new attendee material in any way; the instructors and site operators take no responsibility for any content posted by the community. Always Be Civil \u00b6 Nothing sabotages a healthy conversation like rudeness: Be civil . Don\u2019t post anything that a reasonable person would consider offensive, abusive, or hate speech. Keep it clean . Don\u2019t post anything obscene or sexually explicit. Respect each other . Don\u2019t harass or grief anyone, impersonate people, or expose their private information. Respect our workshop . Don\u2019t post spam or otherwise vandalize the Slack. These are not concrete terms with precise definitions \u2014 avoid even the appearance of any of these things. If you\u2019re unsure, ask yourself how you would feel if your post was featured on the front page of the New York Times. Keep the language, links, and images safe for family and friends.","title":"Code of Conduct"},{"location":"code_of_conduct/#code-of-conduct","text":"","title":"Code of Conduct"},{"location":"code_of_conduct/#this-is-a-civilized-place-for-public-discussion","text":"Please treat this workshop with the same respect you would a public park. We, too, are a shared community resource \u2014 a place to share skills, knowledge, and interests through ongoing conversation. These are not hard and fast rules, merely aids to the human judgment of our community. Use these guidelines to keep this a clean, well-lighted place for civilized public discourse.","title":"This is a Civilized Place for Public Discussion"},{"location":"code_of_conduct/#inclusivity","text":"We want to be unequivocal in recognizing that the scientific community has serious issues with representation, with people being excluded or marginalized on the basis of sex, race, and other personal characteristics. There is absolutely no place for sexism, racism, or any other kind of discrimination or prejudice in modern science, and we want to take an active role to ensure our community is a fair, equitable, and welcoming place. Our community is stronger and more effective when it recognizes all voices equally and treats everyone with respect. There will be zero tolerance for harassment and any behavior that is discriminatory on the basis of age, disability, gender, relationship status, maternity, race, ethnicity, religion, sex or sexual orientation, or other personal characteristics. If any such behavior is noticed, members of the workshop are encouraged to let us know so that appropriate action can be taken.","title":"Inclusivity"},{"location":"code_of_conduct/#improve-the-discussion","text":"Help us make this a great place for discussion by always working to improve the discussion in some way, however small. If you are not sure your response adds to the conversation, think over what you want to say and try again later. The topics discussed here matter to us, and we want you to act as if they matter to you, too. Be respectful of the topics and the people discussing them, even if you disagree with some of what is being said.","title":"Improve the Discussion"},{"location":"code_of_conduct/#be-agreeable-even-when-you-disagree","text":"You may wish to respond to something by disagreeing with it. That\u2019s fine. But, remember to criticize ideas, not people. Please avoid: Name-calling. Ad hominem attacks. Responding to a post\u2019s tone instead of its actual content. Knee-jerk contradiction. Instead, provide reasoned counter-arguments that improve the conversation.","title":"Be Agreeable, Even When You Disagree"},{"location":"code_of_conduct/#your-participation-counts","text":"The conversations we have here set the tone for everyone. Help us influence the future of this community by choosing to engage in discussions that make this workshop an interesting place to be \u2014 and avoiding those that do not. Let\u2019s try to leave our park better than we found it.","title":"Your Participation Counts"},{"location":"code_of_conduct/#if-you-see-a-problem-report-it","text":"Instructors have special authority; they are responsible for this workshop. But so are you. With your help, moderators can be community facilitators, not just janitors or police. When you see bad behavior, don\u2019t reply. It encourages bad behavior by acknowledging it, consumes your energy, and wastes everyone\u2019s time. Just report it. In order to maintain our community, instructors reserve the right to remove any content and any user account for any reason at any time. Instructors do not preview new attendee material in any way; the instructors and site operators take no responsibility for any content posted by the community.","title":"If You See a Problem, Report It"},{"location":"code_of_conduct/#always-be-civil","text":"Nothing sabotages a healthy conversation like rudeness: Be civil . Don\u2019t post anything that a reasonable person would consider offensive, abusive, or hate speech. Keep it clean . Don\u2019t post anything obscene or sexually explicit. Respect each other . Don\u2019t harass or grief anyone, impersonate people, or expose their private information. Respect our workshop . Don\u2019t post spam or otherwise vandalize the Slack. These are not concrete terms with precise definitions \u2014 avoid even the appearance of any of these things. If you\u2019re unsure, ask yourself how you would feel if your post was featured on the front page of the New York Times. Keep the language, links, and images safe for family and friends.","title":"Always Be Civil"},{"location":"lessons/01_website_walkthrough/website_walkthrough/","text":"Using the Materials Project Website \u00b6 Purpose of this Session \u00b6 This session is designed as an introduction make sure that everyone is familiar with the data and analysis that the Materials Project offers and how to access that data. We will navigate the Materials Project website, explore the properties of a material, and see how aggregations of properties of multiple materials and provide insight. We will re-visit much of this data and methods later but from a programmatic perspective later within the CoCalc teaching environment. Where Does Materials Project Data Come From? \u00b6 The Materials Project offers a variety of properties of hundreds of thousands of inorganic crystalline materials. These properties can be searched, combined and filtered in a variety of ways to help understand existing materials or discover new ones for a variety of modern applications, such as better batteries, optoelectronics, photovoltaics, carbon dioxide reduction and more. But where does this data come from? Almost all Materials Project data is calculated using a theoretical technique called Density Functional Theory (DFT). Teaching the fundamentals of DFT are beyond the scope of this workshop, but if you come from an experimental background there are some important high-level things you should know: DFT is an atomistic method. This means it needs approximate positions of atoms and approximate lattice parameters to perform a calculation. DFT is a first-principles method. This means that it uses a minimum of empirical information, so it can handle unusual systems well, including materials that have never been synthesized! It scales well to several hundred atoms, but beyond that other methods need to be used. However, DFT does still need some form of correction. The particular type of DFT used in Materials Project (GGA/PBE) systematically under-binds materials, meaning that bond lengths (and hence lattice parameters) are systematically larger than expected by 1-2%. This also results in a systematic error in our formation energies, but we can fix this systematic error by fitting our calculated data to experimental formation enthalpies. DFT is a ground-state, 0 K method. It can calculate ground state properties well such as bulk modulus, along with electronic structure information (the shape of your band structures, for example) but it is notably bad at calculating excited states including band gaps, and systematically under-estimates band gaps by a large margin. For this reason, any screening based on band gap has to include a large safety margin of ~0.5 eV. Our methods are continuously being updated. If you're a DFT person, you're welcome to talk to us about this! More information on our methods can be found in the Materials Project Documentation and references therein, or you can ask us during this workshop. Structure of the Materials Project Database \u00b6 DFT used to be a prohibitively expensive computational method but now is feasible at scale. Materials Project uses supercomputing resources at the National Energy Research Scientific Computing Center (NERSC) and elsewhere to run millions of DFT calculations using the VASP DFT code. To do this, we've developed a suite of open-source scientific codes: pymatgen , our crystallographic analysis code fireworks , a workflow package to submit, monitor and track supercomputing jobs custodian , automated error correction, to fix errors in VASP and other codes without user intervention. atomate , 'recipes' for materials science calculations built on top of fireworks maggma and emmet , for managing large databases of existing calculations matminer , to data mine our databases for machine learning We will explore the use of some of these codes in this workshop. All codes have publications, documentation and source code freely available. When performing calculations for the Materials Project, every distinct DFT calculation task we perform gets assigned an identifier, a materials ID or mp-id . Eery single property for a given material might need one or more distinct calculation tasks to calculate it, so this means that every single material has multiple mp-ids associated with it: one for each task. For example, we have the mp-id for the task used to calculate the lattice parameters and atomic positions, the task to calculate the energy, the task to calculate its band structure, etc. We then group together all the calculations for a given material together and use a single mp-id, typically the oldest one, to use for its canonical database identifier and URL on materialsproject.org, however it should be noted that any mp-id from any calculation associated with a given material can be used to find that calculation. Our implicit \"user contract\" is that the information on a specific calculation task will always remain available and unchanged via our website or API. For example, the final energy from a given calculation task will always remain the same and remain accessible. However our derived data , such as the summarized information on the materials detail page like formation energy, may change with from one database release to the next as we perform newer, better calculations that might supercede our old data. Therefore, if you want to cite Materials Project data, make sure to include the database version information with your citation. 1. Searching the Materials Project \u00b6 This part of the walkthrough will be in the Materials Explorer search app. We will briefly demonstrate how to identify experimentally synthesized structures, how to interpret the \"energy above hull\" and why this is important, and introduce an advanced search syntax we will use later in our API lesson. 2. Understanding a \"Materials Details\" Page \u00b6 This part of the walkthrough will take you through a typical \"Materials Details\" page, such as this one for GaN and this one for Fe , and look at various properties including: Electronic Structure Phonon Dispersion X-Ray Diffraction Substrates Surfaces Grain Boundaries Elasticity Piezoelectricity Dielectric Properties Equations of State Similar Structures Synthesis Descriptions Calculation Summary User Contributions (see later session) Provenance/Citation We will talk about the subtlety of crystallographic setting in interpreting lattice parameter, how to download a CIF file for the relevant crystal structure, examine references for the crystal structure from the literature (where applicable), discuss why not all materials have all properties, and show advanced users where to find details on calculation parameters. 3. Using Materials Project Apps \u00b6 This part of the walkthrough will show the variety of \"apps\" available on Materials Project. These apps combine the information we have about multiple materials to build phase diagrams, aqueous stability (Pourbaix) diagrams and more. Getting Help \u00b6 After the workshop, make sure to visit our discussion forum at matsci.org with any questions, and we will be happy to help!","title":"The Materials Project Website"},{"location":"lessons/01_website_walkthrough/website_walkthrough/#using-the-materials-project-website","text":"","title":"Using the Materials Project Website"},{"location":"lessons/01_website_walkthrough/website_walkthrough/#purpose-of-this-session","text":"This session is designed as an introduction make sure that everyone is familiar with the data and analysis that the Materials Project offers and how to access that data. We will navigate the Materials Project website, explore the properties of a material, and see how aggregations of properties of multiple materials and provide insight. We will re-visit much of this data and methods later but from a programmatic perspective later within the CoCalc teaching environment.","title":"Purpose of this Session"},{"location":"lessons/01_website_walkthrough/website_walkthrough/#where-does-materials-project-data-come-from","text":"The Materials Project offers a variety of properties of hundreds of thousands of inorganic crystalline materials. These properties can be searched, combined and filtered in a variety of ways to help understand existing materials or discover new ones for a variety of modern applications, such as better batteries, optoelectronics, photovoltaics, carbon dioxide reduction and more. But where does this data come from? Almost all Materials Project data is calculated using a theoretical technique called Density Functional Theory (DFT). Teaching the fundamentals of DFT are beyond the scope of this workshop, but if you come from an experimental background there are some important high-level things you should know: DFT is an atomistic method. This means it needs approximate positions of atoms and approximate lattice parameters to perform a calculation. DFT is a first-principles method. This means that it uses a minimum of empirical information, so it can handle unusual systems well, including materials that have never been synthesized! It scales well to several hundred atoms, but beyond that other methods need to be used. However, DFT does still need some form of correction. The particular type of DFT used in Materials Project (GGA/PBE) systematically under-binds materials, meaning that bond lengths (and hence lattice parameters) are systematically larger than expected by 1-2%. This also results in a systematic error in our formation energies, but we can fix this systematic error by fitting our calculated data to experimental formation enthalpies. DFT is a ground-state, 0 K method. It can calculate ground state properties well such as bulk modulus, along with electronic structure information (the shape of your band structures, for example) but it is notably bad at calculating excited states including band gaps, and systematically under-estimates band gaps by a large margin. For this reason, any screening based on band gap has to include a large safety margin of ~0.5 eV. Our methods are continuously being updated. If you're a DFT person, you're welcome to talk to us about this! More information on our methods can be found in the Materials Project Documentation and references therein, or you can ask us during this workshop.","title":"Where Does Materials Project Data Come From?"},{"location":"lessons/01_website_walkthrough/website_walkthrough/#structure-of-the-materials-project-database","text":"DFT used to be a prohibitively expensive computational method but now is feasible at scale. Materials Project uses supercomputing resources at the National Energy Research Scientific Computing Center (NERSC) and elsewhere to run millions of DFT calculations using the VASP DFT code. To do this, we've developed a suite of open-source scientific codes: pymatgen , our crystallographic analysis code fireworks , a workflow package to submit, monitor and track supercomputing jobs custodian , automated error correction, to fix errors in VASP and other codes without user intervention. atomate , 'recipes' for materials science calculations built on top of fireworks maggma and emmet , for managing large databases of existing calculations matminer , to data mine our databases for machine learning We will explore the use of some of these codes in this workshop. All codes have publications, documentation and source code freely available. When performing calculations for the Materials Project, every distinct DFT calculation task we perform gets assigned an identifier, a materials ID or mp-id . Eery single property for a given material might need one or more distinct calculation tasks to calculate it, so this means that every single material has multiple mp-ids associated with it: one for each task. For example, we have the mp-id for the task used to calculate the lattice parameters and atomic positions, the task to calculate the energy, the task to calculate its band structure, etc. We then group together all the calculations for a given material together and use a single mp-id, typically the oldest one, to use for its canonical database identifier and URL on materialsproject.org, however it should be noted that any mp-id from any calculation associated with a given material can be used to find that calculation. Our implicit \"user contract\" is that the information on a specific calculation task will always remain available and unchanged via our website or API. For example, the final energy from a given calculation task will always remain the same and remain accessible. However our derived data , such as the summarized information on the materials detail page like formation energy, may change with from one database release to the next as we perform newer, better calculations that might supercede our old data. Therefore, if you want to cite Materials Project data, make sure to include the database version information with your citation.","title":"Structure of the Materials Project Database"},{"location":"lessons/01_website_walkthrough/website_walkthrough/#1-searching-the-materials-project","text":"This part of the walkthrough will be in the Materials Explorer search app. We will briefly demonstrate how to identify experimentally synthesized structures, how to interpret the \"energy above hull\" and why this is important, and introduce an advanced search syntax we will use later in our API lesson.","title":"1. Searching the Materials Project"},{"location":"lessons/01_website_walkthrough/website_walkthrough/#2-understanding-a-materials-details-page","text":"This part of the walkthrough will take you through a typical \"Materials Details\" page, such as this one for GaN and this one for Fe , and look at various properties including: Electronic Structure Phonon Dispersion X-Ray Diffraction Substrates Surfaces Grain Boundaries Elasticity Piezoelectricity Dielectric Properties Equations of State Similar Structures Synthesis Descriptions Calculation Summary User Contributions (see later session) Provenance/Citation We will talk about the subtlety of crystallographic setting in interpreting lattice parameter, how to download a CIF file for the relevant crystal structure, examine references for the crystal structure from the literature (where applicable), discuss why not all materials have all properties, and show advanced users where to find details on calculation parameters.","title":"2. Understanding a \"Materials Details\" Page"},{"location":"lessons/01_website_walkthrough/website_walkthrough/#3-using-materials-project-apps","text":"This part of the walkthrough will show the variety of \"apps\" available on Materials Project. These apps combine the information we have about multiple materials to build phase diagrams, aqueous stability (Pourbaix) diagrams and more.","title":"3. Using Materials Project Apps"},{"location":"lessons/01_website_walkthrough/website_walkthrough/#getting-help","text":"After the workshop, make sure to visit our discussion forum at matsci.org with any questions, and we will be happy to help!","title":"Getting Help"},{"location":"lessons/02_intro_pymatgen/1%20-%20pymatgen%20foundations/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Materials Project Workshop \u2013 July 28th to July 30th, 2019, Berkeley, California \u00b6 What is pymatgen? \u00b6 Pymatgen (Python Materials Genomics) is the code that powers all of the scientific analysis behind the Materials Project. It includes a robust and efficient libraries for the handling of crystallographic structures and molecules, in addition to various mathematical and scientific tools for the handling and generation of materials data. For more details, see the pymatgen website . How do I install pymatgen? \u00b6 For the workshop, pymatgen has been pre-installed for use in your Jupyter notebooks. Otherwise, pymatgen can be installed via pip: pip install pymatgen or conda: conda install --channel matsci pymatgen We recommend using Python 3.6 or above. Until 2018, pymatgen was developed simultaneously for Python 2.x and 3.x, but following the rest of the Python community we have phased out support for Python 2.x, and since version 2019.1.1 we are developing exclusively for Python 3.x. Where can I find help and how do I get involved? \u00b6 For general help: pymatgen discourse is a place to ask questions. To report bugs: The Github Issues page is a good place to report bugs. For Materials Project data and website discussions: The Materials Project has its community Materials Project Discussion forum. For more example notebooks: matgenb is a new resource of Jupyter notebooks demonstrating various pymatgen functionality. If you want specific new features, you're welcome to ask! We try to respond to community needs. If you're a developer and can add the feature yourself, we actively encourage you to do so by creating a Pull Request on Github with your additional functionality. To date, pymatgen has seen over 19,000 commits and nearly 150 contributors, and we try to have an inclusive and welcoming development community. All contributors are also individually acknowledged on materialsproject.org/about . Verify we have pymatgen installed \u00b6 First, let's verify we have pymatgen installed. The following command should produce no error or warning: import pymatgen We can show the specific version of pymatgen installed: print ( pymatgen . __version__ ) 2020.7.16 For a list of new features, bug fixes and other changes, consult the changelog on pymatgen.org . You can also see where pymatgen is installed on your computer: print ( pymatgen . __file__ ) /Users/shyamd/Dropbox/Codes/pymatgen/pymatgen/__init__.py We can also see which version of the Python programming language we are using: import sys print ( sys . version ) 3.8.3 (default, Jul 2 2020, 11:26:31) [Clang 10.0.0 ] If you have problems or need to report bugs when using pymatgen after the workshop, the above information is often very useful to help us identify the problem. Structures and Molecules \u00b6 Most of the fundamentals of pymatgen are expressed in terms of Molecule and Structure objects. While we will mostly be using Structure , Stucture and Molecule are very similar conceptually. The main difference is that Structure supports full periodicity required to describe crystallographic structures. Creating a Structure can be done in one line, even for complicated crystallographic structures. However, we'll start by introducing the somewhat simpler Molecule object, and then use this understanding of Molecule to introduce Structure . Creating a Molecule \u00b6 Start by importing Molecule : from pymatgen import Molecule In a Jupyter notebook, you can show help for any Python object by clicking on the object and pressing Shift+Tab . This will give you a list of arguments and keyword arguments necessary to construct the object, as well as the documentation ('docstring') which gives more information on what each argument means. Molecule pymatgen.core.structure.Molecule Molecule takes input arguments species and coords , and input keyword arguments charge , spin_multiplicity , validate_proximity and site_properties . Keyword arguments come with a default value (the value after the equals sign), and so keyword arguments are optional. Arguments (without default values) are mandatory. c_monox = Molecule ([ \"C\" , \"O\" ], [[ 0.0 , 0.0 , 0.0 ], [ 0.0 , 0.0 , 1.2 ]]) print ( c_monox ) Full Formula (C1 O1) Reduced Formula: CO Charge = 0.0, Spin Mult = 1 Sites (2) 0 C 0.000000 0.000000 0.000000 1 O 0.000000 0.000000 1.200000 Alright, now let's use a keyword variable to change a default. How about we make an anion? oh_minus = Molecule ([ \"O\" , \"H\" ], [[ 0.0 , 0.0 , 0.0 ], [ 0.0 , 0.0 , 1.0 ]], charge =- 1 ) print ( oh_minus ) Full Formula (H1 O1) Reduced Formula: H2O2 Charge = -1, Spin Mult = 1 Sites (2) 0 O 0.000000 0.000000 0.000000 1 H 0.000000 0.000000 1.000000 You can also create Molecule objects from files. Let's say you have an *.xyz file called \"water.xyz\". You can import that into pymatgen with Molecule.from_file , like: water = Molecule . from_file ( \"water.xyz\" ) print ( water ) Full Formula (H2 O1) Reduced Formula: H2O Charge = 0, Spin Mult = 1 Sites (3) 0 O -0.070000 -0.026960 -0.095240 1 H 0.919330 -0.015310 -0.054070 2 H -0.359290 0.231000 0.816010 Exercise: Making Molecules \u00b6 Try it yourself! Create molecules however you like! In this folder are several example molecules ( methane.xyz , furan.xyz , and benzene.xyz ). Try loading these files with Molecule.from_file . You can also try making a Molecule from a list of species and coordinates. Try changing the default parameters - see what you can and cannot do (for instance, look at varying the charge and the spin multiplicity). What's in a Molecule? Introducing Sites, Elements and Species \u00b6 You can access properties of the molecule, such as the Cartesian coordinates of its sites: print ( c_monox . cart_coords ) [[0. 0. 0. ] [0. 0. 1.2]] or properties that are computed on-the-fly, such as its center of mass: print ( c_monox . center_of_mass ) [0. 0. 0.68544132] To see the full list of available properties and methods, press Tab after typing my_molecule. in your Jupyter notebook. There are methods used to modify the molecule and these take additional argument(s). For example, to add a charge to the molecule: c_monox . set_charge_and_spin ( charge = 1 ) print ( c_monox ) Full Formula (C1 O1) Reduced Formula: CO Charge = 1, Spin Mult = 2 Sites (2) 0 C 0.000000 0.000000 0.000000 1 O 0.000000 0.000000 1.200000 A molecule is essentially a list of Site objects. We can access these sites like we would a list in Python. For example, to obtain the total number of sites in the molecule: len ( c_monox ) 2 Or to access the first site (note that Python is a 0-indexed programming language, so the first site is site 0): print ( c_monox [ 0 ]) [0. 0. 0.] C And just like a list, I can even change the elements of a molecule. c_monox [ 0 ] = \"O\" c_monox [ 1 ] = \"C\" print ( c_monox ) Full Formula (C1 O1) Reduced Formula: CO Charge = 1, Spin Mult = 2 Sites (2) 0 O 0.000000 0.000000 0.000000 1 C 0.000000 0.000000 1.200000 A site object contains information on the site's identity and position in space. site0 = c_monox [ 0 ] site0 . coords array([0., 0., 0.]) site0 . specie Element O Here, because we switched the elements, the site holds the element O. In general, a site can hold an Element , a Specie or a Composition . Let's look at each of these in turn. from pymatgen import Element , Specie , Composition An Element is simply an element from the Periodic Table. carbon = Element ( 'C' ) Elements have properties such as atomic mass, average ionic radius and more: carbon . average_ionic_radius 0.3 A Specie can contain additional information, such as oxidation state: o_ion = Specie ( 'O' , oxidation_state =- 2 ) o_ion Specie O2- Again, we can access both these Specie -specific properties and more general properties of Elements. o_ion . oxi_state -2 o_ion . atomic_mass 15.9994 Or, for convenience, we can use strings, which will be interpreted as elements with oxidation states: Specie . from_string ( 'O2-' ) Specie O2- Finally, a Composition is an object that can hold certain amounts of different elements or species. This is most useful in a disordered Structure, and would rarely be used in a Molecule. For example, a site that holds 50% Au and 50% Cu would be set as follows: comp = Composition ({ 'Au' : 0.5 , 'Cu' : 0.5 }) A Composition contains more information than either an Element or a Specie . Because it can contain multiple Elements / Species , you can obtain the formula, or the chemical system. print ( \"formula\" , comp . alphabetical_formula ) print ( \"chemical system\" , comp . chemical_system ) formula Au0.5 Cu0.5 chemical system Au-Cu When we construct a Molecule , the input argument will automatically be converted into one of Element , Specie or Composition . Thus, in the previous example, when we first defined carbon monoxide, the input ['C', 'O'] was converted to [Element C, Element O] . Exercise: Hydrogen Cyanide \u00b6 Construct the linear HCN molecule where each bond distance is the sum of the two atomic radii. HINT: To do this, you'll probably want to use some Element properties! H_rad = Element ( 'H' ) . atomic_radius C_rad = Element ( 'C' ) . atomic_radius N_rad = Element ( 'N' ) . atomic_radius HC_bond_dist = H_rad + C_rad CN_bond_dist = C_rad + N_rad H_pos = 0 C_pos = H_pos + HC_bond_dist N_pos = C_pos + CN_bond_dist hcn = Molecule ([ 'H' , 'C' , 'N' ], [[ H_pos , 0 , 0 ], [ C_pos , 0 , 0 ],[ N_pos , 0 , 0 ]]) print ( hcn ) Full Formula (H1 C1 N1) Reduced Formula: HCN Charge = 0.0, Spin Mult = 1 Sites (3) 0 H 0.000000 0.000000 0.000000 1 C 0.950000 0.000000 0.000000 2 N 2.300000 0.000000 0.000000 Creating a Structure and Lattice \u00b6 Creating a Structure is very similar to creating a Molecule , except we now also have to specify a Lattice . from pymatgen import Lattice , Structure A Lattice can be created in one of several ways, such as by inputting a 3x3 matrix describing the individual lattice vectors. For example, a cubic lattice of length 5 \u00c5ngstrom: my_lattice = Lattice ([[ 5 , 0 , 0 ], [ 0 , 5 , 0 ], [ 0 , 0 , 5 ]]) print ( my_lattice ) 5.000000 0.000000 0.000000 0.000000 5.000000 0.000000 0.000000 0.000000 5.000000 Equivalently, we can create it from its lattice parameters: my_lattice_2 = Lattice . from_parameters ( 5 , 5 , 5 , 90 , 90 , 90 ) Or, since we know in this case that we have a cubic lattice, a == b == c and alpha == beta == gamma == 90 degrees, so we can simply put: my_lattice_3 = Lattice . cubic ( 5 ) We can confirm that these lattices are the same: my_lattice == my_lattice_2 == my_lattice_3 True Now, we can create a simple crystal structure. Let's start with body-centered-cubic iron: bcc_fe = Structure ( Lattice . cubic ( 2.8 ), [ \"Fe\" , \"Fe\" ], [[ 0 , 0 , 0 ], [ 0.5 , 0.5 , 0.5 ]]) print ( bcc_fe ) Full Formula (Fe2) Reduced Formula: Fe abc : 2.800000 2.800000 2.800000 angles: 90.000000 90.000000 90.000000 Sites (2) # SP a b c --- ---- --- --- --- 0 Fe 0 0 0 1 Fe 0.5 0.5 0.5 print ( bcc_fe ) Full Formula (Fe2) Reduced Formula: Fe abc : 2.800000 2.800000 2.800000 angles: 90.000000 90.000000 90.000000 Sites (2) # SP a b c --- ---- --- --- --- 0 Fe 0 0 0 1 Fe 0.5 0.5 0.5 Creating this Structure was similar to creating a Molecule in that we provided a list of elements and a list of positions. However, there are two key differences: we had to include our Lattice object when creating the Structure and since we have a lattice, we can define the positions of our sites in fractional coordinates with respect to that lattice instead of Cartesian coordinates. It's also possible to create an equivalent Structure using Cartesian coordinates: bcc_fe_from_cart = Structure ( Lattice . cubic ( 2.8 ), [ \"Fe\" , \"Fe\" ], [[ 0 , 0 , 0 ], [ 1.4 , 1.4 , 1.4 ]], coords_are_cartesian = True ) print ( bcc_fe_from_cart ) Full Formula (Fe2) Reduced Formula: Fe abc : 2.800000 2.800000 2.800000 angles: 90.000000 90.000000 90.000000 Sites (2) # SP a b c --- ---- --- --- --- 0 Fe 0 0 0 1 Fe 0.5 0.5 0.5 We can check that both structures are equivalent: bcc_fe == bcc_fe_from_cart True As in a Molecule , we can access properties of the structure, such as its volume: bcc_fe . volume 21.951999999999995 Creating Structures from Spacegroups \u00b6 Structures can also be created directly from their spacegroup: bcc_fe = Structure . from_spacegroup ( \"Im-3m\" , Lattice . cubic ( 2.8 ), [ \"Fe\" ], [[ 0 , 0 , 0 ]]) print ( bcc_fe ) Full Formula (Fe2) Reduced Formula: Fe abc : 2.800000 2.800000 2.800000 angles: 90.000000 90.000000 90.000000 Sites (2) # SP a b c --- ---- --- --- --- 0 Fe 0 0 0 1 Fe 0.5 0.5 0.5 nacl = Structure . from_spacegroup ( \"Fm-3m\" , Lattice . cubic ( 5.692 ), [ \"Na+\" , \"Cl-\" ], [[ 0 , 0 , 0 ], [ 0.5 , 0.5 , 0.5 ]]) print ( nacl ) Full Formula (Na4 Cl4) Reduced Formula: NaCl abc : 5.692000 5.692000 5.692000 angles: 90.000000 90.000000 90.000000 Sites (8) # SP a b c --- ---- --- --- --- 0 Na+ 0 0 0 1 Na+ 0 0.5 0.5 2 Na+ 0.5 0 0.5 3 Na+ 0.5 0.5 0 4 Cl- 0.5 0.5 0.5 5 Cl- 0.5 0 0 6 Cl- 0 0.5 0 7 Cl- 0 0 0.5 And spacegroups can be obtained from a structure: nacl . get_space_group_info () ('Fm-3m', 225) Where 225 is the spacegroup number. Supercells \u00b6 Alright, we are now well-versed in the art of creating singular structures. But in some cases, you really don't just want one unit cell; you want a supercell. Pymatgen provides a very simple interface to create superstructures. Let's start with the simplest structure that we can imagine: Polonium, a simple cubic metal. polonium = Structure ( Lattice . cubic ( 3.4 ), [ \"Po\" ], [[ 0.0 , 0.0 , 0.0 ]]) print ( polonium ) Full Formula (Po1) Reduced Formula: Po abc : 3.400000 3.400000 3.400000 angles: 90.000000 90.000000 90.000000 Sites (1) # SP a b c --- ---- --- --- --- 0 Po 0 0 0 To make a supercell, we can just multiply the structure by a tuple! supercell = polonium * ( 2 , 2 , 2 ) print ( supercell ) Full Formula (Po8) Reduced Formula: Po abc : 6.800000 6.800000 6.800000 angles: 90.000000 90.000000 90.000000 Sites (8) # SP a b c --- ---- --- --- --- 0 Po 0 0 0 1 Po 0 0 0.5 2 Po 0 0.5 0 3 Po 0 0.5 0.5 4 Po 0.5 0 0 5 Po 0.5 0 0.5 6 Po 0.5 0.5 0 7 Po 0.5 0.5 0.5 Exercise: Barium Titanate \u00b6 Load BaTiO3 from the CIF file provided ( BaTiO3.cif ). Replace the barium with a new element with atomic number equal to the the day of the month you were born (e.g. 1st = hydrogen, 31st = gallium). Then, make a supercell of N unit cells in one cartesian direction of your choice where N is the integer of your birth month (e.g. January = 1, December = 12). BaTiO3 = Structure . from_file ( \"BaTiO3.cif\" ) print ( BaTiO3 . get_space_group_info ()) BaTiO3 . replace ( 0 , 'Mg' ) BaTiO3 = BaTiO3 * ( 1 , 1 , 4 ) print ( BaTiO3 ) print ( BaTiO3 . get_space_group_info ()) ('R3m', 160) Full Formula (Mg4 Ti4 O12) Reduced Formula: MgTiO3 abc : 4.077159 4.077159 16.308637 angles: 89.699022 89.699022 89.699022 Sites (20) # SP a b c --- ---- -------- -------- -------- 0 Mg 0.497155 0.497155 0.124289 1 Mg 0.497155 0.497155 0.374289 2 Mg 0.497155 0.497155 0.624289 3 Mg 0.497155 0.497155 0.874289 4 Ti 0.982209 0.982209 0.245552 5 Ti 0.982209 0.982209 0.495552 6 Ti 0.982209 0.982209 0.745552 7 Ti 0.982209 0.982209 0.995552 8 O 0.524065 0.012736 0.003184 9 O 0.524065 0.012736 0.253184 10 O 0.524065 0.012736 0.503184 11 O 0.524065 0.012736 0.753184 12 O 0.012736 0.012736 0.131016 13 O 0.012736 0.012736 0.381016 14 O 0.012736 0.012736 0.631016 15 O 0.012736 0.012736 0.881016 16 O 0.012736 0.524065 0.003184 17 O 0.012736 0.524065 0.253184 18 O 0.012736 0.524065 0.503184 19 O 0.012736 0.524065 0.753184 ('R3m', 160) Summary \u00b6 This notebook is intended to provide a short introduction to some of the functionality of pymatgen. We've examined the building blocks of pymatgen: the Structure and Molecule objects, as well as the Lattice , Element , Specie and Composition objects that they're made up of.","title":"Intro to Pymatgen"},{"location":"lessons/02_intro_pymatgen/1%20-%20pymatgen%20foundations/#materials-project-workshop-july-28th-to-july-30th-2019-berkeley-california","text":"","title":"Materials Project Workshop \u2013 July 28th to July 30th, 2019, Berkeley, California"},{"location":"lessons/02_intro_pymatgen/1%20-%20pymatgen%20foundations/#what-is-pymatgen","text":"Pymatgen (Python Materials Genomics) is the code that powers all of the scientific analysis behind the Materials Project. It includes a robust and efficient libraries for the handling of crystallographic structures and molecules, in addition to various mathematical and scientific tools for the handling and generation of materials data. For more details, see the pymatgen website .","title":"What is pymatgen?"},{"location":"lessons/02_intro_pymatgen/1%20-%20pymatgen%20foundations/#how-do-i-install-pymatgen","text":"For the workshop, pymatgen has been pre-installed for use in your Jupyter notebooks. Otherwise, pymatgen can be installed via pip: pip install pymatgen or conda: conda install --channel matsci pymatgen We recommend using Python 3.6 or above. Until 2018, pymatgen was developed simultaneously for Python 2.x and 3.x, but following the rest of the Python community we have phased out support for Python 2.x, and since version 2019.1.1 we are developing exclusively for Python 3.x.","title":"How do I install pymatgen?"},{"location":"lessons/02_intro_pymatgen/1%20-%20pymatgen%20foundations/#where-can-i-find-help-and-how-do-i-get-involved","text":"For general help: pymatgen discourse is a place to ask questions. To report bugs: The Github Issues page is a good place to report bugs. For Materials Project data and website discussions: The Materials Project has its community Materials Project Discussion forum. For more example notebooks: matgenb is a new resource of Jupyter notebooks demonstrating various pymatgen functionality. If you want specific new features, you're welcome to ask! We try to respond to community needs. If you're a developer and can add the feature yourself, we actively encourage you to do so by creating a Pull Request on Github with your additional functionality. To date, pymatgen has seen over 19,000 commits and nearly 150 contributors, and we try to have an inclusive and welcoming development community. All contributors are also individually acknowledged on materialsproject.org/about .","title":"Where can I find help and how do I get involved?"},{"location":"lessons/02_intro_pymatgen/1%20-%20pymatgen%20foundations/#verify-we-have-pymatgen-installed","text":"First, let's verify we have pymatgen installed. The following command should produce no error or warning: import pymatgen We can show the specific version of pymatgen installed: print ( pymatgen . __version__ ) 2020.7.16 For a list of new features, bug fixes and other changes, consult the changelog on pymatgen.org . You can also see where pymatgen is installed on your computer: print ( pymatgen . __file__ ) /Users/shyamd/Dropbox/Codes/pymatgen/pymatgen/__init__.py We can also see which version of the Python programming language we are using: import sys print ( sys . version ) 3.8.3 (default, Jul 2 2020, 11:26:31) [Clang 10.0.0 ] If you have problems or need to report bugs when using pymatgen after the workshop, the above information is often very useful to help us identify the problem.","title":"Verify we have pymatgen installed"},{"location":"lessons/02_intro_pymatgen/1%20-%20pymatgen%20foundations/#structures-and-molecules","text":"Most of the fundamentals of pymatgen are expressed in terms of Molecule and Structure objects. While we will mostly be using Structure , Stucture and Molecule are very similar conceptually. The main difference is that Structure supports full periodicity required to describe crystallographic structures. Creating a Structure can be done in one line, even for complicated crystallographic structures. However, we'll start by introducing the somewhat simpler Molecule object, and then use this understanding of Molecule to introduce Structure .","title":"Structures and Molecules"},{"location":"lessons/02_intro_pymatgen/1%20-%20pymatgen%20foundations/#creating-a-molecule","text":"Start by importing Molecule : from pymatgen import Molecule In a Jupyter notebook, you can show help for any Python object by clicking on the object and pressing Shift+Tab . This will give you a list of arguments and keyword arguments necessary to construct the object, as well as the documentation ('docstring') which gives more information on what each argument means. Molecule pymatgen.core.structure.Molecule Molecule takes input arguments species and coords , and input keyword arguments charge , spin_multiplicity , validate_proximity and site_properties . Keyword arguments come with a default value (the value after the equals sign), and so keyword arguments are optional. Arguments (without default values) are mandatory. c_monox = Molecule ([ \"C\" , \"O\" ], [[ 0.0 , 0.0 , 0.0 ], [ 0.0 , 0.0 , 1.2 ]]) print ( c_monox ) Full Formula (C1 O1) Reduced Formula: CO Charge = 0.0, Spin Mult = 1 Sites (2) 0 C 0.000000 0.000000 0.000000 1 O 0.000000 0.000000 1.200000 Alright, now let's use a keyword variable to change a default. How about we make an anion? oh_minus = Molecule ([ \"O\" , \"H\" ], [[ 0.0 , 0.0 , 0.0 ], [ 0.0 , 0.0 , 1.0 ]], charge =- 1 ) print ( oh_minus ) Full Formula (H1 O1) Reduced Formula: H2O2 Charge = -1, Spin Mult = 1 Sites (2) 0 O 0.000000 0.000000 0.000000 1 H 0.000000 0.000000 1.000000 You can also create Molecule objects from files. Let's say you have an *.xyz file called \"water.xyz\". You can import that into pymatgen with Molecule.from_file , like: water = Molecule . from_file ( \"water.xyz\" ) print ( water ) Full Formula (H2 O1) Reduced Formula: H2O Charge = 0, Spin Mult = 1 Sites (3) 0 O -0.070000 -0.026960 -0.095240 1 H 0.919330 -0.015310 -0.054070 2 H -0.359290 0.231000 0.816010","title":"Creating a Molecule"},{"location":"lessons/02_intro_pymatgen/1%20-%20pymatgen%20foundations/#exercise-making-molecules","text":"Try it yourself! Create molecules however you like! In this folder are several example molecules ( methane.xyz , furan.xyz , and benzene.xyz ). Try loading these files with Molecule.from_file . You can also try making a Molecule from a list of species and coordinates. Try changing the default parameters - see what you can and cannot do (for instance, look at varying the charge and the spin multiplicity).","title":"Exercise: Making Molecules"},{"location":"lessons/02_intro_pymatgen/1%20-%20pymatgen%20foundations/#whats-in-a-molecule-introducing-sites-elements-and-species","text":"You can access properties of the molecule, such as the Cartesian coordinates of its sites: print ( c_monox . cart_coords ) [[0. 0. 0. ] [0. 0. 1.2]] or properties that are computed on-the-fly, such as its center of mass: print ( c_monox . center_of_mass ) [0. 0. 0.68544132] To see the full list of available properties and methods, press Tab after typing my_molecule. in your Jupyter notebook. There are methods used to modify the molecule and these take additional argument(s). For example, to add a charge to the molecule: c_monox . set_charge_and_spin ( charge = 1 ) print ( c_monox ) Full Formula (C1 O1) Reduced Formula: CO Charge = 1, Spin Mult = 2 Sites (2) 0 C 0.000000 0.000000 0.000000 1 O 0.000000 0.000000 1.200000 A molecule is essentially a list of Site objects. We can access these sites like we would a list in Python. For example, to obtain the total number of sites in the molecule: len ( c_monox ) 2 Or to access the first site (note that Python is a 0-indexed programming language, so the first site is site 0): print ( c_monox [ 0 ]) [0. 0. 0.] C And just like a list, I can even change the elements of a molecule. c_monox [ 0 ] = \"O\" c_monox [ 1 ] = \"C\" print ( c_monox ) Full Formula (C1 O1) Reduced Formula: CO Charge = 1, Spin Mult = 2 Sites (2) 0 O 0.000000 0.000000 0.000000 1 C 0.000000 0.000000 1.200000 A site object contains information on the site's identity and position in space. site0 = c_monox [ 0 ] site0 . coords array([0., 0., 0.]) site0 . specie Element O Here, because we switched the elements, the site holds the element O. In general, a site can hold an Element , a Specie or a Composition . Let's look at each of these in turn. from pymatgen import Element , Specie , Composition An Element is simply an element from the Periodic Table. carbon = Element ( 'C' ) Elements have properties such as atomic mass, average ionic radius and more: carbon . average_ionic_radius 0.3 A Specie can contain additional information, such as oxidation state: o_ion = Specie ( 'O' , oxidation_state =- 2 ) o_ion Specie O2- Again, we can access both these Specie -specific properties and more general properties of Elements. o_ion . oxi_state -2 o_ion . atomic_mass 15.9994 Or, for convenience, we can use strings, which will be interpreted as elements with oxidation states: Specie . from_string ( 'O2-' ) Specie O2- Finally, a Composition is an object that can hold certain amounts of different elements or species. This is most useful in a disordered Structure, and would rarely be used in a Molecule. For example, a site that holds 50% Au and 50% Cu would be set as follows: comp = Composition ({ 'Au' : 0.5 , 'Cu' : 0.5 }) A Composition contains more information than either an Element or a Specie . Because it can contain multiple Elements / Species , you can obtain the formula, or the chemical system. print ( \"formula\" , comp . alphabetical_formula ) print ( \"chemical system\" , comp . chemical_system ) formula Au0.5 Cu0.5 chemical system Au-Cu When we construct a Molecule , the input argument will automatically be converted into one of Element , Specie or Composition . Thus, in the previous example, when we first defined carbon monoxide, the input ['C', 'O'] was converted to [Element C, Element O] .","title":"What's in a Molecule? Introducing Sites, Elements and Species"},{"location":"lessons/02_intro_pymatgen/1%20-%20pymatgen%20foundations/#exercise-hydrogen-cyanide","text":"Construct the linear HCN molecule where each bond distance is the sum of the two atomic radii. HINT: To do this, you'll probably want to use some Element properties! H_rad = Element ( 'H' ) . atomic_radius C_rad = Element ( 'C' ) . atomic_radius N_rad = Element ( 'N' ) . atomic_radius HC_bond_dist = H_rad + C_rad CN_bond_dist = C_rad + N_rad H_pos = 0 C_pos = H_pos + HC_bond_dist N_pos = C_pos + CN_bond_dist hcn = Molecule ([ 'H' , 'C' , 'N' ], [[ H_pos , 0 , 0 ], [ C_pos , 0 , 0 ],[ N_pos , 0 , 0 ]]) print ( hcn ) Full Formula (H1 C1 N1) Reduced Formula: HCN Charge = 0.0, Spin Mult = 1 Sites (3) 0 H 0.000000 0.000000 0.000000 1 C 0.950000 0.000000 0.000000 2 N 2.300000 0.000000 0.000000","title":"Exercise: Hydrogen Cyanide"},{"location":"lessons/02_intro_pymatgen/1%20-%20pymatgen%20foundations/#creating-a-structure-and-lattice","text":"Creating a Structure is very similar to creating a Molecule , except we now also have to specify a Lattice . from pymatgen import Lattice , Structure A Lattice can be created in one of several ways, such as by inputting a 3x3 matrix describing the individual lattice vectors. For example, a cubic lattice of length 5 \u00c5ngstrom: my_lattice = Lattice ([[ 5 , 0 , 0 ], [ 0 , 5 , 0 ], [ 0 , 0 , 5 ]]) print ( my_lattice ) 5.000000 0.000000 0.000000 0.000000 5.000000 0.000000 0.000000 0.000000 5.000000 Equivalently, we can create it from its lattice parameters: my_lattice_2 = Lattice . from_parameters ( 5 , 5 , 5 , 90 , 90 , 90 ) Or, since we know in this case that we have a cubic lattice, a == b == c and alpha == beta == gamma == 90 degrees, so we can simply put: my_lattice_3 = Lattice . cubic ( 5 ) We can confirm that these lattices are the same: my_lattice == my_lattice_2 == my_lattice_3 True Now, we can create a simple crystal structure. Let's start with body-centered-cubic iron: bcc_fe = Structure ( Lattice . cubic ( 2.8 ), [ \"Fe\" , \"Fe\" ], [[ 0 , 0 , 0 ], [ 0.5 , 0.5 , 0.5 ]]) print ( bcc_fe ) Full Formula (Fe2) Reduced Formula: Fe abc : 2.800000 2.800000 2.800000 angles: 90.000000 90.000000 90.000000 Sites (2) # SP a b c --- ---- --- --- --- 0 Fe 0 0 0 1 Fe 0.5 0.5 0.5 print ( bcc_fe ) Full Formula (Fe2) Reduced Formula: Fe abc : 2.800000 2.800000 2.800000 angles: 90.000000 90.000000 90.000000 Sites (2) # SP a b c --- ---- --- --- --- 0 Fe 0 0 0 1 Fe 0.5 0.5 0.5 Creating this Structure was similar to creating a Molecule in that we provided a list of elements and a list of positions. However, there are two key differences: we had to include our Lattice object when creating the Structure and since we have a lattice, we can define the positions of our sites in fractional coordinates with respect to that lattice instead of Cartesian coordinates. It's also possible to create an equivalent Structure using Cartesian coordinates: bcc_fe_from_cart = Structure ( Lattice . cubic ( 2.8 ), [ \"Fe\" , \"Fe\" ], [[ 0 , 0 , 0 ], [ 1.4 , 1.4 , 1.4 ]], coords_are_cartesian = True ) print ( bcc_fe_from_cart ) Full Formula (Fe2) Reduced Formula: Fe abc : 2.800000 2.800000 2.800000 angles: 90.000000 90.000000 90.000000 Sites (2) # SP a b c --- ---- --- --- --- 0 Fe 0 0 0 1 Fe 0.5 0.5 0.5 We can check that both structures are equivalent: bcc_fe == bcc_fe_from_cart True As in a Molecule , we can access properties of the structure, such as its volume: bcc_fe . volume 21.951999999999995","title":"Creating a Structure and Lattice"},{"location":"lessons/02_intro_pymatgen/1%20-%20pymatgen%20foundations/#creating-structures-from-spacegroups","text":"Structures can also be created directly from their spacegroup: bcc_fe = Structure . from_spacegroup ( \"Im-3m\" , Lattice . cubic ( 2.8 ), [ \"Fe\" ], [[ 0 , 0 , 0 ]]) print ( bcc_fe ) Full Formula (Fe2) Reduced Formula: Fe abc : 2.800000 2.800000 2.800000 angles: 90.000000 90.000000 90.000000 Sites (2) # SP a b c --- ---- --- --- --- 0 Fe 0 0 0 1 Fe 0.5 0.5 0.5 nacl = Structure . from_spacegroup ( \"Fm-3m\" , Lattice . cubic ( 5.692 ), [ \"Na+\" , \"Cl-\" ], [[ 0 , 0 , 0 ], [ 0.5 , 0.5 , 0.5 ]]) print ( nacl ) Full Formula (Na4 Cl4) Reduced Formula: NaCl abc : 5.692000 5.692000 5.692000 angles: 90.000000 90.000000 90.000000 Sites (8) # SP a b c --- ---- --- --- --- 0 Na+ 0 0 0 1 Na+ 0 0.5 0.5 2 Na+ 0.5 0 0.5 3 Na+ 0.5 0.5 0 4 Cl- 0.5 0.5 0.5 5 Cl- 0.5 0 0 6 Cl- 0 0.5 0 7 Cl- 0 0 0.5 And spacegroups can be obtained from a structure: nacl . get_space_group_info () ('Fm-3m', 225) Where 225 is the spacegroup number.","title":"Creating Structures from Spacegroups"},{"location":"lessons/02_intro_pymatgen/1%20-%20pymatgen%20foundations/#supercells","text":"Alright, we are now well-versed in the art of creating singular structures. But in some cases, you really don't just want one unit cell; you want a supercell. Pymatgen provides a very simple interface to create superstructures. Let's start with the simplest structure that we can imagine: Polonium, a simple cubic metal. polonium = Structure ( Lattice . cubic ( 3.4 ), [ \"Po\" ], [[ 0.0 , 0.0 , 0.0 ]]) print ( polonium ) Full Formula (Po1) Reduced Formula: Po abc : 3.400000 3.400000 3.400000 angles: 90.000000 90.000000 90.000000 Sites (1) # SP a b c --- ---- --- --- --- 0 Po 0 0 0 To make a supercell, we can just multiply the structure by a tuple! supercell = polonium * ( 2 , 2 , 2 ) print ( supercell ) Full Formula (Po8) Reduced Formula: Po abc : 6.800000 6.800000 6.800000 angles: 90.000000 90.000000 90.000000 Sites (8) # SP a b c --- ---- --- --- --- 0 Po 0 0 0 1 Po 0 0 0.5 2 Po 0 0.5 0 3 Po 0 0.5 0.5 4 Po 0.5 0 0 5 Po 0.5 0 0.5 6 Po 0.5 0.5 0 7 Po 0.5 0.5 0.5","title":"Supercells"},{"location":"lessons/02_intro_pymatgen/1%20-%20pymatgen%20foundations/#exercise-barium-titanate","text":"Load BaTiO3 from the CIF file provided ( BaTiO3.cif ). Replace the barium with a new element with atomic number equal to the the day of the month you were born (e.g. 1st = hydrogen, 31st = gallium). Then, make a supercell of N unit cells in one cartesian direction of your choice where N is the integer of your birth month (e.g. January = 1, December = 12). BaTiO3 = Structure . from_file ( \"BaTiO3.cif\" ) print ( BaTiO3 . get_space_group_info ()) BaTiO3 . replace ( 0 , 'Mg' ) BaTiO3 = BaTiO3 * ( 1 , 1 , 4 ) print ( BaTiO3 ) print ( BaTiO3 . get_space_group_info ()) ('R3m', 160) Full Formula (Mg4 Ti4 O12) Reduced Formula: MgTiO3 abc : 4.077159 4.077159 16.308637 angles: 89.699022 89.699022 89.699022 Sites (20) # SP a b c --- ---- -------- -------- -------- 0 Mg 0.497155 0.497155 0.124289 1 Mg 0.497155 0.497155 0.374289 2 Mg 0.497155 0.497155 0.624289 3 Mg 0.497155 0.497155 0.874289 4 Ti 0.982209 0.982209 0.245552 5 Ti 0.982209 0.982209 0.495552 6 Ti 0.982209 0.982209 0.745552 7 Ti 0.982209 0.982209 0.995552 8 O 0.524065 0.012736 0.003184 9 O 0.524065 0.012736 0.253184 10 O 0.524065 0.012736 0.503184 11 O 0.524065 0.012736 0.753184 12 O 0.012736 0.012736 0.131016 13 O 0.012736 0.012736 0.381016 14 O 0.012736 0.012736 0.631016 15 O 0.012736 0.012736 0.881016 16 O 0.012736 0.524065 0.003184 17 O 0.012736 0.524065 0.253184 18 O 0.012736 0.524065 0.503184 19 O 0.012736 0.524065 0.753184 ('R3m', 160)","title":"Exercise: Barium Titanate"},{"location":"lessons/02_intro_pymatgen/1%20-%20pymatgen%20foundations/#summary","text":"This notebook is intended to provide a short introduction to some of the functionality of pymatgen. We've examined the building blocks of pymatgen: the Structure and Molecule objects, as well as the Lattice , Element , Specie and Composition objects that they're made up of.","title":"Summary"},{"location":"lessons/02_intro_pymatgen/1-%20pymatgen%20foundations%20exercises/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Exercise 1: Creating Molecules \u00b6 Try it yourself! Create molecules however you like! In this folder are several example molecules ( methane.xyz , furan.xyz , and benzene.xyz ). Try loading these files with Molecule.from_file . You can also try making a Molecule from lists of species and coordinates. Try changing the default parameters - see what you can and cannot do (for instance, look at varying the charge and the spin multiplicity). Exercise 2: Hydrogen Cyanide \u00b6 Construct a linear HCN molecule, where each bond distance is the sum of the two atomic radii. Exercise 3: Barium Titanate \u00b6 Load BaTiO3 from the CIF file provided ( BaTiO3.cif ). Replace the barium with a new element with atomic number equal to the the day of the month you were born (e.g. 1st = hydrogen, 31st = gallium). Then, make a supercell of N unit cells in one cartesian direction of your choice where N is the integer of your birth month (e.g. January = 1, December = 12). Make sure the space group of your supercell is the same as the space group for the original crystal.","title":"1  pymatgen foundations exercises"},{"location":"lessons/02_intro_pymatgen/1-%20pymatgen%20foundations%20exercises/#exercise-1-creating-molecules","text":"Try it yourself! Create molecules however you like! In this folder are several example molecules ( methane.xyz , furan.xyz , and benzene.xyz ). Try loading these files with Molecule.from_file . You can also try making a Molecule from lists of species and coordinates. Try changing the default parameters - see what you can and cannot do (for instance, look at varying the charge and the spin multiplicity).","title":"Exercise 1: Creating Molecules"},{"location":"lessons/02_intro_pymatgen/1-%20pymatgen%20foundations%20exercises/#exercise-2-hydrogen-cyanide","text":"Construct a linear HCN molecule, where each bond distance is the sum of the two atomic radii.","title":"Exercise 2: Hydrogen Cyanide"},{"location":"lessons/02_intro_pymatgen/1-%20pymatgen%20foundations%20exercises/#exercise-3-barium-titanate","text":"Load BaTiO3 from the CIF file provided ( BaTiO3.cif ). Replace the barium with a new element with atomic number equal to the the day of the month you were born (e.g. 1st = hydrogen, 31st = gallium). Then, make a supercell of N unit cells in one cartesian direction of your choice where N is the integer of your birth month (e.g. January = 1, December = 12). Make sure the space group of your supercell is the same as the space group for the original crystal.","title":"Exercise 3: Barium Titanate"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_empty/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Working With Surfaces \u00b6 1. Building Elemental Surfaces \u00b6 Exercise 1.1: Silicon (1, 1, 1) surfaces \u00b6 Let's try generating the (1, 1, 1) surfaces for a diamond Silicon structure. We can start by importing the Structure class from pymatgen and reading the silicon structure from the Si.cif file: The next step is to import the SlabGenerator class from pymatgen.core.surface and then initialize it for the silicon structure, with a Miller index of (1, 1, 1), a minimum slab height of 10 \u00c5, and minimum 10 \u00c5 of vacuum: We can now get all the corresponding slabs using get_slabs() and store the returned list in a new variable: How many terminations are there now? Let's check if the two slabs are equivalent by using the matches() method for one of the two slabs and passing the other one as the argument: We can also visualize the two slabs to convince ourselves that they are different. Start by importing plot_slab and pyplot as plt and then run %matplotlib inline : Let's now plot the two slabs. Remeber to make a pyplot figure and add a subplot first. For simplicity you can write the code to plot each slab in a separate cell; if you would like more of a challenge, you can try to plot them on the same figure! Finally, let's save the two silicon (1, 1, 1) surfaces to files using the to() method with \"cif\" as the format (the fmt argument) and a filename of your choice under filename : Exercise 1.2: Silicon - All surfaces \u00b6 We can also generate all the possible surfaces up to a given Miller index. This can be achieved using the generate_all_slabs() function. We can import it from pymatgen.core.surface : Let's use this function for our Si crystal with a Miller index of up to 3, a minimum slab size of 10 \u00c5 and minimum vacuum of 10 \u00c5 and store the returned list under a new variable: How many slab structures were returned? We can investigate these surfaces further. What are their Miller indices and c shifts? Notice some Miller indices are repeated. Again, this is due to there being more than one termination. However, each Miller index + c shift combination is unique. 2. Building Compound Surfaces \u00b6 Exercise 2.1: TiO 2 - all surfaces \u00b6 Let's generate some rutile TiO 2 surfaces and investigate them. We can start by importing the bulk structure from TiO2.cif : We should now add the corresponding oxidation states to each element using the add_oxidation_state_by_element() method: +4 for Ti, -2 for O: Let's now generate all slabs up to a Miller index of 2, with a minimum slab size and minimum vacuum size of 10 \u00c5. How many such surfaces are there? For each of these slabs print its index, whether it is symmetric, and whether or not is polar. To do so, we can use the enumerate() function, which allows us to loop through the elements of our list and their indices at the same time: Choose a few slabs, some that are polar, some that are not, and print their dipoles (using the dipole property). You can use the indices you printed previously to access specific elements of the list. Are the values of the dipoles consistent with the polarity returned by is_polar() ? Exercise 2.2: WSe 2 - a layered material \u00b6 Let's now think about generating slabs for a layered material, WSe 2 . You can read its structure from WSe2.cif (if you get a warning about fractional co-ordinates do not worry about it): The bulk WSe 2 structure has the layers oriented along the c direction - this means that the relevant slabs, which terminate on a layer of the material, will be along the (0, 0, 1) direction. Let's initialize the SlabGenerator for (0, 0, 1), with a minimum slab size and minimum vacuum of 10 \u00c5: To generate the slabs we have to also make sure that we are not breaking through any layers of atoms. In this case, that means we have to avoid breaking any of the W-Se bonds, which are 2.55 \u00c5 long. Get the slabs from the SlabGenerator you just created, making sure to use the bonds argument to avoid breaking any W-Se bonds. (Hint: in the dictionary you pass to the bonds argument, use a distance slightly larger than 2.55 \u00c5 to account for the rounding of this value as reported here): Let's check if our code only returned one slab, as expected: The slab you just created contains 2 layers of atoms. Let's now try to create a slab that contains 4 layers of atoms - what parameter would control this? (You can keep the vacuum size the same as before) We can print the number of sites in the original slab and the new slab, respectively, to check if the new slab has twice the number of layers. This can be done using the num_sites property of the slab: 3. Adding adsorbates \u00b6 Exercise 3.1: Adsorbates in the dilute limit \u00b6 While in the previous example we added one adsorbate per unit cell, in this exercise we are going to add adsorbates that are more spaced out. Let's start by importing the copper structure from the .cif file: Let's generate the (1, 1, 1) surface, with 10 \u00c5 as the minimum slab size and minimum vacuum and then extract the one slab from the returned list as a new variable: We can now import the AdsorbateSiteFinder and initialize it for the copper slab we just created. Let's make a hydrogen Molecule object that we can then add to our surface (don't forget to import the Molecule class from pymatgen first): We can now generate the adsorption structures, but this time, let's use the min_lw argument to make our slab a supercell of the original slab. Let's set min_lw to be 7 \u00c5, which will mean that the slab will be repeated multiple times in the a and b directions until it has a length and a width of at least 7 \u00c5 (the thickness of the slab i.e. the size in the c direction will remain unchanged). Notice that min_lw is an alternative to using the repeat argument we used in the lesson. Let's set the distance from the surface to the adsorbate to be 1.6 \u00c5; this can be done by setting the find_args parameter to be a dictionary with \"distance\" as the key and 1.6 as the value: Let's now visualize the first adsorption structure in the list using plot_slab() . Some hints: set the adsorption_sites argument of plot_slab() to False to not display adsorption sites use the set_xlim() and set_ylim() methods of the matplotlib axes to \"zoom in\" around the unit cell use the set_xticks() and set_yticks() methods of the matplotlib axes with an empty list as an argument to remove the ticks on the x and y axis, respectively You should now see that only a third of the corresponding equivalent adsorption sites have a hydrogen atom on them - compare this with the structures we generated during the lesson. Exercise 3.2: CO 2 as an adsorbate \u00b6 In this exercise we will look into some advanced controls for generating adsorption structures by working with CO 2 , a polyatomic adsorbate. Compared to the H adsorbate, which was rotationally invariant, CO 2 can be added to the surface with many different orientations. The orientation of the molecule to be added as an adsorbate is controlled through the coordinates of its atoms. By default, molecules are added to surfaces so that the z direction in their coordinate system corresponds to the normal to the surface. Therefore, if we want to add a CO 2 molecule in a head-on orientation, we will have to position it along the z axis, whereas if we want it to be adsorbed side-on , it will have to be positioned in the x-y plane. To investigate these possibilites, let's create three different CO 2 molecules: one oriented along the x direction, one along y , and one along z . The C-O bond length in CO 2 is 1.16 \u00c5. (For simplicity, you can define each C atom at [0, 0, 0], and then for each direction in turn, one O atom at -1.16 \u00c5 and the other one at 1.16 \u00c5, while all other coordinates are 0): We can now think about adding these molecules to the copper (1, 1, 1) surface from before. Let's start by finding all the adsorpton sites using the find_adsorption_sites() method of the AdsorbateSiteFinder class (you should already have an instance of the AdsorbateSiteFinder for the copper surface from the previous exercise). Extract the coordinates of the only \"ontop\" site returned into a new variable: We can now add the CO 2 molecule to the copper surface using the add_adsorbate() method of the AdsorbateSiteFinder class. To keep the distance between the CO 2 adsorbates larger than the size of the unit cell, set the repeat argument to [2, 2, 1] - this will repeat the slab unit cell twice in the a and b directions, while the size in the c direction will stay the same. Do this for each of the three CO 2 molecules you defined above and assign the resulting adsorption structures to new variables called x_struct , y_struct , and z_struct (where the name corresponds to the orientation of the CO 2 ): Finally, let's examine our adsorption structures! To do this, uncomment and run the cell below (it might take a while to complete): # for struc, ax, title in zip([x_struct, y_struct, z_struct], plt.subplots(1, 3, figsize=[15, 45])[1], [\"x\", \"y\", \"z\"]): # plot_slab(struc, ax, adsorption_sites=False) # ax.set_title(r\"CO$_2$ in the %s direction\" % title) # ax.set_xlim(-1, 10) # ax.set_ylim(-3, 8) # ax.set_xticks([]) # ax.set_yticks([]) # plt.show() You can now see how the three different geometries of the initial CO 2 molecule led to three very different adsorption structures - and these are just a few of the many possible orientations. (A note on the z direction plot: Since all the plots are of the plane of the surface, in the z direction case it is difficult to see the CO 2 molecule because the three atoms are stacked in the direction coming out of the plane of the plot. This is also the reason why the copper atoms look more faded than in the other two cases - they are further away from the topmost atom in the structure, so they appear more discolored in the plot.) These three adsorption structures can now be saved to cif files that you can later open in a visualization software of your choice:","title":"Working With Surfaces exercises empty"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_empty/#working-with-surfaces","text":"","title":"Working With Surfaces"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_empty/#1-building-elemental-surfaces","text":"","title":"1. Building Elemental Surfaces"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_empty/#exercise-11-silicon-1-1-1-surfaces","text":"Let's try generating the (1, 1, 1) surfaces for a diamond Silicon structure. We can start by importing the Structure class from pymatgen and reading the silicon structure from the Si.cif file: The next step is to import the SlabGenerator class from pymatgen.core.surface and then initialize it for the silicon structure, with a Miller index of (1, 1, 1), a minimum slab height of 10 \u00c5, and minimum 10 \u00c5 of vacuum: We can now get all the corresponding slabs using get_slabs() and store the returned list in a new variable: How many terminations are there now? Let's check if the two slabs are equivalent by using the matches() method for one of the two slabs and passing the other one as the argument: We can also visualize the two slabs to convince ourselves that they are different. Start by importing plot_slab and pyplot as plt and then run %matplotlib inline : Let's now plot the two slabs. Remeber to make a pyplot figure and add a subplot first. For simplicity you can write the code to plot each slab in a separate cell; if you would like more of a challenge, you can try to plot them on the same figure! Finally, let's save the two silicon (1, 1, 1) surfaces to files using the to() method with \"cif\" as the format (the fmt argument) and a filename of your choice under filename :","title":"Exercise 1.1: Silicon (1, 1, 1) surfaces"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_empty/#exercise-12-silicon-all-surfaces","text":"We can also generate all the possible surfaces up to a given Miller index. This can be achieved using the generate_all_slabs() function. We can import it from pymatgen.core.surface : Let's use this function for our Si crystal with a Miller index of up to 3, a minimum slab size of 10 \u00c5 and minimum vacuum of 10 \u00c5 and store the returned list under a new variable: How many slab structures were returned? We can investigate these surfaces further. What are their Miller indices and c shifts? Notice some Miller indices are repeated. Again, this is due to there being more than one termination. However, each Miller index + c shift combination is unique.","title":"Exercise 1.2: Silicon - All surfaces"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_empty/#2-building-compound-surfaces","text":"","title":"2. Building Compound Surfaces"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_empty/#exercise-21-tio2-all-surfaces","text":"Let's generate some rutile TiO 2 surfaces and investigate them. We can start by importing the bulk structure from TiO2.cif : We should now add the corresponding oxidation states to each element using the add_oxidation_state_by_element() method: +4 for Ti, -2 for O: Let's now generate all slabs up to a Miller index of 2, with a minimum slab size and minimum vacuum size of 10 \u00c5. How many such surfaces are there? For each of these slabs print its index, whether it is symmetric, and whether or not is polar. To do so, we can use the enumerate() function, which allows us to loop through the elements of our list and their indices at the same time: Choose a few slabs, some that are polar, some that are not, and print their dipoles (using the dipole property). You can use the indices you printed previously to access specific elements of the list. Are the values of the dipoles consistent with the polarity returned by is_polar() ?","title":"Exercise 2.1: TiO2 - all surfaces"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_empty/#exercise-22-wse2-a-layered-material","text":"Let's now think about generating slabs for a layered material, WSe 2 . You can read its structure from WSe2.cif (if you get a warning about fractional co-ordinates do not worry about it): The bulk WSe 2 structure has the layers oriented along the c direction - this means that the relevant slabs, which terminate on a layer of the material, will be along the (0, 0, 1) direction. Let's initialize the SlabGenerator for (0, 0, 1), with a minimum slab size and minimum vacuum of 10 \u00c5: To generate the slabs we have to also make sure that we are not breaking through any layers of atoms. In this case, that means we have to avoid breaking any of the W-Se bonds, which are 2.55 \u00c5 long. Get the slabs from the SlabGenerator you just created, making sure to use the bonds argument to avoid breaking any W-Se bonds. (Hint: in the dictionary you pass to the bonds argument, use a distance slightly larger than 2.55 \u00c5 to account for the rounding of this value as reported here): Let's check if our code only returned one slab, as expected: The slab you just created contains 2 layers of atoms. Let's now try to create a slab that contains 4 layers of atoms - what parameter would control this? (You can keep the vacuum size the same as before) We can print the number of sites in the original slab and the new slab, respectively, to check if the new slab has twice the number of layers. This can be done using the num_sites property of the slab:","title":"Exercise 2.2: WSe2 - a layered material"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_empty/#3-adding-adsorbates","text":"","title":"3. Adding adsorbates"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_empty/#exercise-31-adsorbates-in-the-dilute-limit","text":"While in the previous example we added one adsorbate per unit cell, in this exercise we are going to add adsorbates that are more spaced out. Let's start by importing the copper structure from the .cif file: Let's generate the (1, 1, 1) surface, with 10 \u00c5 as the minimum slab size and minimum vacuum and then extract the one slab from the returned list as a new variable: We can now import the AdsorbateSiteFinder and initialize it for the copper slab we just created. Let's make a hydrogen Molecule object that we can then add to our surface (don't forget to import the Molecule class from pymatgen first): We can now generate the adsorption structures, but this time, let's use the min_lw argument to make our slab a supercell of the original slab. Let's set min_lw to be 7 \u00c5, which will mean that the slab will be repeated multiple times in the a and b directions until it has a length and a width of at least 7 \u00c5 (the thickness of the slab i.e. the size in the c direction will remain unchanged). Notice that min_lw is an alternative to using the repeat argument we used in the lesson. Let's set the distance from the surface to the adsorbate to be 1.6 \u00c5; this can be done by setting the find_args parameter to be a dictionary with \"distance\" as the key and 1.6 as the value: Let's now visualize the first adsorption structure in the list using plot_slab() . Some hints: set the adsorption_sites argument of plot_slab() to False to not display adsorption sites use the set_xlim() and set_ylim() methods of the matplotlib axes to \"zoom in\" around the unit cell use the set_xticks() and set_yticks() methods of the matplotlib axes with an empty list as an argument to remove the ticks on the x and y axis, respectively You should now see that only a third of the corresponding equivalent adsorption sites have a hydrogen atom on them - compare this with the structures we generated during the lesson.","title":"Exercise 3.1: Adsorbates in the dilute limit"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_empty/#exercise-32-co2-as-an-adsorbate","text":"In this exercise we will look into some advanced controls for generating adsorption structures by working with CO 2 , a polyatomic adsorbate. Compared to the H adsorbate, which was rotationally invariant, CO 2 can be added to the surface with many different orientations. The orientation of the molecule to be added as an adsorbate is controlled through the coordinates of its atoms. By default, molecules are added to surfaces so that the z direction in their coordinate system corresponds to the normal to the surface. Therefore, if we want to add a CO 2 molecule in a head-on orientation, we will have to position it along the z axis, whereas if we want it to be adsorbed side-on , it will have to be positioned in the x-y plane. To investigate these possibilites, let's create three different CO 2 molecules: one oriented along the x direction, one along y , and one along z . The C-O bond length in CO 2 is 1.16 \u00c5. (For simplicity, you can define each C atom at [0, 0, 0], and then for each direction in turn, one O atom at -1.16 \u00c5 and the other one at 1.16 \u00c5, while all other coordinates are 0): We can now think about adding these molecules to the copper (1, 1, 1) surface from before. Let's start by finding all the adsorpton sites using the find_adsorption_sites() method of the AdsorbateSiteFinder class (you should already have an instance of the AdsorbateSiteFinder for the copper surface from the previous exercise). Extract the coordinates of the only \"ontop\" site returned into a new variable: We can now add the CO 2 molecule to the copper surface using the add_adsorbate() method of the AdsorbateSiteFinder class. To keep the distance between the CO 2 adsorbates larger than the size of the unit cell, set the repeat argument to [2, 2, 1] - this will repeat the slab unit cell twice in the a and b directions, while the size in the c direction will stay the same. Do this for each of the three CO 2 molecules you defined above and assign the resulting adsorption structures to new variables called x_struct , y_struct , and z_struct (where the name corresponds to the orientation of the CO 2 ): Finally, let's examine our adsorption structures! To do this, uncomment and run the cell below (it might take a while to complete): # for struc, ax, title in zip([x_struct, y_struct, z_struct], plt.subplots(1, 3, figsize=[15, 45])[1], [\"x\", \"y\", \"z\"]): # plot_slab(struc, ax, adsorption_sites=False) # ax.set_title(r\"CO$_2$ in the %s direction\" % title) # ax.set_xlim(-1, 10) # ax.set_ylim(-3, 8) # ax.set_xticks([]) # ax.set_yticks([]) # plt.show() You can now see how the three different geometries of the initial CO 2 molecule led to three very different adsorption structures - and these are just a few of the many possible orientations. (A note on the z direction plot: Since all the plots are of the plane of the surface, in the z direction case it is difficult to see the CO 2 molecule because the three atoms are stacked in the direction coming out of the plane of the plot. This is also the reason why the copper atoms look more faded than in the other two cases - they are further away from the topmost atom in the structure, so they appear more discolored in the plot.) These three adsorption structures can now be saved to cif files that you can later open in a visualization software of your choice:","title":"Exercise 3.2: CO2 as an adsorbate"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_filled/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Working With Surfaces \u00b6 1. Building Elemental Surfaces \u00b6 Exercise 1.1: Silicon (1, 1, 1) surfaces \u00b6 Let's try generating the (1, 1, 1) surfaces for a diamond Silicon structure. We can start by importing the Structure class from pymatgen and reading the silicon structure from the Si.cif file: from pymatgen import Structure Si = Structure . from_file ( \"Si.cif\" ) The next step is to import the SlabGenerator class from pymatgen.core.surface and then initialize it for the silicon structure, with a Miller index of (1, 1, 1), a minimum slab height of 10 \u00c5, and minimum 10 \u00c5 of vacuum: from pymatgen.core.surface import SlabGenerator slabgen = SlabGenerator ( Si , ( 1 , 1 , 1 ), 10 , 10 ) We can now get all the corresponding slabs using get_slabs() and store the returned list in a new variable: slabs = slabgen . get_slabs () How many terminations are there now? print ( len ( slabs )) 2 Let's check if the two slabs are equivalent by using the matches() method for one of the two slabs and passing the other one as the argument: slabs [ 0 ] . matches ( slabs [ 1 ]) False We can also visualize the two slabs to convince ourselves that they are different. Start by importing plot_slab and pyplot as plt and then run %matplotlib inline : from pymatgen.analysis.adsorption import plot_slab from matplotlib import pyplot as plt % matplotlib inline Let's now plot the two slabs. Remeber to make a pyplot figure and add a subplot first. For simplicity you can write the code to plot each slab in a separate cell; if you would like more of a challenge, you can try to plot them on the same figure! fig = plt . figure () for n , slab in enumerate ( slabs ): ax = fig . add_subplot ( 1 , len ( slabs ), n + 1 ) plot_slab ( slab , ax , adsorption_sites = False ) ax . set_title ( \"Si (1, 1, 1) surface %i \" % ( n + 1 )) ax . set_xticks ([]) ax . set_yticks ([]) plt . show () Finally, let's save the two silicon (1, 1, 1) surfaces to files using the to() method with \"cif\" as the format (the fmt argument) and a filename of your choice under filename : # Uncomment the lines below to run them: # slabs[0].to(fmt=\"cif\", filename=\"Si_111_1.json\") # slabs[1].to(fmt=\"cif\", filename=\"Si_111_2.json\") Exercise 1.2: Silicon - All surfaces \u00b6 We can also generate all the possible surfaces up to a given Miller index. This can be achieved using the generate_all_slabs() function. We can import it from pymatgen.core.surface : from pymatgen.core.surface import generate_all_slabs Let's use this function for our Si crystal with a Miller index of up to 3, a minimum slab size of 10 \u00c5 and minimum vacuum of 10 \u00c5 and store the returned list under a new variable: all_slabs = generate_all_slabs ( Si , 3 , 10 , 10 ) How many slab structures were returned? print ( len ( all_slabs )) 18 We can investigate these surfaces further. What are their Miller indices and c shifts? for slab in all_slabs : print ( slab . miller_index , slab . shift ) (1, 1, 1) 0.3750000000000001 (1, 1, 1) 0.8750000000000001 (3, 3, 2) 0.08333333333333348 (3, 3, 1) 0.1250000000000001 (3, 3, 1) 0.29166666666666685 (1, 1, 0) 0.25 (3, 2, 2) 0.04166666666666674 (3, 2, 2) 0.1250000000000001 (3, 2, 1) 0.08333333333333326 (3, 2, 0) 0.04166666666666652 (3, 1, 1) 0.04166666666666674 (3, 1, 1) 0.20833333333333337 (3, 1, 0) 0.08333333333333326 (1, 0, 0) 0.125 (2, 2, 1) 0.06250000000000011 (2, 2, 1) 0.1875000000000001 (2, 1, 1) 0.125 (2, 1, 0) 0.062499999999999944 Notice some Miller indices are repeated. Again, this is due to there being more than one termination. However, each Miller index + c shift combination is unique. 2. Building Compound Surfaces \u00b6 Exercise 2.1: TiO 2 - all surfaces \u00b6 Let's generate some rutile TiO 2 surfaces and investigate them. We can start by importing the bulk structure from TiO2.cif : TiO2 = Structure . from_file ( \"TiO2.cif\" ) We should now add the corresponding oxidation states to each element using the add_oxidation_state_by_element() method: +4 for Ti, -2 for O: TiO2 . add_oxidation_state_by_element ({ \"Ti\" : 4 , \"O\" : - 2 }) Let's now generate all slabs up to a Miller index of 2, with a minimum slab size and minimum vacuum size of 10 \u00c5. How many such surfaces are there? all_slabs = generate_all_slabs ( TiO2 , 2 , 10 , 10 ) print ( len ( all_slabs )) 26 For each of these slabs print its index, whether it is symmetric, and whether or not is polar. To do so, we can use the enumerate() function, which allows us to loop through the elements of our list and their indices at the same time: for n , slab in enumerate ( all_slabs ): print ( n , slab . is_symmetric (), slab . is_polar ()) 0 False True 1 False False 2 False True 3 False False 4 False True 5 True False 6 False True 7 False False 8 False True 9 False True 10 False True 11 True False 12 False True 13 False False 14 False True 15 False True 16 True False 17 False True 18 False False 19 False True 20 False False 21 False True 22 True False 23 False True 24 False False 25 False False Choose a few slabs, some that are polar, some that are not, and print their dipoles (using the dipole property). You can use the indices you printed previously to access specific elements of the list. Are the values of the dipoles consistent with the polarity returned by is_polar() ? # Polar slabs print ( all_slabs [ 0 ] . dipole ) print ( all_slabs [ 12 ] . dipole ) [-1.00209258e-15 -1.47680597e+01 1.63654138e+01] [-1.36766752e-15 1.11678528e+01 2.23357056e+01] # Non-polar slabs print ( all_slabs [ 1 ] . dipole ) print ( all_slabs [ 22 ] . dipole ) [9.86076132e-32 0.00000000e+00 0.00000000e+00] [-2.46519033e-31 4.44089210e-16 7.99360578e-15] Exercise 2.2: WSe 2 - a layered material \u00b6 Let's now think about generating slabs for a layered material, WSe 2 . You can read its structure from WSe2.cif (if you get a warning about fractional co-ordinates do not worry about it): WSe2 = Structure . from_file ( \"WSe2.cif\" ) /Users/ioandriuc/anaconda3/envs/cms/code/pymatgen/pymatgen/io/cif.py:1123: UserWarning: Issues encountered while parsing CIF: Some fractional co-ordinates rounded to ideal values to avoid issues with finite precision. warnings.warn(\"Issues encountered while parsing CIF: %s\" % \"\\n\".join(self.warnings)) The bulk WSe 2 structure has the layers oriented along the c direction - this means that the relevant slabs, which terminate on a layer of the material, will be along the (0, 0, 1) direction. Let's initialize the SlabGenerator for (0, 0, 1), with a minimum slab size and minimum vacuum of 10 \u00c5: slabgen = SlabGenerator ( WSe2 , ( 0 , 0 , 1 ), 10 , 10 ) To generate the slabs we have to also make sure that we are not breaking through any layers of atoms. In this case, that means we have to avoid breaking any of the W-Se bonds, which are 2.55 \u00c5 long. Get the slabs from the SlabGenerator you just created, making sure to use the bonds argument to avoid breaking any W-Se bonds. (Hint: in the dictionary you pass to the bonds argument, use a distance slightly larger than 2.55 \u00c5 to account for the rounding of this value as reported here): slabs = slabgen . get_slabs ( bonds = {( \"W\" , \"Se\" ): 3 }) Let's check if our code only returned one slab, as expected: print ( len ( slabs )) 1 The slab you just created contains 2 layers of atoms. Let's now try to create a slab that contains 4 layers of atoms - what parameter would control this? (You can keep the vacuum size the same as before) slabgen = SlabGenerator ( WSe2 , ( 0 , 0 , 1 ), 20 , 10 ) new_slabs = slabgen . get_slabs ( bonds = {( \"W\" , \"Se\" ): 3 }) new_slab = new_slabs [ 0 ] print ( new_slab ) Slab Summary (W4 Se8) Reduced Formula: WSe2 Miller index: (0, 0, 1) Shift: 0.0000, Scale Factor: [[1 0 0] [0 1 0] [0 0 1]] abc : 3.327070 3.327070 45.206853 angles: 90.000000 90.000000 120.000000 Sites (12) 1 W 0.333333 0.666667 0.083333 2 W 0.666667 0.333333 0.250000 3 Se 0.666667 0.333333 0.120523 4 Se 0.333333 0.666667 0.287190 5 Se 0.666667 0.333333 0.046144 6 Se 0.333333 0.666667 0.212810 7 W 0.333333 0.666667 0.416667 8 W 0.666667 0.333333 0.583333 9 Se 0.666667 0.333333 0.453856 10 Se 0.333333 0.666667 0.620523 11 Se 0.666667 0.333333 0.379477 12 Se 0.333333 0.666667 0.546144 We can print the number of sites in the original slab and the new slab, respectively, to check if the new slab has twice the number of layers. This can be done using the num_sites property of the slab: print ( slabs [ 0 ] . num_sites , new_slab . num_sites ) 6 12 3. Adding adsorbates \u00b6 Exercise 3.1: Adsorbates in the dilute limit \u00b6 While in the previous example we added one adsorbate per unit cell, in this exercise we are going to add adsorbates that are more spaced out. Let's start by importing the copper structure from the .cif file: Cu = Structure . from_file ( \"Cu.cif\" ) Let's generate the (1, 1, 1) surface, with 10 \u00c5 as the minimum slab size and minimum vacuum and then extract the one slab from the returned list as a new variable: slabgen = SlabGenerator ( Cu , ( 1 , 1 , 1 ), 10 , 10 ) slabs = slabgen . get_slabs () slab = slabs [ 0 ] We can now import the AdsorbateSiteFinder and initialize it for the copper slab we just created. from pymatgen.analysis.adsorption import AdsorbateSiteFinder asf = AdsorbateSiteFinder ( slab ) Let's make a hydrogen Molecule object that we can then add to our surface (don't forget to import the Molecule class from pymatgen first): from pymatgen import Molecule H = Molecule ( \"H\" , [[ 0 , 0 , 0 ]]) We can now generate the adsorption structures, but this time, let's use the min_lw argument to make our slab a supercell of the original slab. Let's set min_lw to be 7 \u00c5, which will mean that the slab will be repeated multiple times in the a and b directions until it has a length and a width of at least 7 \u00c5 (the thickness of the slab i.e. the size in the c direction will remain unchanged). Notice that min_lw is an alternative to using the repeat argument we used in the lesson. Let's set the distance from the surface to the adsorbate to be 1.6 \u00c5; this can be done by setting the find_args parameter to be a dictionary with \"distance\" as the key and 1.6 as the value: ads_structs = asf . generate_adsorption_structures ( H , min_lw = 7 , find_args = { \"distance\" : 1.6 }) Let's now visualize the first adsorption structure in the list using plot_slab() . Some hints: set the adsorption_sites argument of plot_slab() to False to not display adsorption sites use the set_xlim() and set_ylim() methods of the matplotlib axes to \"zoom in\" around the unit cell use the set_xticks() and set_yticks() methods of the matplotlib axes with an empty list as an argument to remove the ticks on the x and y axis, respectively fig = plt . figure () ax = fig . add_subplot ( 111 ) plot_slab ( ads_structs [ 0 ], ax , adsorption_sites = False ) ax . set_xlim ( - 1 , 14 ) ax . set_ylim ( - 1 , 8 ) ax . set_xticks ([]) ax . set_yticks ([]) plt . show () /Users/ioandriuc/anaconda3/envs/cms/code/pymatgen/pymatgen/core/structure.py:731: UserWarning: Not all sites have property bulk_equivalent. Missing values are set to None. \"are set to None.\" % k) /Users/ioandriuc/anaconda3/envs/cms/code/pymatgen/pymatgen/core/structure.py:731: UserWarning: Not all sites have property bulk_wyckoff. Missing values are set to None. \"are set to None.\" % k) You should now see that only a third of the corresponding equivalent adsorption sites have a hydrogen atom on them - compare this with the structures we generated during the lesson. Exercise 3.2: CO 2 as an adsorbate \u00b6 In this exercise we will look into some advanced controls for generating adsorption structures by working with CO 2 , a polyatomic adsorbate. Compared to the H adsorbate, which was rotationally invariant, CO 2 can be added to the surface with many different orientations. The orientation of the molecule to be added as an adsorbate is controlled through the coordinates of its atoms. By default, molecules are added to surfaces so that the z direction in their coordinate system corresponds to the normal to the surface. Therefore, if we want to add a CO 2 molecule in a head-on orientation, we will have to position it along the z axis, whereas if we want it to be adsorbed side-on , it will have to be positioned in the x-y plane. To investigate these possibilites, let's create three different CO 2 molecules: one oriented along the x direction, one along y , and one along z . The C-O bond length in CO 2 is 1.16 \u00c5. (For simplicity, you can define each C atom at [0, 0, 0], and then for each direction in turn, one O atom at -1.16 \u00c5 and the other one at 1.16 \u00c5, while all other coordinates are 0): CO2_x = Molecule ([ \"O\" , \"C\" , \"O\" ], [[ - 1.16 , 0 , 0 ], [ 0 , 0 , 0 ], [ 1.16 , 0 , 0 ]]) CO2_y = Molecule ([ \"O\" , \"C\" , \"O\" ], [[ 0 , - 1.16 , 0 ], [ 0 , 0 , 0 ], [ 0 , 1.16 , 0 ]]) CO2_z = Molecule ([ \"O\" , \"C\" , \"O\" ], [[ 0 , 0 , - 1.16 ], [ 0 , 0 , 0 ], [ 0 , 0 , 1.16 ]]) We can now think about adding these molecules to the copper (1, 1, 1) surface from before. Let's start by finding all the adsorpton sites using the find_adsorption_sites() method of the AdsorbateSiteFinder class (you should already have an instance of the AdsorbateSiteFinder for the copper surface from the previous exercise). Extract the coordinates of the only \"ontop\" site returned into a new variable: ads_sites = asf . find_adsorption_sites () ads_coords = ads_sites [ 'ontop' ][ 0 ] We can now add the CO 2 molecule to the copper surface using the add_adsorbate() method of the AdsorbateSiteFinder class. To keep the distance between the CO 2 adsorbates larger than the size of the unit cell, set the repeat argument to [2, 2, 1] - this will repeat the slab unit cell twice in the a and b directions, while the size in the c direction will stay the same. Do this for each of the three CO 2 molecules you defined above and assign the resulting adsorption structures to new variables called x_struct , y_struct , and z_struct (where the name corresponds to the orientation of the CO 2 ): x_struct = asf . add_adsorbate ( CO2_x , ads_coords , repeat = [ 2 , 2 , 1 ]) y_struct = asf . add_adsorbate ( CO2_y , ads_coords , repeat = [ 2 , 2 , 1 ]) z_struct = asf . add_adsorbate ( CO2_z , ads_coords , repeat = [ 2 , 2 , 1 ]) Finally, let's examine our adsorption structures! To do this, run the cell below (it might take a while to complete): for struc , ax , title in zip ([ x_struct , y_struct , z_struct ], plt . subplots ( 1 , 3 , figsize = [ 15 , 45 ])[ 1 ], [ \"x\" , \"y\" , \"z\" ]): plot_slab ( struc , ax , adsorption_sites = False ) ax . set_title ( r \"CO$_2$ in the %s direction\" % title ) ax . set_xlim ( - 1 , 10 ) ax . set_ylim ( - 3 , 8 ) ax . set_xticks ([]) ax . set_yticks ([]) plt . show () You can now see how the three different geometries of the initial CO 2 molecule led to three very different adsorption structures - and these are just a few of the many possible orientations. (A note on the z direction plot: Since all the plots are of the plane of the surface, in the z direction case it is difficult to see the CO 2 molecule because the three atoms are stacked in the direction coming out of the plane of the plot. This is also the reason why the copper atoms look more faded than in the other two cases - they are further away from the topmost atom in the structure, so they appear more discolored in the plot.) These three adsorption structures can now be saved to cif files that you can later open in a visualization software of your choice: # Uncomment the lines below to run them: # x_struct.to(fmt=\"cif\", filename=\"Cu_CO2_x.cif\") # y_struct.to(fmt=\"cif\", filename=\"Cu_CO2_y.cif\") # z_struct.to(fmt=\"cif\", filename=\"Cu_CO2_z.cif\")","title":"Working With Surfaces exercises filled"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_filled/#working-with-surfaces","text":"","title":"Working With Surfaces"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_filled/#1-building-elemental-surfaces","text":"","title":"1. Building Elemental Surfaces"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_filled/#exercise-11-silicon-1-1-1-surfaces","text":"Let's try generating the (1, 1, 1) surfaces for a diamond Silicon structure. We can start by importing the Structure class from pymatgen and reading the silicon structure from the Si.cif file: from pymatgen import Structure Si = Structure . from_file ( \"Si.cif\" ) The next step is to import the SlabGenerator class from pymatgen.core.surface and then initialize it for the silicon structure, with a Miller index of (1, 1, 1), a minimum slab height of 10 \u00c5, and minimum 10 \u00c5 of vacuum: from pymatgen.core.surface import SlabGenerator slabgen = SlabGenerator ( Si , ( 1 , 1 , 1 ), 10 , 10 ) We can now get all the corresponding slabs using get_slabs() and store the returned list in a new variable: slabs = slabgen . get_slabs () How many terminations are there now? print ( len ( slabs )) 2 Let's check if the two slabs are equivalent by using the matches() method for one of the two slabs and passing the other one as the argument: slabs [ 0 ] . matches ( slabs [ 1 ]) False We can also visualize the two slabs to convince ourselves that they are different. Start by importing plot_slab and pyplot as plt and then run %matplotlib inline : from pymatgen.analysis.adsorption import plot_slab from matplotlib import pyplot as plt % matplotlib inline Let's now plot the two slabs. Remeber to make a pyplot figure and add a subplot first. For simplicity you can write the code to plot each slab in a separate cell; if you would like more of a challenge, you can try to plot them on the same figure! fig = plt . figure () for n , slab in enumerate ( slabs ): ax = fig . add_subplot ( 1 , len ( slabs ), n + 1 ) plot_slab ( slab , ax , adsorption_sites = False ) ax . set_title ( \"Si (1, 1, 1) surface %i \" % ( n + 1 )) ax . set_xticks ([]) ax . set_yticks ([]) plt . show () Finally, let's save the two silicon (1, 1, 1) surfaces to files using the to() method with \"cif\" as the format (the fmt argument) and a filename of your choice under filename : # Uncomment the lines below to run them: # slabs[0].to(fmt=\"cif\", filename=\"Si_111_1.json\") # slabs[1].to(fmt=\"cif\", filename=\"Si_111_2.json\")","title":"Exercise 1.1: Silicon (1, 1, 1) surfaces"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_filled/#exercise-12-silicon-all-surfaces","text":"We can also generate all the possible surfaces up to a given Miller index. This can be achieved using the generate_all_slabs() function. We can import it from pymatgen.core.surface : from pymatgen.core.surface import generate_all_slabs Let's use this function for our Si crystal with a Miller index of up to 3, a minimum slab size of 10 \u00c5 and minimum vacuum of 10 \u00c5 and store the returned list under a new variable: all_slabs = generate_all_slabs ( Si , 3 , 10 , 10 ) How many slab structures were returned? print ( len ( all_slabs )) 18 We can investigate these surfaces further. What are their Miller indices and c shifts? for slab in all_slabs : print ( slab . miller_index , slab . shift ) (1, 1, 1) 0.3750000000000001 (1, 1, 1) 0.8750000000000001 (3, 3, 2) 0.08333333333333348 (3, 3, 1) 0.1250000000000001 (3, 3, 1) 0.29166666666666685 (1, 1, 0) 0.25 (3, 2, 2) 0.04166666666666674 (3, 2, 2) 0.1250000000000001 (3, 2, 1) 0.08333333333333326 (3, 2, 0) 0.04166666666666652 (3, 1, 1) 0.04166666666666674 (3, 1, 1) 0.20833333333333337 (3, 1, 0) 0.08333333333333326 (1, 0, 0) 0.125 (2, 2, 1) 0.06250000000000011 (2, 2, 1) 0.1875000000000001 (2, 1, 1) 0.125 (2, 1, 0) 0.062499999999999944 Notice some Miller indices are repeated. Again, this is due to there being more than one termination. However, each Miller index + c shift combination is unique.","title":"Exercise 1.2: Silicon - All surfaces"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_filled/#2-building-compound-surfaces","text":"","title":"2. Building Compound Surfaces"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_filled/#exercise-21-tio2-all-surfaces","text":"Let's generate some rutile TiO 2 surfaces and investigate them. We can start by importing the bulk structure from TiO2.cif : TiO2 = Structure . from_file ( \"TiO2.cif\" ) We should now add the corresponding oxidation states to each element using the add_oxidation_state_by_element() method: +4 for Ti, -2 for O: TiO2 . add_oxidation_state_by_element ({ \"Ti\" : 4 , \"O\" : - 2 }) Let's now generate all slabs up to a Miller index of 2, with a minimum slab size and minimum vacuum size of 10 \u00c5. How many such surfaces are there? all_slabs = generate_all_slabs ( TiO2 , 2 , 10 , 10 ) print ( len ( all_slabs )) 26 For each of these slabs print its index, whether it is symmetric, and whether or not is polar. To do so, we can use the enumerate() function, which allows us to loop through the elements of our list and their indices at the same time: for n , slab in enumerate ( all_slabs ): print ( n , slab . is_symmetric (), slab . is_polar ()) 0 False True 1 False False 2 False True 3 False False 4 False True 5 True False 6 False True 7 False False 8 False True 9 False True 10 False True 11 True False 12 False True 13 False False 14 False True 15 False True 16 True False 17 False True 18 False False 19 False True 20 False False 21 False True 22 True False 23 False True 24 False False 25 False False Choose a few slabs, some that are polar, some that are not, and print their dipoles (using the dipole property). You can use the indices you printed previously to access specific elements of the list. Are the values of the dipoles consistent with the polarity returned by is_polar() ? # Polar slabs print ( all_slabs [ 0 ] . dipole ) print ( all_slabs [ 12 ] . dipole ) [-1.00209258e-15 -1.47680597e+01 1.63654138e+01] [-1.36766752e-15 1.11678528e+01 2.23357056e+01] # Non-polar slabs print ( all_slabs [ 1 ] . dipole ) print ( all_slabs [ 22 ] . dipole ) [9.86076132e-32 0.00000000e+00 0.00000000e+00] [-2.46519033e-31 4.44089210e-16 7.99360578e-15]","title":"Exercise 2.1: TiO2 - all surfaces"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_filled/#exercise-22-wse2-a-layered-material","text":"Let's now think about generating slabs for a layered material, WSe 2 . You can read its structure from WSe2.cif (if you get a warning about fractional co-ordinates do not worry about it): WSe2 = Structure . from_file ( \"WSe2.cif\" ) /Users/ioandriuc/anaconda3/envs/cms/code/pymatgen/pymatgen/io/cif.py:1123: UserWarning: Issues encountered while parsing CIF: Some fractional co-ordinates rounded to ideal values to avoid issues with finite precision. warnings.warn(\"Issues encountered while parsing CIF: %s\" % \"\\n\".join(self.warnings)) The bulk WSe 2 structure has the layers oriented along the c direction - this means that the relevant slabs, which terminate on a layer of the material, will be along the (0, 0, 1) direction. Let's initialize the SlabGenerator for (0, 0, 1), with a minimum slab size and minimum vacuum of 10 \u00c5: slabgen = SlabGenerator ( WSe2 , ( 0 , 0 , 1 ), 10 , 10 ) To generate the slabs we have to also make sure that we are not breaking through any layers of atoms. In this case, that means we have to avoid breaking any of the W-Se bonds, which are 2.55 \u00c5 long. Get the slabs from the SlabGenerator you just created, making sure to use the bonds argument to avoid breaking any W-Se bonds. (Hint: in the dictionary you pass to the bonds argument, use a distance slightly larger than 2.55 \u00c5 to account for the rounding of this value as reported here): slabs = slabgen . get_slabs ( bonds = {( \"W\" , \"Se\" ): 3 }) Let's check if our code only returned one slab, as expected: print ( len ( slabs )) 1 The slab you just created contains 2 layers of atoms. Let's now try to create a slab that contains 4 layers of atoms - what parameter would control this? (You can keep the vacuum size the same as before) slabgen = SlabGenerator ( WSe2 , ( 0 , 0 , 1 ), 20 , 10 ) new_slabs = slabgen . get_slabs ( bonds = {( \"W\" , \"Se\" ): 3 }) new_slab = new_slabs [ 0 ] print ( new_slab ) Slab Summary (W4 Se8) Reduced Formula: WSe2 Miller index: (0, 0, 1) Shift: 0.0000, Scale Factor: [[1 0 0] [0 1 0] [0 0 1]] abc : 3.327070 3.327070 45.206853 angles: 90.000000 90.000000 120.000000 Sites (12) 1 W 0.333333 0.666667 0.083333 2 W 0.666667 0.333333 0.250000 3 Se 0.666667 0.333333 0.120523 4 Se 0.333333 0.666667 0.287190 5 Se 0.666667 0.333333 0.046144 6 Se 0.333333 0.666667 0.212810 7 W 0.333333 0.666667 0.416667 8 W 0.666667 0.333333 0.583333 9 Se 0.666667 0.333333 0.453856 10 Se 0.333333 0.666667 0.620523 11 Se 0.666667 0.333333 0.379477 12 Se 0.333333 0.666667 0.546144 We can print the number of sites in the original slab and the new slab, respectively, to check if the new slab has twice the number of layers. This can be done using the num_sites property of the slab: print ( slabs [ 0 ] . num_sites , new_slab . num_sites ) 6 12","title":"Exercise 2.2: WSe2 - a layered material"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_filled/#3-adding-adsorbates","text":"","title":"3. Adding adsorbates"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_filled/#exercise-31-adsorbates-in-the-dilute-limit","text":"While in the previous example we added one adsorbate per unit cell, in this exercise we are going to add adsorbates that are more spaced out. Let's start by importing the copper structure from the .cif file: Cu = Structure . from_file ( \"Cu.cif\" ) Let's generate the (1, 1, 1) surface, with 10 \u00c5 as the minimum slab size and minimum vacuum and then extract the one slab from the returned list as a new variable: slabgen = SlabGenerator ( Cu , ( 1 , 1 , 1 ), 10 , 10 ) slabs = slabgen . get_slabs () slab = slabs [ 0 ] We can now import the AdsorbateSiteFinder and initialize it for the copper slab we just created. from pymatgen.analysis.adsorption import AdsorbateSiteFinder asf = AdsorbateSiteFinder ( slab ) Let's make a hydrogen Molecule object that we can then add to our surface (don't forget to import the Molecule class from pymatgen first): from pymatgen import Molecule H = Molecule ( \"H\" , [[ 0 , 0 , 0 ]]) We can now generate the adsorption structures, but this time, let's use the min_lw argument to make our slab a supercell of the original slab. Let's set min_lw to be 7 \u00c5, which will mean that the slab will be repeated multiple times in the a and b directions until it has a length and a width of at least 7 \u00c5 (the thickness of the slab i.e. the size in the c direction will remain unchanged). Notice that min_lw is an alternative to using the repeat argument we used in the lesson. Let's set the distance from the surface to the adsorbate to be 1.6 \u00c5; this can be done by setting the find_args parameter to be a dictionary with \"distance\" as the key and 1.6 as the value: ads_structs = asf . generate_adsorption_structures ( H , min_lw = 7 , find_args = { \"distance\" : 1.6 }) Let's now visualize the first adsorption structure in the list using plot_slab() . Some hints: set the adsorption_sites argument of plot_slab() to False to not display adsorption sites use the set_xlim() and set_ylim() methods of the matplotlib axes to \"zoom in\" around the unit cell use the set_xticks() and set_yticks() methods of the matplotlib axes with an empty list as an argument to remove the ticks on the x and y axis, respectively fig = plt . figure () ax = fig . add_subplot ( 111 ) plot_slab ( ads_structs [ 0 ], ax , adsorption_sites = False ) ax . set_xlim ( - 1 , 14 ) ax . set_ylim ( - 1 , 8 ) ax . set_xticks ([]) ax . set_yticks ([]) plt . show () /Users/ioandriuc/anaconda3/envs/cms/code/pymatgen/pymatgen/core/structure.py:731: UserWarning: Not all sites have property bulk_equivalent. Missing values are set to None. \"are set to None.\" % k) /Users/ioandriuc/anaconda3/envs/cms/code/pymatgen/pymatgen/core/structure.py:731: UserWarning: Not all sites have property bulk_wyckoff. Missing values are set to None. \"are set to None.\" % k) You should now see that only a third of the corresponding equivalent adsorption sites have a hydrogen atom on them - compare this with the structures we generated during the lesson.","title":"Exercise 3.1: Adsorbates in the dilute limit"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_exercises_filled/#exercise-32-co2-as-an-adsorbate","text":"In this exercise we will look into some advanced controls for generating adsorption structures by working with CO 2 , a polyatomic adsorbate. Compared to the H adsorbate, which was rotationally invariant, CO 2 can be added to the surface with many different orientations. The orientation of the molecule to be added as an adsorbate is controlled through the coordinates of its atoms. By default, molecules are added to surfaces so that the z direction in their coordinate system corresponds to the normal to the surface. Therefore, if we want to add a CO 2 molecule in a head-on orientation, we will have to position it along the z axis, whereas if we want it to be adsorbed side-on , it will have to be positioned in the x-y plane. To investigate these possibilites, let's create three different CO 2 molecules: one oriented along the x direction, one along y , and one along z . The C-O bond length in CO 2 is 1.16 \u00c5. (For simplicity, you can define each C atom at [0, 0, 0], and then for each direction in turn, one O atom at -1.16 \u00c5 and the other one at 1.16 \u00c5, while all other coordinates are 0): CO2_x = Molecule ([ \"O\" , \"C\" , \"O\" ], [[ - 1.16 , 0 , 0 ], [ 0 , 0 , 0 ], [ 1.16 , 0 , 0 ]]) CO2_y = Molecule ([ \"O\" , \"C\" , \"O\" ], [[ 0 , - 1.16 , 0 ], [ 0 , 0 , 0 ], [ 0 , 1.16 , 0 ]]) CO2_z = Molecule ([ \"O\" , \"C\" , \"O\" ], [[ 0 , 0 , - 1.16 ], [ 0 , 0 , 0 ], [ 0 , 0 , 1.16 ]]) We can now think about adding these molecules to the copper (1, 1, 1) surface from before. Let's start by finding all the adsorpton sites using the find_adsorption_sites() method of the AdsorbateSiteFinder class (you should already have an instance of the AdsorbateSiteFinder for the copper surface from the previous exercise). Extract the coordinates of the only \"ontop\" site returned into a new variable: ads_sites = asf . find_adsorption_sites () ads_coords = ads_sites [ 'ontop' ][ 0 ] We can now add the CO 2 molecule to the copper surface using the add_adsorbate() method of the AdsorbateSiteFinder class. To keep the distance between the CO 2 adsorbates larger than the size of the unit cell, set the repeat argument to [2, 2, 1] - this will repeat the slab unit cell twice in the a and b directions, while the size in the c direction will stay the same. Do this for each of the three CO 2 molecules you defined above and assign the resulting adsorption structures to new variables called x_struct , y_struct , and z_struct (where the name corresponds to the orientation of the CO 2 ): x_struct = asf . add_adsorbate ( CO2_x , ads_coords , repeat = [ 2 , 2 , 1 ]) y_struct = asf . add_adsorbate ( CO2_y , ads_coords , repeat = [ 2 , 2 , 1 ]) z_struct = asf . add_adsorbate ( CO2_z , ads_coords , repeat = [ 2 , 2 , 1 ]) Finally, let's examine our adsorption structures! To do this, run the cell below (it might take a while to complete): for struc , ax , title in zip ([ x_struct , y_struct , z_struct ], plt . subplots ( 1 , 3 , figsize = [ 15 , 45 ])[ 1 ], [ \"x\" , \"y\" , \"z\" ]): plot_slab ( struc , ax , adsorption_sites = False ) ax . set_title ( r \"CO$_2$ in the %s direction\" % title ) ax . set_xlim ( - 1 , 10 ) ax . set_ylim ( - 3 , 8 ) ax . set_xticks ([]) ax . set_yticks ([]) plt . show () You can now see how the three different geometries of the initial CO 2 molecule led to three very different adsorption structures - and these are just a few of the many possible orientations. (A note on the z direction plot: Since all the plots are of the plane of the surface, in the z direction case it is difficult to see the CO 2 molecule because the three atoms are stacked in the direction coming out of the plane of the plot. This is also the reason why the copper atoms look more faded than in the other two cases - they are further away from the topmost atom in the structure, so they appear more discolored in the plot.) These three adsorption structures can now be saved to cif files that you can later open in a visualization software of your choice: # Uncomment the lines below to run them: # x_struct.to(fmt=\"cif\", filename=\"Cu_CO2_x.cif\") # y_struct.to(fmt=\"cif\", filename=\"Cu_CO2_y.cif\") # z_struct.to(fmt=\"cif\", filename=\"Cu_CO2_z.cif\")","title":"Exercise 3.2: CO2 as an adsorbate"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_lesson/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Working With Surfaces \u00b6 1. Building Elemental Surfaces \u00b6 In this lesson and in the corresponding exercises we will learn how to generate specific surfaces of elemental materials, as well as all possible surfaces up to a certain Miller index. Copper: (1, 1, 1) surface For our first example we will generate a copper (1, 1, 1) surface. Let's start by importing a Cu structure from a .cif file. from pymatgen.core.structure import Structure Cu = Structure . from_file ( \"Cu.cif\" ) We can now start thinking about how to represent surfaces: in pymatgen , this is done through slabs. A slab is a cell containing a few layers of atoms and vacuum, where the termination corresponds to the surface we are interested in. Here is an example of a Cu slab corresponding to a (1, 1, 1) surface: If we visualize multiple slabs instead of just one, we can see how the surface-like structure arises. Here is the same slab from above, copied 15 times in the x and y directions, and twice in the z direction: Let's now try to generate surfaces using the SlabGenerator class. from pymatgen.core.surface import SlabGenerator Let's initialize it for the Cu structure we just created, with a Miller index of (1, 1, 1), a minimum slab height of 10 \u00c5, and minimum 10 \u00c5 of vacuum. slabgen = SlabGenerator ( Cu , ( 1 , 1 , 1 ), 10 , 10 ) We can now use the get_slabs() method of the SlabGenerator class to create a list of Slab objects. The slabs returned by get_slabs() in this case correspond to all the unique terminations along the normal to the Miller plane we are interested in. For example, for the Cu (1, 1, 1) case, the algorithm will find all the unique terminations that are parallel to the (1, 1, 1) plane i.e. perpendicular to the normal. The different resulting slabs are characterized by different c shifts: slabs = slabgen . get_slabs () For a fcc structure such as the Cu structure we are working with, there should only be only one unique (1, 1, 1) surface. We can check if that is the case: print ( len ( slabs )) 1 We can print the Miller index of this surface, as well as the c shift value: Cu_111 = slabs [ 0 ] print ( Cu_111 . miller_index , Cu_111 . shift ) (1, 1, 1) 0.5 Let's now visualize the surface we just generated. For this, we can use the plot_slab function and we will also need to import pyplot , a python plotting framework. from pymatgen.analysis.adsorption import plot_slab from matplotlib import pyplot as plt % matplotlib inline We can now plot our surface: fig = plt . figure () ax = fig . add_subplot ( 1 , 1 , 1 ) plot_slab ( Cu_111 , ax , adsorption_sites = False ) ax . set_title ( \"Cu (1, 1, 1) surface\" ) ax . set_xticks ([]) ax . set_yticks ([]) plt . show () 2. Building Compound Surfaces \u00b6 In this part of the tutorial we will extend what we learned about generating elemental surfaces to compound materials by accounting for the additional complexity of such systems. Let's try something a little more complicated, say LiFePO 4 : LiFePO4 = Structure . from_file ( \"LiFePO4.cif\" ) Let's add some oxidation states to LiFePO 4 , this will be important when we want to take surface polarity into consideration: LiFePO4 . add_oxidation_state_by_element ({ \"Fe\" : 2 , \"Li\" : 1 , \"P\" : 5 , \"O\" : - 2 }) We can now initialize an instance of the SlabGenerator class, let's choose a Miller index of (0, 0, 1) and the same minimum slab size and minimum vacuum of 10 \u00c5: slabgen = SlabGenerator ( LiFePO4 , ( 0 , 0 , 1 ), 10 , 10 ) We can now use get_slabs() to generate our (0, 0, 1) slabs. Unlike before, when generating a slab of LiFePO 4 , we also want to be careful not break any of the P-O bonds - these bonds are strong enough that they will result in a significantly high surface energy when broken. To implement this, we add the bonds parameter to get_slabs() , a dictionary where the key will be a tuple of the two atoms whose bonds we do not want to break and the element of that value would be their maximum bond length in \u00c5. This means that any bond between P and O less than 2 \u00c5 cannot be broken when generating slabs. slabs = slabgen . get_slabs ( bonds = {( \"P\" , \"O\" ): 2 }) How many (0, 0, 1) slabs that do not break any P-O bonds are there? print ( len ( slabs )) 5 There are a couple of other things to keep in mind when working with slabs: First off, if we want to calculate the surface energy, we need to ensure that the slabs have the same surface on both sides i.e. they contain inversion symmetry. We can check whether that is the case by using the is_symmetric() property of our slab object. If the top and bottom surface of the slab were different, we would only be able to calculate the average surface energy of the two different terminations in our slab, rather than the surface energy of the one termination we are interested in. Secondly, for structures containing oxidation states, a good thing to check for is whether our surfaces are polar. A polar termination will lead to a very high surface energy, so we might want to skip those particular structures in any calculations we want to carry out. We can check polarity using the is_polar() property of our slab object. for n , slab in enumerate ( slabs ): print ( n , slab . is_polar (), slab . is_symmetric ()) 0 True False 1 True False 2 True False 3 True False 4 False False Notice that none of the terminations in the (0, 0, 1) direction simultaneously satisfy our two criteria so a (0, 0, 1) surface with a reasonable surface energy cannot be calculated. Now let's generate all possible slabs for a maximum Miller index of 2 for LiFePO 4 and see if any of these surfaces can be calculated to yield reasonable and accurate surface energy values. This may take a while. from pymatgen.core.surface import generate_all_slabs all_slabs = generate_all_slabs ( LiFePO4 , 2 , 10 , 10 , bonds = {( \"P\" , \"O\" ): 2 }) Let's now select the surfaces that satisfy our aforementioned criteria and see how many of them there are compared to the total number of generated slabs: valid_slabs = [] for slab in all_slabs : if not slab . is_polar () and slab . is_symmetric (): valid_slabs . append ( slab ) print ( len ( all_slabs ), len ( valid_slabs )) 91 2 3. Adding adsorbates \u00b6 Now that we have learned how to generate various types of surfaces, in this part of the tutorial we will learn how to find adsorption sites and generate adsorption structures. In order to find adsorption sites and generate adsorption structures, we will use the AdsorbateSiteFinder : from pymatgen.analysis.adsorption import AdsorbateSiteFinder Let's now use our Cu structure to add adsorbates to different surfaces. We can start with our previously generated Cu (1, 1, 1) surface and make an instance of the AdsorbateSiteFinder : asf = AdsorbateSiteFinder ( Cu_111 ) By default, the three types of adsorption sites identified using pymatgen are: on top - positioned on top of a surface atom bridge - positioned between two surface atoms hollow - positioned between three surface atoms Let's use the find_adsorption_sites() method to find the relevant adsorption sites on our copper surface: ads_sites = asf . find_adsorption_sites () print ( ads_sites ) {'ontop': [array([ 3.13253096, 1.81308338, 11.69272977])], 'bridge': [array([ 1.85461237, 1.81308338, 11.61452242])], 'hollow': [array([ 0.57988459, 0.33563247, 11.48417684]), array([ 1.85620778, 1.07435792, 11.58845331])], 'all': [array([ 3.13253096, 1.81308338, 11.69272977]), array([ 1.85461237, 1.81308338, 11.61452242]), array([ 0.57988459, 0.33563247, 11.48417684]), array([ 1.85620778, 1.07435792, 11.58845331])]} You can see that there is a total of 4 adsorption sites: one \"on top\", one \"bridge\" and two \"hollow\". Let's now visualize these adsorption sites, using plot_slab() : fig = plt . figure () ax = fig . add_subplot ( 1 , 1 , 1 ) plot_slab ( Cu_111 , ax , adsorption_sites = True ) plt . show () We can now move on to adding adsorbates. Let's start by making a H molecule, that we can use as an adsorbate: from pymatgen.core.structure import Molecule adsorbate = Molecule ( \"H\" , [[ 0 , 0 , 0 ]]) We can now use the generate_adsorption_structures() method to create adsorption structures corresponding to the 4 adsorption sites we identified. Let's keep the same slab size by setting the repeat argument to [1, 1, 1]. We can control the distance between the adsorbate and the slab using the \"distance\" key in the dictionary passed to the find_args argument - let's make this 1.6 \u00c5: ads_structs = asf . generate_adsorption_structures ( adsorbate , repeat = [ 1 , 1 , 1 ], find_args = { \"distance\" : 1.6 }) Let's visualize our new adsorption structures: fig = plt . figure ( figsize = [ 15 , 60 ]) for n , ads_struct in enumerate ( ads_structs ): ax = fig . add_subplot ( 1 , 4 , n + 1 ) plot_slab ( ads_struct , ax , adsorption_sites = False ) ax . set_title ( \"Cu (1, 1, 1) + H structure %i \" % ( n + 1 )) ax . set_xticks ([]) ax . set_yticks ([]) ax . set_xlim ( 0 , 5 ) ax . set_ylim ( - 1 , 4 ) plt . show ()","title":"Working with Surfaces"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_lesson/#working-with-surfaces","text":"","title":"Working With Surfaces"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_lesson/#1-building-elemental-surfaces","text":"In this lesson and in the corresponding exercises we will learn how to generate specific surfaces of elemental materials, as well as all possible surfaces up to a certain Miller index. Copper: (1, 1, 1) surface For our first example we will generate a copper (1, 1, 1) surface. Let's start by importing a Cu structure from a .cif file. from pymatgen.core.structure import Structure Cu = Structure . from_file ( \"Cu.cif\" ) We can now start thinking about how to represent surfaces: in pymatgen , this is done through slabs. A slab is a cell containing a few layers of atoms and vacuum, where the termination corresponds to the surface we are interested in. Here is an example of a Cu slab corresponding to a (1, 1, 1) surface: If we visualize multiple slabs instead of just one, we can see how the surface-like structure arises. Here is the same slab from above, copied 15 times in the x and y directions, and twice in the z direction: Let's now try to generate surfaces using the SlabGenerator class. from pymatgen.core.surface import SlabGenerator Let's initialize it for the Cu structure we just created, with a Miller index of (1, 1, 1), a minimum slab height of 10 \u00c5, and minimum 10 \u00c5 of vacuum. slabgen = SlabGenerator ( Cu , ( 1 , 1 , 1 ), 10 , 10 ) We can now use the get_slabs() method of the SlabGenerator class to create a list of Slab objects. The slabs returned by get_slabs() in this case correspond to all the unique terminations along the normal to the Miller plane we are interested in. For example, for the Cu (1, 1, 1) case, the algorithm will find all the unique terminations that are parallel to the (1, 1, 1) plane i.e. perpendicular to the normal. The different resulting slabs are characterized by different c shifts: slabs = slabgen . get_slabs () For a fcc structure such as the Cu structure we are working with, there should only be only one unique (1, 1, 1) surface. We can check if that is the case: print ( len ( slabs )) 1 We can print the Miller index of this surface, as well as the c shift value: Cu_111 = slabs [ 0 ] print ( Cu_111 . miller_index , Cu_111 . shift ) (1, 1, 1) 0.5 Let's now visualize the surface we just generated. For this, we can use the plot_slab function and we will also need to import pyplot , a python plotting framework. from pymatgen.analysis.adsorption import plot_slab from matplotlib import pyplot as plt % matplotlib inline We can now plot our surface: fig = plt . figure () ax = fig . add_subplot ( 1 , 1 , 1 ) plot_slab ( Cu_111 , ax , adsorption_sites = False ) ax . set_title ( \"Cu (1, 1, 1) surface\" ) ax . set_xticks ([]) ax . set_yticks ([]) plt . show ()","title":"1. Building Elemental Surfaces"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_lesson/#2-building-compound-surfaces","text":"In this part of the tutorial we will extend what we learned about generating elemental surfaces to compound materials by accounting for the additional complexity of such systems. Let's try something a little more complicated, say LiFePO 4 : LiFePO4 = Structure . from_file ( \"LiFePO4.cif\" ) Let's add some oxidation states to LiFePO 4 , this will be important when we want to take surface polarity into consideration: LiFePO4 . add_oxidation_state_by_element ({ \"Fe\" : 2 , \"Li\" : 1 , \"P\" : 5 , \"O\" : - 2 }) We can now initialize an instance of the SlabGenerator class, let's choose a Miller index of (0, 0, 1) and the same minimum slab size and minimum vacuum of 10 \u00c5: slabgen = SlabGenerator ( LiFePO4 , ( 0 , 0 , 1 ), 10 , 10 ) We can now use get_slabs() to generate our (0, 0, 1) slabs. Unlike before, when generating a slab of LiFePO 4 , we also want to be careful not break any of the P-O bonds - these bonds are strong enough that they will result in a significantly high surface energy when broken. To implement this, we add the bonds parameter to get_slabs() , a dictionary where the key will be a tuple of the two atoms whose bonds we do not want to break and the element of that value would be their maximum bond length in \u00c5. This means that any bond between P and O less than 2 \u00c5 cannot be broken when generating slabs. slabs = slabgen . get_slabs ( bonds = {( \"P\" , \"O\" ): 2 }) How many (0, 0, 1) slabs that do not break any P-O bonds are there? print ( len ( slabs )) 5 There are a couple of other things to keep in mind when working with slabs: First off, if we want to calculate the surface energy, we need to ensure that the slabs have the same surface on both sides i.e. they contain inversion symmetry. We can check whether that is the case by using the is_symmetric() property of our slab object. If the top and bottom surface of the slab were different, we would only be able to calculate the average surface energy of the two different terminations in our slab, rather than the surface energy of the one termination we are interested in. Secondly, for structures containing oxidation states, a good thing to check for is whether our surfaces are polar. A polar termination will lead to a very high surface energy, so we might want to skip those particular structures in any calculations we want to carry out. We can check polarity using the is_polar() property of our slab object. for n , slab in enumerate ( slabs ): print ( n , slab . is_polar (), slab . is_symmetric ()) 0 True False 1 True False 2 True False 3 True False 4 False False Notice that none of the terminations in the (0, 0, 1) direction simultaneously satisfy our two criteria so a (0, 0, 1) surface with a reasonable surface energy cannot be calculated. Now let's generate all possible slabs for a maximum Miller index of 2 for LiFePO 4 and see if any of these surfaces can be calculated to yield reasonable and accurate surface energy values. This may take a while. from pymatgen.core.surface import generate_all_slabs all_slabs = generate_all_slabs ( LiFePO4 , 2 , 10 , 10 , bonds = {( \"P\" , \"O\" ): 2 }) Let's now select the surfaces that satisfy our aforementioned criteria and see how many of them there are compared to the total number of generated slabs: valid_slabs = [] for slab in all_slabs : if not slab . is_polar () and slab . is_symmetric (): valid_slabs . append ( slab ) print ( len ( all_slabs ), len ( valid_slabs )) 91 2","title":"2. Building Compound Surfaces"},{"location":"lessons/03_surfaces/Working%20With%20Surfaces_lesson/#3-adding-adsorbates","text":"Now that we have learned how to generate various types of surfaces, in this part of the tutorial we will learn how to find adsorption sites and generate adsorption structures. In order to find adsorption sites and generate adsorption structures, we will use the AdsorbateSiteFinder : from pymatgen.analysis.adsorption import AdsorbateSiteFinder Let's now use our Cu structure to add adsorbates to different surfaces. We can start with our previously generated Cu (1, 1, 1) surface and make an instance of the AdsorbateSiteFinder : asf = AdsorbateSiteFinder ( Cu_111 ) By default, the three types of adsorption sites identified using pymatgen are: on top - positioned on top of a surface atom bridge - positioned between two surface atoms hollow - positioned between three surface atoms Let's use the find_adsorption_sites() method to find the relevant adsorption sites on our copper surface: ads_sites = asf . find_adsorption_sites () print ( ads_sites ) {'ontop': [array([ 3.13253096, 1.81308338, 11.69272977])], 'bridge': [array([ 1.85461237, 1.81308338, 11.61452242])], 'hollow': [array([ 0.57988459, 0.33563247, 11.48417684]), array([ 1.85620778, 1.07435792, 11.58845331])], 'all': [array([ 3.13253096, 1.81308338, 11.69272977]), array([ 1.85461237, 1.81308338, 11.61452242]), array([ 0.57988459, 0.33563247, 11.48417684]), array([ 1.85620778, 1.07435792, 11.58845331])]} You can see that there is a total of 4 adsorption sites: one \"on top\", one \"bridge\" and two \"hollow\". Let's now visualize these adsorption sites, using plot_slab() : fig = plt . figure () ax = fig . add_subplot ( 1 , 1 , 1 ) plot_slab ( Cu_111 , ax , adsorption_sites = True ) plt . show () We can now move on to adding adsorbates. Let's start by making a H molecule, that we can use as an adsorbate: from pymatgen.core.structure import Molecule adsorbate = Molecule ( \"H\" , [[ 0 , 0 , 0 ]]) We can now use the generate_adsorption_structures() method to create adsorption structures corresponding to the 4 adsorption sites we identified. Let's keep the same slab size by setting the repeat argument to [1, 1, 1]. We can control the distance between the adsorbate and the slab using the \"distance\" key in the dictionary passed to the find_args argument - let's make this 1.6 \u00c5: ads_structs = asf . generate_adsorption_structures ( adsorbate , repeat = [ 1 , 1 , 1 ], find_args = { \"distance\" : 1.6 }) Let's visualize our new adsorption structures: fig = plt . figure ( figsize = [ 15 , 60 ]) for n , ads_struct in enumerate ( ads_structs ): ax = fig . add_subplot ( 1 , 4 , n + 1 ) plot_slab ( ads_struct , ax , adsorption_sites = False ) ax . set_title ( \"Cu (1, 1, 1) + H structure %i \" % ( n + 1 )) ax . set_xticks ([]) ax . set_yticks ([]) ax . set_xlim ( 0 , 5 ) ax . set_ylim ( - 1 , 4 ) plt . show ()","title":"3. Adding adsorbates"},{"location":"lessons/04_materials_api/MAPI%20Exercise%201/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Materials API - Exercise 1 \u00b6 In this excercise, your task is to plot the distribution of crystal systems (cubic, tetragonal, monoclinic, etc) within all SiO _2 _2 compounds. You will do this through the following 3 steps: Retrieve the spacegroup entries in the MP database with the formula SiO _2 _2 Collect their crystal systems Plot a bar chart with the data Step 1: Retrieve the spacegroup entries in the MP database with the formula SiO _2 _2 \u00b6 Use the Materials API to get the \"structure\" property for all SiO _2 _2 compounds. Hint: use the query method of the MPRester . # Your code here Step 2: Extract the crystal_system property for the entries we retrieved into a list \u00b6 Hint: \"crystal_system\" is a subkey of the spacegroup property. # Your code here Step 3: Process the data and plot the results \u00b6 Our data is currently a list of crystal systems. Your task now is to create a \"count_dict\" where each key is the name of the crystal system and it's value is the count for that crystal system. Once you have written code to create count_dict , you the cell beneath it will plot the data for you. Hint: Iterate through the list of crystal_systems you just created using a for loop and check if they are already in the dictionary before updating any entries. count_dict = {} # Your code here import matplotlib.pyplot as plt % matplotlib inline # The code below plots the distribution plt . bar ( range ( len ( count_dict )), count_dict . values (), align = 'center' ) plt . xticks ( range ( len ( count_dict )), [ key [ 0 : 5 ] for key in list ( count_dict . keys ())]) plt . title ( 'Distribution of crystal systems within SiO2 compounds' ) plt . show ()","title":"MAPI Exercise 1"},{"location":"lessons/04_materials_api/MAPI%20Exercise%201/#materials-api-exercise-1","text":"In this excercise, your task is to plot the distribution of crystal systems (cubic, tetragonal, monoclinic, etc) within all SiO _2 _2 compounds. You will do this through the following 3 steps: Retrieve the spacegroup entries in the MP database with the formula SiO _2 _2 Collect their crystal systems Plot a bar chart with the data","title":"Materials API - Exercise 1"},{"location":"lessons/04_materials_api/MAPI%20Exercise%201/#step-1-retrieve-the-spacegroup-entries-in-the-mp-database-with-the-formula-sio_2_2","text":"Use the Materials API to get the \"structure\" property for all SiO _2 _2 compounds. Hint: use the query method of the MPRester . # Your code here","title":"Step 1: Retrieve the spacegroup entries in the MP database with the formula SiO_2_2"},{"location":"lessons/04_materials_api/MAPI%20Exercise%201/#step-2-extract-the-crystal_system-property-for-the-entries-we-retrieved-into-a-list","text":"Hint: \"crystal_system\" is a subkey of the spacegroup property. # Your code here","title":"Step 2: Extract the crystal_system property for the entries we retrieved into a list"},{"location":"lessons/04_materials_api/MAPI%20Exercise%201/#step-3-process-the-data-and-plot-the-results","text":"Our data is currently a list of crystal systems. Your task now is to create a \"count_dict\" where each key is the name of the crystal system and it's value is the count for that crystal system. Once you have written code to create count_dict , you the cell beneath it will plot the data for you. Hint: Iterate through the list of crystal_systems you just created using a for loop and check if they are already in the dictionary before updating any entries. count_dict = {} # Your code here import matplotlib.pyplot as plt % matplotlib inline # The code below plots the distribution plt . bar ( range ( len ( count_dict )), count_dict . values (), align = 'center' ) plt . xticks ( range ( len ( count_dict )), [ key [ 0 : 5 ] for key in list ( count_dict . keys ())]) plt . title ( 'Distribution of crystal systems within SiO2 compounds' ) plt . show ()","title":"Step 3: Process the data and plot the results"},{"location":"lessons/04_materials_api/MAPI%20Exercise%202/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Materials API - Exercise 2: Using the MPRester and Pymatgen to Find Materials With Exotic Mechanical Properties \u00b6 The tetragonal SiO _2 _2 polymorph \\alpha \\alpha -cristobalite is one of the very few crystalline materials known to have a negative average Poisson's ratio, which means that its cross-section expands under tensile strain rather than contracting. This property can be extremely useful in a variety of applications such as scratch-resistant coatings and high-toughness ceramics. Why does \\alpha \\alpha -cristobalite exhibit this property while other materials do not? The prevailing hypothesis is that \\alpha \\alpha -cristobalite's negative Poisson's ratio is a result of its crystal structure. If that's the case, then perhaps we can find other materials with this exotic property by looking for materials with similar structures and then calculating their Poisson's ratios. Step 1: Retrieve the structure of \\alpha \\alpha -cristobalite \u00b6 First, we should find the ground state structure for \\alpha \\alpha -cristobalite, which has the spacegroup P4_12_12 P4_12_12 [92]. Remember, stable materials have low energy above hull ( e_above_hull ). Hint: Query for the formula and spacegroup for the desired compound and then select the one with the lowest e_above_hull if there are multiple results. ac_structure = < YOUR CODE HERE > Step 2: Build a structure comparison engine and test it out \u00b6 The code below creates a structure matcher object that can be used to compare if two structures are simlar (loose tolerances = similar, tight tolerances = identical). Please verify that the structure matcher works for identical structure by comparing the structure of AC with itself. Hint: Replace with the two structures you want to compare, separated by a comma. ##### Don't edit code below ##### from pymatgen.analysis.structure_matcher import StructureMatcher from pymatgen.analysis.structure_matcher import FrameworkComparator # This line initializes our comparator. Please don't play with its tolerances until after you are done comparison_engine = StructureMatcher ( ltol =. 2 , stol =. 5 , angle_tol = 10 , primitive_cell = True , scale = True , attempt_supercell = True , comparator = FrameworkComparator ()) ##### Don't edit code above ##### print ( sm . fit ( < YOUR CODE HERE > )) We know that the high-temperature phase of cristobalite, \\beta \\beta -cristobalite (mp-546794) , has a very similar structure to \\alpha \\alpha -cristobalite. Let's see if the structure matcher agrees. Please retreive the structure for mp-546794 and then compare it with our prototype structure. Hint: No need to re-initialize the structure matcher. Just call it's fit function again. # Your code here Just to make sure we haven't increased the tolerances too much, please try it against a random compound to make sure it's not matching dissimilar structures. Hint: \"mp-4991\" is a good random MPID you can use # Your code here Step 3: Get a set of candidate structures to compare \u00b6 Now that we have our comparator, we need some candidates to screen! Imagine that we have an experimental colleague, Soren Tsarpinski, who is an expert at synthesizing vanadate compounds. We have a hunch that some of the vanadates coming out of Dr. Tsarpinski's lab might have similar structures to \\alpha \\alpha -cristobalite and therefore might have negative Poisson's ratios. Let's see if we're right: For our search, we want to start with a set of structures that are: * Computationally tractable, so not too many sites (i.e nsites <50 is a good number) * Not too unlikely to be synthesizable (energy above hull <100 meV, i.e. {e_above_hull: {\"$lt\": 0.1} ) * Have a \"vanadate\" composition, i.e. \"*V3O8\" Construct and execute a query to get the structure, MPID, and pretty_formula for all materials that match these criteria: Aside; Soren Tsarpinski is an anagram. There is a prize for the first workshop atendee that can guess the original phrase it comes from. (Submit your anwswers on Slack, please.) # Your code here Step 4: Screen the vanadates for similar structures to \\alpha \\alpha -cristobalite and then check if our hypothesis is valid by querying for their Poisson's ratios. \u00b6 Now that we have a list of vanadates, let's screen it for similar structures. After we have the similar structures, make one final query to the Materials API to retrieve the pretty_formula and elasticity.homogenious_poisson property for each one. Hint: Create an empty list for matches and then iterate through the vanadate entries with a for loop. If its structure is similar to \\alpha \\alpha -cristobalite, append its material_id to a list of matches. After you have a match list, query the Materials API for entries with a material_id that is in your matches list using the $in mongodb operator (e.g {\"material_id\": {\"$in$: matches}} ) # Your code here","title":"MAPI Exercise 2"},{"location":"lessons/04_materials_api/MAPI%20Exercise%202/#materials-api-exercise-2-using-the-mprester-and-pymatgen-to-find-materials-with-exotic-mechanical-properties","text":"The tetragonal SiO _2 _2 polymorph \\alpha \\alpha -cristobalite is one of the very few crystalline materials known to have a negative average Poisson's ratio, which means that its cross-section expands under tensile strain rather than contracting. This property can be extremely useful in a variety of applications such as scratch-resistant coatings and high-toughness ceramics. Why does \\alpha \\alpha -cristobalite exhibit this property while other materials do not? The prevailing hypothesis is that \\alpha \\alpha -cristobalite's negative Poisson's ratio is a result of its crystal structure. If that's the case, then perhaps we can find other materials with this exotic property by looking for materials with similar structures and then calculating their Poisson's ratios.","title":"Materials API - Exercise 2: Using the MPRester and Pymatgen to Find Materials With Exotic Mechanical Properties"},{"location":"lessons/04_materials_api/MAPI%20Exercise%202/#step-1-retrieve-the-structure-of-alphaalpha-cristobalite","text":"First, we should find the ground state structure for \\alpha \\alpha -cristobalite, which has the spacegroup P4_12_12 P4_12_12 [92]. Remember, stable materials have low energy above hull ( e_above_hull ). Hint: Query for the formula and spacegroup for the desired compound and then select the one with the lowest e_above_hull if there are multiple results. ac_structure = < YOUR CODE HERE >","title":"Step 1: Retrieve the structure of \\alpha\\alpha-cristobalite"},{"location":"lessons/04_materials_api/MAPI%20Exercise%202/#step-2-build-a-structure-comparison-engine-and-test-it-out","text":"The code below creates a structure matcher object that can be used to compare if two structures are simlar (loose tolerances = similar, tight tolerances = identical). Please verify that the structure matcher works for identical structure by comparing the structure of AC with itself. Hint: Replace with the two structures you want to compare, separated by a comma. ##### Don't edit code below ##### from pymatgen.analysis.structure_matcher import StructureMatcher from pymatgen.analysis.structure_matcher import FrameworkComparator # This line initializes our comparator. Please don't play with its tolerances until after you are done comparison_engine = StructureMatcher ( ltol =. 2 , stol =. 5 , angle_tol = 10 , primitive_cell = True , scale = True , attempt_supercell = True , comparator = FrameworkComparator ()) ##### Don't edit code above ##### print ( sm . fit ( < YOUR CODE HERE > )) We know that the high-temperature phase of cristobalite, \\beta \\beta -cristobalite (mp-546794) , has a very similar structure to \\alpha \\alpha -cristobalite. Let's see if the structure matcher agrees. Please retreive the structure for mp-546794 and then compare it with our prototype structure. Hint: No need to re-initialize the structure matcher. Just call it's fit function again. # Your code here Just to make sure we haven't increased the tolerances too much, please try it against a random compound to make sure it's not matching dissimilar structures. Hint: \"mp-4991\" is a good random MPID you can use # Your code here","title":"Step 2: Build a structure comparison engine and test it out"},{"location":"lessons/04_materials_api/MAPI%20Exercise%202/#step-3-get-a-set-of-candidate-structures-to-compare","text":"Now that we have our comparator, we need some candidates to screen! Imagine that we have an experimental colleague, Soren Tsarpinski, who is an expert at synthesizing vanadate compounds. We have a hunch that some of the vanadates coming out of Dr. Tsarpinski's lab might have similar structures to \\alpha \\alpha -cristobalite and therefore might have negative Poisson's ratios. Let's see if we're right: For our search, we want to start with a set of structures that are: * Computationally tractable, so not too many sites (i.e nsites <50 is a good number) * Not too unlikely to be synthesizable (energy above hull <100 meV, i.e. {e_above_hull: {\"$lt\": 0.1} ) * Have a \"vanadate\" composition, i.e. \"*V3O8\" Construct and execute a query to get the structure, MPID, and pretty_formula for all materials that match these criteria: Aside; Soren Tsarpinski is an anagram. There is a prize for the first workshop atendee that can guess the original phrase it comes from. (Submit your anwswers on Slack, please.) # Your code here","title":"Step 3: Get a set of candidate structures to compare"},{"location":"lessons/04_materials_api/MAPI%20Exercise%202/#step-4-screen-the-vanadates-for-similar-structures-to-alphaalpha-cristobalite-and-then-check-if-our-hypothesis-is-valid-by-querying-for-their-poissons-ratios","text":"Now that we have a list of vanadates, let's screen it for similar structures. After we have the similar structures, make one final query to the Materials API to retrieve the pretty_formula and elasticity.homogenious_poisson property for each one. Hint: Create an empty list for matches and then iterate through the vanadate entries with a for loop. If its structure is similar to \\alpha \\alpha -cristobalite, append its material_id to a list of matches. After you have a match list, query the Materials API for entries with a material_id that is in your matches list using the $in mongodb operator (e.g {\"material_id\": {\"$in$: matches}} ) # Your code here","title":"Step 4: Screen the vanadates for similar structures to \\alpha\\alpha-cristobalite and then check if our hypothesis is valid by querying for their Poisson's ratios."},{"location":"lessons/04_materials_api/api_use/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); The Materials API \u00b6 Presented by: John Dagdelen \u00b6 In this lesson, we cover: The Materials Project API (MAPI) and its documentation, the mapidoc . Getting your Materials Project API key. Using the MPRester to access the MP database. A hands-on example of using the API and pymatgen to screen the MP database for interesting materials. # This supresses warnings. import warnings warnings . filterwarnings ( 'ignore' ) # This is a helper function to shorten lists during the # live presentation of this lesson for better readability. # You can ignore it. def shortlist ( long_list , n = 5 ): print ( \"First {} of {} items:\" . format ( min ( n , 5 ), len ( long_list ))) for item in long_list [ 0 : n ]: print ( item ) Section 0: Getting an API key \u00b6 The first step to getting started with the API is to get an API key. We do this on the Materials Project website (https://materialsproject.org/dashboard.) Click the Generate API key button copy your shiny new key Paste your key in the line below and run the cell. ! pmg config -- add PMG_MAPI_KEY < your API key > Existing /Users/jdagdelen/.pmgrc.yaml backed up to /Users/jdagdelen/.pmgrc.yaml.bak New /Users/jdagdelen/.pmgrc.yaml written! Section 1: The MAPIDOC \u00b6 The mapidoc is a key source of information regarding the Materials Project API. It should be the first thing you consult whenever you are having trouble with the API. Let's take a look! Section 2: Basic Queries In the Web Browser \u00b6 To request data from the Materials Project, you will need to make requests to our API. To do this, you could simply make a GET request through your web browser, providing your API key as an argument. For example, https://www.materialsproject.org/rest/v2/materials/mp-1234/vasp?API_KEY=<your api key> For example, https://www.materialsproject.org/rest/v2/materials/mp-1234/vasp?API_KEY=<your api key> returns the following JSON document: {\"response\": [{\"energy\": -26.94573468, \"energy_per_atom\": -4.49095578, \"volume\": 116.92375473740876, \"formation_energy_per_atom\": -0.4835973866666663, \"nsites\": 6, \"unit_cell_formula\": {\"Al\": 4.0, \"Lu\": 2.0}, \"pretty_formula\": \"LuAl2\", \"is_hubbard\": false, \"elements\": [\"Al\", \"Lu\"], \"nelements\": 2, \"e_above_hull\": 0, \"hubbards\": {}, \"is_compatible\": true, \"spacegroup\": {\"source\": \"spglib\", \"symbol\": \"Fd-3m\", \"number\": 227, \"point_group\": \"m-3m\", \"crystal_system\": \"cubic\", \"hall\": \"F 4d 2 3 -1d\"}, \"task_ids\": [\"mp-1234\", \"mp-925833\", \"mp-940234\", \"mp-940654\"], \"band_gap\": 0.0, \"density\": 6.502482433523648, \"icsd_id\": null, \"icsd_ids\": [608375, 57958, 608376, 608372, 608371, 608370], \"cif\": \"# generated using pymatgen\\ndata_LuAl2\\n_symmetry_space_group_name_H-M 'P 1'\\n_cell_length_a 5.48873905\\n_cell_length_b 5.48873905\\n_cell_length_c 5.48873905\\n_cell_angle_alpha 60.00000005\\n_cell_angle_beta 60.00000003\\n_cell_angle_gamma 60.00000007\\n_symmetry_Int_Tables_number 1\\n_chemical_formula_structural LuAl2\\n_chemical_formula_sum 'Lu2 Al4'\\n_cell_volume 116.92375474\\n_cell_formula_units_Z 2\\nloop_\\n _symmetry_equiv_pos_site_id\\n _symmetry_equiv_pos_as_xyz\\n 1 'x, y, z'\\nloop_\\n _atom_site_type_symbol\\n _atom_site_label\\n _atom_site_symmetry_multiplicity\\n _atom_site_fract_x\\n _atom_site_fract_y\\n _atom_site_fract_z\\n _atom_site_occupancy\\n Al Al1 1 0.500000 0.500000 0.500000 1\\n Al Al2 1 0.500000 0.500000 0.000000 1\\n Al Al3 1 0.000000 0.500000 0.500000 1\\n Al Al4 1 0.500000 0.000000 0.500000 1\\n Lu Lu5 1 0.875000 0.875000 0.875000 1\\n Lu Lu6 1 0.125000 0.125000 0.125000 1\\n\", \"total_magnetization\": 0.0012519, \"material_id\": \"mp-1234\", \"oxide_type\": \"None\", \"tags\": [\"High pressure experimental phase\", \"Aluminium lutetium (2/1)\"], \"elasticity\": null, \"full_formula\": \"Lu2Al4\"}], \"valid_response\": true, \"created_at\": \"2018-08-08T18:52:53.042666\", \"version\": {\"db\": \"3.0.0\", \"pymatgen\": \"2018.7.23\", \"rest\": \"2.0\"}, \"copyright\": \"Materials Project, 2018\"} For obvious reasons, typing these kinds of urls into your web browser is not an ideal way to request MP data. Instead, we should try to access the API programatically with python. Let's do the same request that we did above using Python's requests library. Making Requests With Python \u00b6 import requests response = requests . get ( \"https://www.materialsproject.org/rest/v2/materials/mp-1234/vasp\" , { \"API_KEY\" : \"<your API key>\" }) print ( response . text ) Section 3: The MPRester \u00b6 In this section we will: Open the pymatgen.MPRester web documentation. Create our first instance of an MPRester object. Get our feet wet with calling a few of the MPRester's \"specialty\" methods. Background and Documentation \u00b6 Code connects to the MP Database through REST requests. Pymatgen's MPRester class is helpful for accessing our API in python. The documentation for the MPRester is very helpful. Let's take a look! Background and Documentation \u00b6 REST is a widely used type of standardization that allows different computer systems to work together. In RESTful systems, information is organized into resources, each of which is uniquely identified via a uniform resource identifier (URI). Since MAPI is a RESTful system, users can interact with the MP database regardless of their computer system or programming language (as long as it supports basic http requests.) To facilitate researchers in using our API, we implemented a convenient wrapper for it in the Python Materials Genomics (pymatgen) library called the MPRester . You can find the relevant pymatgen documentation for it here . Starting up an instance of the MPRester \u00b6 We'll import the MPRester and create an instance of it. Note: You may need to use your API key as an input argument if it has not been pre-configured. from pymatgen import MPRester mpr = MPRester () print ( mpr . supported_properties ) ('energy', 'energy_per_atom', 'volume', 'formation_energy_per_atom', 'nsites', 'unit_cell_formula', 'pretty_formula', 'is_hubbard', 'elements', 'nelements', 'e_above_hull', 'hubbards', 'is_compatible', 'spacegroup', 'task_ids', 'band_gap', 'density', 'icsd_id', 'icsd_ids', 'cif', 'total_magnetization', 'material_id', 'oxide_type', 'tags', 'elasticity') However, we recommend that you use the \u201cwith\u201d context manager to ensure that sessions are properly closed after usage: with MPRester () as mpr : print ( mpr . supported_properties ) ('energy', 'energy_per_atom', 'volume', 'formation_energy_per_atom', 'nsites', 'unit_cell_formula', 'pretty_formula', 'is_hubbard', 'elements', 'nelements', 'e_above_hull', 'hubbards', 'is_compatible', 'spacegroup', 'task_ids', 'band_gap', 'density', 'icsd_id', 'icsd_ids', 'cif', 'total_magnetization', 'material_id', 'oxide_type', 'tags', 'elasticity') MPRester Methods: \u00b6 The MPRester has many methods that you might want to use in your research. For example, there is a method to get the bandstructure for a material, get_bandstructure_by_material_id . Let's use this method and the following bandstructure plotting function to get and plot a bandstructure for mp-1234: ### Don't edit this code #### from pymatgen.electronic_structure.plotter import BSPlotter # Helpful function for plotting a bandstructure. def plot_bandstructure ( bs ): BSPlotter ( bs ) . get_plot () . show () ############################# # Excercise: Use the MPRester's get_bandstructure_by_material_id method to # get a bandstructure from the MP Database and plot it using the # plot_bandstructure functin defined above. with MPRester () as mpr : bs = mpr . get_bandstructure_by_material_id ( \"mp-1234\" ) plot_bandstructure ( bs ) There's also a method to get MPIDs for a formula or chemical system called get_materials_ids . with MPRester () as mpr : # You can pass in a formula to get_materials_ids shortlist ( mpr . get_materials_ids ( \"LiFePO4\" )) # Or you can pass in a \"chemsys\" such as \"Li-Fe-P-O\" shortlist ( mpr . get_materials_ids ( \"Li-Fe-P-O\" )) First 5 of 67 items: mp-765593 mp-757182 mp-1662030 mp-772409 mp-765604 First 5 of 908 items: mp-1245108 mp-1271693 mp-1194030 mp-1271562 mp-136 Using the API to achieve research goals: \u00b6 Imagine you want to get the structure for the multiferroic material BiFeO3 ( mp-24932 ) and suggest some substrates for growing it. We can use methods of the MPRester to get this information from the Materials Project API. Hints: MPRester.get_structure_by_material_id MPRester.get_substrates # Get the structure for BiFeO3 (mp-23501) and # suggest some substrates for growing it. with MPRester () as mpr : structure = mpr . get_structure_by_material_id ( \"mp-23501\" ) substrates = mpr . get_substrates ( \"mp-23501\" ) print ( structure ) print ([ s [ \"sub_form\" ] for s in substrates ]) Full Formula (Fe2 Bi2 O6) Reduced Formula: FeBiO3 abc : 5.615643 5.615629 5.705140 angles: 60.510834 119.489364 120.001015 Sites (10) # SP a b c magmom --- ---- -------- -------- -------- -------- 0 Fe 0.219028 0.780969 0.657065 -4.256 1 Fe 0.719032 0.28097 0.15707 4.256 2 Bi 0.498595 0.501425 0.495716 -0.001 3 Bi 0.998575 0.001404 0.995717 0.001 4 O 0.436045 0.111857 0.359395 0.034 5 O 0.035218 0.563986 0.359413 0.034 6 O 0.888122 0.964774 0.359409 0.034 7 O 0.388142 0.063955 0.859394 -0.034 8 O 0.535228 0.61188 0.859409 -0.034 9 O 0.936013 0.46478 0.859414 -0.034 ['AlN', 'LaAlO3', 'LiGaO2', 'WS2', 'MoS2', 'C', 'TbScO3', 'MgF2', 'NdGaO3', 'BaTiO3', 'Ag', 'C', 'DyScO3', 'GdScO3', 'Mg', 'LiAlO2', 'Au', 'BaTiO3', 'AlN', 'TiO2', 'ZnO', 'NaCl', 'MgF2', 'Bi2Te3', 'SrTiO3', 'KTaO3', 'GaN', 'NaCl', 'Al', 'C', 'ZnO', 'TeO2', 'Ni', 'C', 'SrTiO3', 'GaN', 'TiO2', 'DyScO3', 'Te2W', 'GdScO3', 'SiC', 'BaTiO3', 'ZnSe', 'SiC', 'WS2', 'WS2', 'ZnO', 'WS2', 'MoS2', 'MoS2'] At this point, you should be comfortable with: Finding documentation on the MPRester. Creating an instance of the MPRester. Using methods of the MPRester. Section 4: Using the MPRester.query method. \u00b6 The MPRester also has a very powerful method called query , which allows us to perform sophisticated searches on the database. The query method uses MongoDB's query syntax . In this syntax, query submissions have two parts: a set of criteria that you want to base the search on (in the form of a python dict), and a set of properties that you want the database to return (in the form of either a list or dict). You will probably find yourself using the MPRester's query method frequently. The general structure of a MPRester query is: mpr.query(criteria, properties) The general structure of a MPRester query is: mpr.query(criteria, properties) criteria is usually a string or a dict. properties is always a list of strings Let's try out some queries to learn how it works! First, we'll query for SiO_2 SiO_2 compounds by chemical formula through 'pretty_formula'. with MPRester () as mpr : results = mpr . query ({ 'pretty_formula' : \"SiO2\" }, properties = [ 'material_id' , 'pretty_formula' ]) print ( len ( results )) If we investigate the object that the query method returns, we find that it is a list of dicts. Furthermore, we find that the keys of the dictionaries are the very same keywords that we passed to the query method as the properties argument. print ( 'Results are returned as a {} of {} . \\n ' . format ( type ( results ), type ( results [ 0 ]))) for r in results [ 0 : 5 ]: print ( r ) In fact, if you are just looking for materials based on formula/composition/stoichiometry, there is an easier way to use the query method: just pass in a string as the criteria! You can even use wildcard characters in your searches. For example, if we want to find all ABO_3 ABO_3 compounds in the Materials Project: with MPRester () as mpr : results = mpr . query ( '**O3' , properties = [ \"material_id\" , \"pretty_formula\" ]) shortlist ( results ) Putting it into practice: \u00b6 There are 296 variants of SiO_2 SiO_2 in the MP database, but how many Si_xO_y Si_xO_y compounds are there in the Materials Project? Hint: Query using a chemsys string instead of a formula. with MPRester () as mpr : print ( len ( mpr . query ( \"Si-O\" , [ \"material_id\" ]))) 331 EXCERCISE 1 \u00b6 MongoDB Operators \u00b6 Above, we specified the chemical formula SiO _2 _2 for our query. This is an example of, the \"specify\" operator. However, MongoDB's syntax also includes other query operators , allowing us to bulid complex conditionals into our queries. These all start with the \"$\" character. Some important MongoDB operators you should be familiar with are: $in (in) $nin (not in) $gt (greater than) $gte (greater than or equal to) $lt (less than) $lte (less than or equal to) $not (is not) We used these more advanced operators as follows: {\"field_name\": {\"$op\": value}} For example, \"entries with e_above_hull that is less than 0.25 eV\" would be: {\"e_above_hull\": {\"$lt\": 0.25}} A paper by McEnany et. al. proposes a novel ammonia synthesis process based on the electrochemical cycling of lithium ( link ). As an exercise, let's use some of MongoDB's operators and ask the database for nitrides of alkali metals. # Find all nitrides of alkali metals alkali_metals = [ 'Li' , 'Na' , 'K' , 'Rb' , 'Cs' ] criteria = { \"elements\" :{ \"$in\" : alkali_metals , \"$all\" : [ \"N\" ]}, \"nelements\" : 2 } properties = [ 'material_id' , 'pretty_formula' ] shortlist ( mpr . query ( criteria , properties )) #Bonus short way to do this with wildcards shortlist ( mpr . query ( '{Li,Na,K,Rb,Cs}-N' , [ 'material_id' , 'pretty_formula' ])) We can also perform the same query, but ask the database to only return compounds with energies above the hull less than 10 meV/atom by using the \"less than\" operator, \" $lt \". (The energy above the convex hull gives us a sense of how stable a compound is relative to other compounds with the same composition.) criteria = { \"elements\" :{ \"$in\" : alkali_metals , \"$all\" :[ \"N\" ]}, \"nelements\" : 2 , 'e_above_hull' :{ \"$lt\" : 0.010 }} properties = [ 'material_id' , 'pretty_formula' ] mpr . query ( criteria , properties ) In this lesson, we have covered: The Materials Project API (MAPI) and its documentation, the mapidoc . Getting your Materials Project API key. Using the MPRester to access the MP database. Hands-on examples of using the API and pymatgen to screen the MP database for interesting materials.","title":"The Materials API"},{"location":"lessons/04_materials_api/api_use/#the-materials-api","text":"","title":"The Materials API"},{"location":"lessons/04_materials_api/api_use/#presented-by-john-dagdelen","text":"In this lesson, we cover: The Materials Project API (MAPI) and its documentation, the mapidoc . Getting your Materials Project API key. Using the MPRester to access the MP database. A hands-on example of using the API and pymatgen to screen the MP database for interesting materials. # This supresses warnings. import warnings warnings . filterwarnings ( 'ignore' ) # This is a helper function to shorten lists during the # live presentation of this lesson for better readability. # You can ignore it. def shortlist ( long_list , n = 5 ): print ( \"First {} of {} items:\" . format ( min ( n , 5 ), len ( long_list ))) for item in long_list [ 0 : n ]: print ( item )","title":"Presented by: John Dagdelen"},{"location":"lessons/04_materials_api/api_use/#section-0-getting-an-api-key","text":"The first step to getting started with the API is to get an API key. We do this on the Materials Project website (https://materialsproject.org/dashboard.) Click the Generate API key button copy your shiny new key Paste your key in the line below and run the cell. ! pmg config -- add PMG_MAPI_KEY < your API key > Existing /Users/jdagdelen/.pmgrc.yaml backed up to /Users/jdagdelen/.pmgrc.yaml.bak New /Users/jdagdelen/.pmgrc.yaml written!","title":"Section 0: Getting an API key"},{"location":"lessons/04_materials_api/api_use/#section-1-the-mapidoc","text":"The mapidoc is a key source of information regarding the Materials Project API. It should be the first thing you consult whenever you are having trouble with the API. Let's take a look!","title":"Section 1: The MAPIDOC"},{"location":"lessons/04_materials_api/api_use/#section-2-basic-queries-in-the-web-browser","text":"To request data from the Materials Project, you will need to make requests to our API. To do this, you could simply make a GET request through your web browser, providing your API key as an argument. For example, https://www.materialsproject.org/rest/v2/materials/mp-1234/vasp?API_KEY=<your api key> For example, https://www.materialsproject.org/rest/v2/materials/mp-1234/vasp?API_KEY=<your api key> returns the following JSON document: {\"response\": [{\"energy\": -26.94573468, \"energy_per_atom\": -4.49095578, \"volume\": 116.92375473740876, \"formation_energy_per_atom\": -0.4835973866666663, \"nsites\": 6, \"unit_cell_formula\": {\"Al\": 4.0, \"Lu\": 2.0}, \"pretty_formula\": \"LuAl2\", \"is_hubbard\": false, \"elements\": [\"Al\", \"Lu\"], \"nelements\": 2, \"e_above_hull\": 0, \"hubbards\": {}, \"is_compatible\": true, \"spacegroup\": {\"source\": \"spglib\", \"symbol\": \"Fd-3m\", \"number\": 227, \"point_group\": \"m-3m\", \"crystal_system\": \"cubic\", \"hall\": \"F 4d 2 3 -1d\"}, \"task_ids\": [\"mp-1234\", \"mp-925833\", \"mp-940234\", \"mp-940654\"], \"band_gap\": 0.0, \"density\": 6.502482433523648, \"icsd_id\": null, \"icsd_ids\": [608375, 57958, 608376, 608372, 608371, 608370], \"cif\": \"# generated using pymatgen\\ndata_LuAl2\\n_symmetry_space_group_name_H-M 'P 1'\\n_cell_length_a 5.48873905\\n_cell_length_b 5.48873905\\n_cell_length_c 5.48873905\\n_cell_angle_alpha 60.00000005\\n_cell_angle_beta 60.00000003\\n_cell_angle_gamma 60.00000007\\n_symmetry_Int_Tables_number 1\\n_chemical_formula_structural LuAl2\\n_chemical_formula_sum 'Lu2 Al4'\\n_cell_volume 116.92375474\\n_cell_formula_units_Z 2\\nloop_\\n _symmetry_equiv_pos_site_id\\n _symmetry_equiv_pos_as_xyz\\n 1 'x, y, z'\\nloop_\\n _atom_site_type_symbol\\n _atom_site_label\\n _atom_site_symmetry_multiplicity\\n _atom_site_fract_x\\n _atom_site_fract_y\\n _atom_site_fract_z\\n _atom_site_occupancy\\n Al Al1 1 0.500000 0.500000 0.500000 1\\n Al Al2 1 0.500000 0.500000 0.000000 1\\n Al Al3 1 0.000000 0.500000 0.500000 1\\n Al Al4 1 0.500000 0.000000 0.500000 1\\n Lu Lu5 1 0.875000 0.875000 0.875000 1\\n Lu Lu6 1 0.125000 0.125000 0.125000 1\\n\", \"total_magnetization\": 0.0012519, \"material_id\": \"mp-1234\", \"oxide_type\": \"None\", \"tags\": [\"High pressure experimental phase\", \"Aluminium lutetium (2/1)\"], \"elasticity\": null, \"full_formula\": \"Lu2Al4\"}], \"valid_response\": true, \"created_at\": \"2018-08-08T18:52:53.042666\", \"version\": {\"db\": \"3.0.0\", \"pymatgen\": \"2018.7.23\", \"rest\": \"2.0\"}, \"copyright\": \"Materials Project, 2018\"} For obvious reasons, typing these kinds of urls into your web browser is not an ideal way to request MP data. Instead, we should try to access the API programatically with python. Let's do the same request that we did above using Python's requests library.","title":"Section 2: Basic Queries In the Web Browser"},{"location":"lessons/04_materials_api/api_use/#making-requests-with-python","text":"import requests response = requests . get ( \"https://www.materialsproject.org/rest/v2/materials/mp-1234/vasp\" , { \"API_KEY\" : \"<your API key>\" }) print ( response . text )","title":"Making Requests With Python"},{"location":"lessons/04_materials_api/api_use/#section-3-the-mprester","text":"In this section we will: Open the pymatgen.MPRester web documentation. Create our first instance of an MPRester object. Get our feet wet with calling a few of the MPRester's \"specialty\" methods.","title":"Section 3: The MPRester"},{"location":"lessons/04_materials_api/api_use/#background-and-documentation","text":"Code connects to the MP Database through REST requests. Pymatgen's MPRester class is helpful for accessing our API in python. The documentation for the MPRester is very helpful. Let's take a look!","title":"Background and Documentation"},{"location":"lessons/04_materials_api/api_use/#background-and-documentation_1","text":"REST is a widely used type of standardization that allows different computer systems to work together. In RESTful systems, information is organized into resources, each of which is uniquely identified via a uniform resource identifier (URI). Since MAPI is a RESTful system, users can interact with the MP database regardless of their computer system or programming language (as long as it supports basic http requests.) To facilitate researchers in using our API, we implemented a convenient wrapper for it in the Python Materials Genomics (pymatgen) library called the MPRester . You can find the relevant pymatgen documentation for it here .","title":"Background and Documentation"},{"location":"lessons/04_materials_api/api_use/#starting-up-an-instance-of-the-mprester","text":"We'll import the MPRester and create an instance of it. Note: You may need to use your API key as an input argument if it has not been pre-configured. from pymatgen import MPRester mpr = MPRester () print ( mpr . supported_properties ) ('energy', 'energy_per_atom', 'volume', 'formation_energy_per_atom', 'nsites', 'unit_cell_formula', 'pretty_formula', 'is_hubbard', 'elements', 'nelements', 'e_above_hull', 'hubbards', 'is_compatible', 'spacegroup', 'task_ids', 'band_gap', 'density', 'icsd_id', 'icsd_ids', 'cif', 'total_magnetization', 'material_id', 'oxide_type', 'tags', 'elasticity') However, we recommend that you use the \u201cwith\u201d context manager to ensure that sessions are properly closed after usage: with MPRester () as mpr : print ( mpr . supported_properties ) ('energy', 'energy_per_atom', 'volume', 'formation_energy_per_atom', 'nsites', 'unit_cell_formula', 'pretty_formula', 'is_hubbard', 'elements', 'nelements', 'e_above_hull', 'hubbards', 'is_compatible', 'spacegroup', 'task_ids', 'band_gap', 'density', 'icsd_id', 'icsd_ids', 'cif', 'total_magnetization', 'material_id', 'oxide_type', 'tags', 'elasticity')","title":"Starting up an instance of the MPRester"},{"location":"lessons/04_materials_api/api_use/#mprester-methods","text":"The MPRester has many methods that you might want to use in your research. For example, there is a method to get the bandstructure for a material, get_bandstructure_by_material_id . Let's use this method and the following bandstructure plotting function to get and plot a bandstructure for mp-1234: ### Don't edit this code #### from pymatgen.electronic_structure.plotter import BSPlotter # Helpful function for plotting a bandstructure. def plot_bandstructure ( bs ): BSPlotter ( bs ) . get_plot () . show () ############################# # Excercise: Use the MPRester's get_bandstructure_by_material_id method to # get a bandstructure from the MP Database and plot it using the # plot_bandstructure functin defined above. with MPRester () as mpr : bs = mpr . get_bandstructure_by_material_id ( \"mp-1234\" ) plot_bandstructure ( bs ) There's also a method to get MPIDs for a formula or chemical system called get_materials_ids . with MPRester () as mpr : # You can pass in a formula to get_materials_ids shortlist ( mpr . get_materials_ids ( \"LiFePO4\" )) # Or you can pass in a \"chemsys\" such as \"Li-Fe-P-O\" shortlist ( mpr . get_materials_ids ( \"Li-Fe-P-O\" )) First 5 of 67 items: mp-765593 mp-757182 mp-1662030 mp-772409 mp-765604 First 5 of 908 items: mp-1245108 mp-1271693 mp-1194030 mp-1271562 mp-136","title":"MPRester Methods:"},{"location":"lessons/04_materials_api/api_use/#using-the-api-to-achieve-research-goals","text":"Imagine you want to get the structure for the multiferroic material BiFeO3 ( mp-24932 ) and suggest some substrates for growing it. We can use methods of the MPRester to get this information from the Materials Project API. Hints: MPRester.get_structure_by_material_id MPRester.get_substrates # Get the structure for BiFeO3 (mp-23501) and # suggest some substrates for growing it. with MPRester () as mpr : structure = mpr . get_structure_by_material_id ( \"mp-23501\" ) substrates = mpr . get_substrates ( \"mp-23501\" ) print ( structure ) print ([ s [ \"sub_form\" ] for s in substrates ]) Full Formula (Fe2 Bi2 O6) Reduced Formula: FeBiO3 abc : 5.615643 5.615629 5.705140 angles: 60.510834 119.489364 120.001015 Sites (10) # SP a b c magmom --- ---- -------- -------- -------- -------- 0 Fe 0.219028 0.780969 0.657065 -4.256 1 Fe 0.719032 0.28097 0.15707 4.256 2 Bi 0.498595 0.501425 0.495716 -0.001 3 Bi 0.998575 0.001404 0.995717 0.001 4 O 0.436045 0.111857 0.359395 0.034 5 O 0.035218 0.563986 0.359413 0.034 6 O 0.888122 0.964774 0.359409 0.034 7 O 0.388142 0.063955 0.859394 -0.034 8 O 0.535228 0.61188 0.859409 -0.034 9 O 0.936013 0.46478 0.859414 -0.034 ['AlN', 'LaAlO3', 'LiGaO2', 'WS2', 'MoS2', 'C', 'TbScO3', 'MgF2', 'NdGaO3', 'BaTiO3', 'Ag', 'C', 'DyScO3', 'GdScO3', 'Mg', 'LiAlO2', 'Au', 'BaTiO3', 'AlN', 'TiO2', 'ZnO', 'NaCl', 'MgF2', 'Bi2Te3', 'SrTiO3', 'KTaO3', 'GaN', 'NaCl', 'Al', 'C', 'ZnO', 'TeO2', 'Ni', 'C', 'SrTiO3', 'GaN', 'TiO2', 'DyScO3', 'Te2W', 'GdScO3', 'SiC', 'BaTiO3', 'ZnSe', 'SiC', 'WS2', 'WS2', 'ZnO', 'WS2', 'MoS2', 'MoS2'] At this point, you should be comfortable with: Finding documentation on the MPRester. Creating an instance of the MPRester. Using methods of the MPRester.","title":"Using the API to achieve research goals:"},{"location":"lessons/04_materials_api/api_use/#section-4-using-the-mpresterquery-method","text":"The MPRester also has a very powerful method called query , which allows us to perform sophisticated searches on the database. The query method uses MongoDB's query syntax . In this syntax, query submissions have two parts: a set of criteria that you want to base the search on (in the form of a python dict), and a set of properties that you want the database to return (in the form of either a list or dict). You will probably find yourself using the MPRester's query method frequently. The general structure of a MPRester query is: mpr.query(criteria, properties) The general structure of a MPRester query is: mpr.query(criteria, properties) criteria is usually a string or a dict. properties is always a list of strings Let's try out some queries to learn how it works! First, we'll query for SiO_2 SiO_2 compounds by chemical formula through 'pretty_formula'. with MPRester () as mpr : results = mpr . query ({ 'pretty_formula' : \"SiO2\" }, properties = [ 'material_id' , 'pretty_formula' ]) print ( len ( results )) If we investigate the object that the query method returns, we find that it is a list of dicts. Furthermore, we find that the keys of the dictionaries are the very same keywords that we passed to the query method as the properties argument. print ( 'Results are returned as a {} of {} . \\n ' . format ( type ( results ), type ( results [ 0 ]))) for r in results [ 0 : 5 ]: print ( r ) In fact, if you are just looking for materials based on formula/composition/stoichiometry, there is an easier way to use the query method: just pass in a string as the criteria! You can even use wildcard characters in your searches. For example, if we want to find all ABO_3 ABO_3 compounds in the Materials Project: with MPRester () as mpr : results = mpr . query ( '**O3' , properties = [ \"material_id\" , \"pretty_formula\" ]) shortlist ( results )","title":"Section 4: Using the MPRester.query method."},{"location":"lessons/04_materials_api/api_use/#putting-it-into-practice","text":"There are 296 variants of SiO_2 SiO_2 in the MP database, but how many Si_xO_y Si_xO_y compounds are there in the Materials Project? Hint: Query using a chemsys string instead of a formula. with MPRester () as mpr : print ( len ( mpr . query ( \"Si-O\" , [ \"material_id\" ]))) 331","title":"Putting it into practice:"},{"location":"lessons/04_materials_api/api_use/#excercise-1","text":"","title":"EXCERCISE 1"},{"location":"lessons/04_materials_api/api_use/#mongodb-operators","text":"Above, we specified the chemical formula SiO _2 _2 for our query. This is an example of, the \"specify\" operator. However, MongoDB's syntax also includes other query operators , allowing us to bulid complex conditionals into our queries. These all start with the \"$\" character. Some important MongoDB operators you should be familiar with are: $in (in) $nin (not in) $gt (greater than) $gte (greater than or equal to) $lt (less than) $lte (less than or equal to) $not (is not) We used these more advanced operators as follows: {\"field_name\": {\"$op\": value}} For example, \"entries with e_above_hull that is less than 0.25 eV\" would be: {\"e_above_hull\": {\"$lt\": 0.25}} A paper by McEnany et. al. proposes a novel ammonia synthesis process based on the electrochemical cycling of lithium ( link ). As an exercise, let's use some of MongoDB's operators and ask the database for nitrides of alkali metals. # Find all nitrides of alkali metals alkali_metals = [ 'Li' , 'Na' , 'K' , 'Rb' , 'Cs' ] criteria = { \"elements\" :{ \"$in\" : alkali_metals , \"$all\" : [ \"N\" ]}, \"nelements\" : 2 } properties = [ 'material_id' , 'pretty_formula' ] shortlist ( mpr . query ( criteria , properties )) #Bonus short way to do this with wildcards shortlist ( mpr . query ( '{Li,Na,K,Rb,Cs}-N' , [ 'material_id' , 'pretty_formula' ])) We can also perform the same query, but ask the database to only return compounds with energies above the hull less than 10 meV/atom by using the \"less than\" operator, \" $lt \". (The energy above the convex hull gives us a sense of how stable a compound is relative to other compounds with the same composition.) criteria = { \"elements\" :{ \"$in\" : alkali_metals , \"$all\" :[ \"N\" ]}, \"nelements\" : 2 , 'e_above_hull' :{ \"$lt\" : 0.010 }} properties = [ 'material_id' , 'pretty_formula' ] mpr . query ( criteria , properties ) In this lesson, we have covered: The Materials Project API (MAPI) and its documentation, the mapidoc . Getting your Materials Project API key. Using the MPRester to access the MP database. Hands-on examples of using the API and pymatgen to screen the MP database for interesting materials.","title":"MongoDB Operators"},{"location":"logistics/logistics/","text":"Logistics \u00b6 Before the Workshop \u00b6 Virtual Poster-Session \u00b6 We'll host a virtual poster-session via a YouTube video for lightning summaries and a FigShare repository with associated DOI for citation. Please email : your poster PDF a 1-minute lighting video explaining the main concept behind your poster. This shouldn't be detailed summary of your work, but rather a high-level description that everyone can listen to and then decide which posters they want to focus on such as an elevator-pitch. We'll host the lightning-videos on our YouTube Channel and publish the PDFs on FigShare with a DOI that everyone can cite for this poster session. Setup Instructions \u00b6 Sign in to your MP account online. Register for an account first if needed. Sign in to an account on CoCalc using the same email address you registered with. This will be the online python service we'll use to work interactively. If you don't use the email you registered for the workshop with to register on CoCalc.com, please send me an email so that I know. We'll use CoCalc as an interactive python environment where you can code alongside the lessons, work on exercises, and get live-help and feedback from our helpers. Lesson Format \u00b6 Lessons will be broadcast via Zoom with live audio + screencast from the instructor. You won't need a microphone or camera. Please make sure audio works via Zoom. We'll use CoCalc for all our collaborative work. An in-notebook chat will allow attendees to ask for help. Instructors and helpers will be able We'll set up a Slack channel for group chat. This will allow attendees to ask general questions and chat amongst each other as well. Finding your API Key: \u00b6 An important aspect of the Materials Project API is the use of API keys to ensure we can control the amount of traffic that comes to the API. Otherwise, it's very easy for someone to take down the MP servers, making them unavailable for anyone. Your API key can be accessed via the Dashboard: Login to your Materials Project account and find the dashboard in the top right hand corner Your API is displayed in the middle under the Generate API Key button. Keep this to yourself. You can reset your API key at any time. Finding your MPContribs API Key: \u00b6 Currently the API key for MPContribs is separate from Materials Project. In order to get your MPContribs API key. Login to portal.mpcontribs.org Hover over the More drop-down in the top right hand corner Click the API Key button to copy your API key to your clipboard. You can now paste this into your notebook during the MPContribs lesson. During the Workshop \u00b6 Start of the Day Instructions \u00b6 Sign in to CoCalc Sign in to the Zoom Link Sign in to the MP Workshop slack Lesson Format \u00b6 The lessons will be taught in 20-minute sessions as 10-minutes of lesson followed by 10-minutes of a hands-on exercise. You're welcome to follow along with the already filled in hand-out notebook or by typing in to an empty notebook as we go along in the lesson. If you need help \u00b6 Click the chat icon at the top right corner your CoCalc browser window. Type in a message in the new chat window followed by Shift + Enter to send the message and our helpers will be notified. If you have a General Question \u00b6 Feel free to ask a question in the MP Workshop Slack #workshop2020 channel","title":"Logistics"},{"location":"logistics/logistics/#logistics","text":"","title":"Logistics"},{"location":"logistics/logistics/#before-the-workshop","text":"","title":"Before the Workshop"},{"location":"logistics/logistics/#virtual-poster-session","text":"We'll host a virtual poster-session via a YouTube video for lightning summaries and a FigShare repository with associated DOI for citation. Please email : your poster PDF a 1-minute lighting video explaining the main concept behind your poster. This shouldn't be detailed summary of your work, but rather a high-level description that everyone can listen to and then decide which posters they want to focus on such as an elevator-pitch. We'll host the lightning-videos on our YouTube Channel and publish the PDFs on FigShare with a DOI that everyone can cite for this poster session.","title":"Virtual Poster-Session"},{"location":"logistics/logistics/#setup-instructions","text":"Sign in to your MP account online. Register for an account first if needed. Sign in to an account on CoCalc using the same email address you registered with. This will be the online python service we'll use to work interactively. If you don't use the email you registered for the workshop with to register on CoCalc.com, please send me an email so that I know. We'll use CoCalc as an interactive python environment where you can code alongside the lessons, work on exercises, and get live-help and feedback from our helpers.","title":"Setup Instructions"},{"location":"logistics/logistics/#lesson-format","text":"Lessons will be broadcast via Zoom with live audio + screencast from the instructor. You won't need a microphone or camera. Please make sure audio works via Zoom. We'll use CoCalc for all our collaborative work. An in-notebook chat will allow attendees to ask for help. Instructors and helpers will be able We'll set up a Slack channel for group chat. This will allow attendees to ask general questions and chat amongst each other as well.","title":"Lesson Format"},{"location":"logistics/logistics/#finding-your-api-key","text":"An important aspect of the Materials Project API is the use of API keys to ensure we can control the amount of traffic that comes to the API. Otherwise, it's very easy for someone to take down the MP servers, making them unavailable for anyone. Your API key can be accessed via the Dashboard: Login to your Materials Project account and find the dashboard in the top right hand corner Your API is displayed in the middle under the Generate API Key button. Keep this to yourself. You can reset your API key at any time.","title":"Finding your API Key:"},{"location":"logistics/logistics/#finding-your-mpcontribs-api-key","text":"Currently the API key for MPContribs is separate from Materials Project. In order to get your MPContribs API key. Login to portal.mpcontribs.org Hover over the More drop-down in the top right hand corner Click the API Key button to copy your API key to your clipboard. You can now paste this into your notebook during the MPContribs lesson.","title":"Finding your MPContribs API Key:"},{"location":"logistics/logistics/#during-the-workshop","text":"","title":"During the Workshop"},{"location":"logistics/logistics/#start-of-the-day-instructions","text":"Sign in to CoCalc Sign in to the Zoom Link Sign in to the MP Workshop slack","title":"Start of the Day Instructions"},{"location":"logistics/logistics/#lesson-format_1","text":"The lessons will be taught in 20-minute sessions as 10-minutes of lesson followed by 10-minutes of a hands-on exercise. You're welcome to follow along with the already filled in hand-out notebook or by typing in to an empty notebook as we go along in the lesson.","title":"Lesson Format"},{"location":"logistics/logistics/#if-you-need-help","text":"Click the chat icon at the top right corner your CoCalc browser window. Type in a message in the new chat window followed by Shift + Enter to send the message and our helpers will be notified.","title":"If you need help"},{"location":"logistics/logistics/#if-you-have-a-general-question","text":"Feel free to ask a question in the MP Workshop Slack #workshop2020 channel","title":"If you have a General Question"},{"location":"people/people/","text":"People \u00b6 The annual MP Workshop would not be possible without all the people that contribute. In particular, several critical people step up each year to plan, organize, develop lessons, run the workshop, teach, collect post-workshop surveys, and begin planning again. This page highlights those individuals who have contributed significantly to this workshop each year. 2020 \u00b6 2020 is particularly important as the transition from an in-person 40-person workshop to an online 100-person workshop represents a significant effort. The workshop lesson plan changes a little bit each year, but these individuals stepped up and reworked the lessons for a virtual teaching environment. This represents 100's, if not well over 1000+ combined hours of effort. Organizers \u00b6 Shyam Dwaraknath Matthew Horton Patrick Huck Alice Muller Kristin Persson Instructors \u00b6 Ryan Kingbury Guy Moore Jason Munro Sam Blau Evan Spotte-Smith Oxana Andriuc John Dagdelen Rachel Woods-Robinson Alex Ganose Helpers \u00b6 Mingjian Wen Jianli Cheng Ann Rutt Hetal Patel Kara Fong Matt McDermott Jimmy Shen Eric Sivonxay","title":"People"},{"location":"people/people/#people","text":"The annual MP Workshop would not be possible without all the people that contribute. In particular, several critical people step up each year to plan, organize, develop lessons, run the workshop, teach, collect post-workshop surveys, and begin planning again. This page highlights those individuals who have contributed significantly to this workshop each year.","title":"People"},{"location":"people/people/#2020","text":"2020 is particularly important as the transition from an in-person 40-person workshop to an online 100-person workshop represents a significant effort. The workshop lesson plan changes a little bit each year, but these individuals stepped up and reworked the lessons for a virtual teaching environment. This represents 100's, if not well over 1000+ combined hours of effort.","title":"2020"},{"location":"people/people/#organizers","text":"Shyam Dwaraknath Matthew Horton Patrick Huck Alice Muller Kristin Persson","title":"Organizers"},{"location":"people/people/#instructors","text":"Ryan Kingbury Guy Moore Jason Munro Sam Blau Evan Spotte-Smith Oxana Andriuc John Dagdelen Rachel Woods-Robinson Alex Ganose","title":"Instructors"},{"location":"people/people/#helpers","text":"Mingjian Wen Jianli Cheng Ann Rutt Hetal Patel Kara Fong Matt McDermott Jimmy Shen Eric Sivonxay","title":"Helpers"},{"location":"primer/01_basic_python/0%20-%20Introduction%20and%20Jupyter%20Use/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Introduction to Python and Using Jupyter notebooks \u00b6 The Jupyter notebook is a platform for using and writing code in a dynamic way that allows users to combine cells of code snippets that are executed with a persistent namespace and kernel alongside markdown text for facilitating readability and visualization. In this notebook, we cover some basics of Jupyter functionality along with a discussion of some details of how you can use python in this environment and elsewhere. Installation \u00b6 For this workshop, we've constructed an online environment for everyone to use in order to smooth out any platform-dependent installation issues, but you'll probably want to install the tools we use today locally on your own machine. To do this, we recommend Anaconda , which is an effective tool for python package management that can create virtual environments, comes with a pre-installed IDE, and includes all of the Jupyter functionality that you'll see here. The Anaconda installer should be detailed on the page linked above, but here's another resource for installation that might be helpful. Code vs. Markdown \u00b6 Jupyter notebooks are broken down into \"cells\" which might contain either code or markdown. If you select a cell with your mouse, it should be highlighted with a green border indicating that you are in \"edit,\" mode and can edit the contents of the cell. If text reading In [ ]: is on the left hand side of the cell, it's a \"code\" cell. For example, type the following and press \"Shift + Enter\" print ( \"Hello world!\" ) Hello world! Pressing \"Shift + Enter\" executes the code in the cell, prints the output below the cell, and creates a new cell below that one. In addition to code cells, you can also write your own markdown cells by converting a cell using either the dropdown menu in the toolbar or pressing \"Esc + m\". In general, pressing escape enters \"command mode\" for which you can issue a number of commands, including f - find and replace m - convert to markdown y - convert to code h - open the help menu Right now, trying typing \"Esc + h\" to open the help/shortcut menu and peruse it. Spend a minute testing out some of the shortcuts. Note that markdown cells are quite flexible and can basically do anything wikipedia does, including adding \\LaTeX \\LaTeX -formatted equations. \\hat{H}\\psi = E \\psi \\hat{H}\\psi = E \\psi Shell commands, magic, and where to learn more \u00b6 Jupyter notebooks can also issue commands to the shell, which can be achieved using the ! symbol at the beginning of the cell: ! ls . 0 - Introduction and Jupyter Use.ipynb Exercises.ipynb 1 - Python Primer.ipynb inflammation-01.csv Exercise_Solutions.ipynb ! date Mon Jul 27 14:57:00 PDT 2020 In addition, certain things can be achieved in Jupyter notebooks using what are called \"magic\" commands, which are demarcated using the % sign. The most common of these are the magic function to enable inline plotting: % matplotlib inline and to invoke the debugger in a particular cell on an error: % pdb Automatic pdb calling has been turned ON These functions set up special functionality in the notebook. Lastly, note that Jupyter notebooks are becoming increasingly popular as tools to supplement publication. As a computational researcher, you can provide explicit documentation of your methods with embedded code that actually works for a person who wants to understand better what you're working on. In my own work, I've begun making all my plots and collecting all of my data in Jupyter notebooks to provide as supporting info for each of my recent papers. It's a bit more work, but you'll find that having this level of organization and being this transparent about your methods goes a long way. There are great resources for IPython notebooks online, and here are a few of them: Jupyter website A gallery of interesting notebooks","title":"Intro"},{"location":"primer/01_basic_python/0%20-%20Introduction%20and%20Jupyter%20Use/#introduction-to-python-and-using-jupyter-notebooks","text":"The Jupyter notebook is a platform for using and writing code in a dynamic way that allows users to combine cells of code snippets that are executed with a persistent namespace and kernel alongside markdown text for facilitating readability and visualization. In this notebook, we cover some basics of Jupyter functionality along with a discussion of some details of how you can use python in this environment and elsewhere.","title":"Introduction to Python and Using Jupyter notebooks"},{"location":"primer/01_basic_python/0%20-%20Introduction%20and%20Jupyter%20Use/#installation","text":"For this workshop, we've constructed an online environment for everyone to use in order to smooth out any platform-dependent installation issues, but you'll probably want to install the tools we use today locally on your own machine. To do this, we recommend Anaconda , which is an effective tool for python package management that can create virtual environments, comes with a pre-installed IDE, and includes all of the Jupyter functionality that you'll see here. The Anaconda installer should be detailed on the page linked above, but here's another resource for installation that might be helpful.","title":"Installation"},{"location":"primer/01_basic_python/0%20-%20Introduction%20and%20Jupyter%20Use/#code-vs-markdown","text":"Jupyter notebooks are broken down into \"cells\" which might contain either code or markdown. If you select a cell with your mouse, it should be highlighted with a green border indicating that you are in \"edit,\" mode and can edit the contents of the cell. If text reading In [ ]: is on the left hand side of the cell, it's a \"code\" cell. For example, type the following and press \"Shift + Enter\" print ( \"Hello world!\" ) Hello world! Pressing \"Shift + Enter\" executes the code in the cell, prints the output below the cell, and creates a new cell below that one. In addition to code cells, you can also write your own markdown cells by converting a cell using either the dropdown menu in the toolbar or pressing \"Esc + m\". In general, pressing escape enters \"command mode\" for which you can issue a number of commands, including f - find and replace m - convert to markdown y - convert to code h - open the help menu Right now, trying typing \"Esc + h\" to open the help/shortcut menu and peruse it. Spend a minute testing out some of the shortcuts. Note that markdown cells are quite flexible and can basically do anything wikipedia does, including adding \\LaTeX \\LaTeX -formatted equations. \\hat{H}\\psi = E \\psi \\hat{H}\\psi = E \\psi","title":"Code vs. Markdown"},{"location":"primer/01_basic_python/0%20-%20Introduction%20and%20Jupyter%20Use/#shell-commands-magic-and-where-to-learn-more","text":"Jupyter notebooks can also issue commands to the shell, which can be achieved using the ! symbol at the beginning of the cell: ! ls . 0 - Introduction and Jupyter Use.ipynb Exercises.ipynb 1 - Python Primer.ipynb inflammation-01.csv Exercise_Solutions.ipynb ! date Mon Jul 27 14:57:00 PDT 2020 In addition, certain things can be achieved in Jupyter notebooks using what are called \"magic\" commands, which are demarcated using the % sign. The most common of these are the magic function to enable inline plotting: % matplotlib inline and to invoke the debugger in a particular cell on an error: % pdb Automatic pdb calling has been turned ON These functions set up special functionality in the notebook. Lastly, note that Jupyter notebooks are becoming increasingly popular as tools to supplement publication. As a computational researcher, you can provide explicit documentation of your methods with embedded code that actually works for a person who wants to understand better what you're working on. In my own work, I've begun making all my plots and collecting all of my data in Jupyter notebooks to provide as supporting info for each of my recent papers. It's a bit more work, but you'll find that having this level of organization and being this transparent about your methods goes a long way. There are great resources for IPython notebooks online, and here are a few of them: Jupyter website A gallery of interesting notebooks","title":"Shell commands, magic, and where to learn more"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Basic Python \u00b6 Lesson 1: Expressions, variables and built-in functions \u00b6 Expressions \u00b6 An expression describes a computation. Python evaluates expressions and generates a value. We say that expressions \"evaluate to\" their result. 2019 2019 Python's arithmetic operators allows you to use a Python command line or Jupyter notebook cell as a \"calculator\" 2000 + 19 2019 2000 - 19 1981 Multiplication is done with an asterisk * 1 * 2 * ( 3 * 4 ) 24 Normal or \"true\" division is done with / . This operation will always return a float 10 / 2 5.0 Python has two other division operators. \"Floor\" division // , which returns the division rounded down to the lowest integer, and the modulo operator % , which returns the remainder of a division after substracting the next lowest integer. These are easier to understand by example: 10 // 6 1 10 % 6 4 6 // 2 3 6 % 3 0 To take an exponent, use two asterisks ** (NOT ^ ) 2 ** 3 8 Variables \u00b6 * Variables are names for values. * In Python the = symbol assigns the value on the right to the name on the left. * The variable is created when a value is assigned to it. * Every variable has a type that describes what sort of data it contains. Some of the most common types are int (integer), float (floating point number), and string (text) * Unlike many other languages, in Python you do not have to specify the type when you create a variable. Python infers the data type based on the context. This is called 'duck typing'. int variables are simply numbers. Let's assign 27 to a variable 'age'. If the variable age does not already exist, this assignment expression will create it age = 27 You can find the type of a variable using the type() function. Let's examine the type of age . type ( age ) int float variables are created by adding a decimal point to a number. Let's redefine age as 27.0 and check the type age = 27.0 type ( age ) float string variables contain text and are created using quotation marks. Both single and double quotation marks are OK. Let's try making age a string first_name = \"Ryan\" type ( first_name ) str Note that it's possible to create a string that contains only numbers age = \"27\" type ( age ) str In the Jupyter notebook, variable names are preserved between cells. In more formal language, the namespace of a notebook is preserved unless the kernel is reset, which resets all of the variable names. You can see this if you execute the following cells out of sequence. Try it out. Also try resetting the kernel and executing just the latter half. age = 42 age 42 Assigning a new value to an existing variable will replace the value of that variable age = 29 age 29 Built-in functions \u00b6 Now that we understand how Python and Jupyter handle variables, let's talk about built-in functions . These functions are available by default without issuing any special instructions. One such function is type , which we've already used. Functions are called using the function name and parentheses, which enclose the function arguments . In the example below, print is the function, and the string \"Hello world!\" is the argument. print ( \"Hello world!\" ) Hello world! print can accept multiple arguments, separate by commas, and will combine them together to generate its output, like this: print ( \"Age is\" , age , \"years\" ) Age is 29 years One of the most important things you can know when learning programming is where to access help on the things you're trying to use. There are a number of ways to access information on a function. Three of the easiest ways in Jupyter are Place your cursor inside the name of any function, and press SHIFT+TAB. This will open a small box with function information, which can be expanded by pressing tab again. Use the built-in help function, where the argument to help is the name of the function you want to know more about. Type the name of the function followed by ? , which will show the functions documentation or 'docstring' Finding help \u00b6 ## click your cursor inside 'print' and press SHIFT+TAB print ( \"this is cool\" ) this is cool help ( print ) Help on built-in function print in module builtins: print(...) print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False) Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline. flush: whether to forcibly flush the stream. print ? Importing other modules and functions \u00b6 To get a function that's not built in to Python, we use the import statement. In this example, we're going to import a module called math that contains a number of functions that can be accessed by using math.FUNCTION_NAME_HERE . import math math . exp ( 2 ) 7.38905609893065 print ( \"Exponent of 2:\" , math . exp ( 2 )) print ( \"Sine of 3.1415:\" , math . sin ( 3.1415 )) Exponent of 2: 7.38905609893065 Sine of 3.1415: 9.265358966049024e-05 The Standard library includes a number of modules that come pre-installed with the python programming language itself, which is summarized in this documentation . Python's real power, however, comes in how extensible it is. Python has an ecosystem of external libraries that provide special functions for many different tasks. Three of the most common external libraries in python are: numpy - for efficient numerical array manipulation and operation scipy - for a number of tools related to scientific computing matplotlib - for plotting data and creating figures Let's use some functions from numpy and matplotlib to create a plot import numpy as np from matplotlib import pyplot inflammation = np . loadtxt ( \"inflammation-01.csv\" , delimiter = ',' ) % matplotlib inline average = np . average ( inflammation , axis = 0 ) pyplot . plot ( average ) [<matplotlib.lines.Line2D at 0x7f97f8648580>] Lesson 2: Lists and Strings \u00b6 A list stores many values in a single structure. \u00b6 A list stores many values together. Contained within square brackets [...] . Values separated by commas , . Use len to find out how many values are in a list. pressures = [ 0.273 , 0.275 , 0.277 , 0.275 , 0.276 ] print ( 'pressures:' , pressures ) pressures: [0.273, 0.275, 0.277, 0.275, 0.276] Use the built-in function len to find the length of a list \u00b6 len ( pressures ) 5 Lists may be heterogeneous \u00b6 Values can have different types goals = [ 1 , 'Create lists.' , 2 , 'Extract items from lists.' , 3 , 'Modify lists.' ] Index and slice to get information out of a string/list \u00b6 Locations are numbered from 0 rather than 1 Negative indices count backward from the end of the string Slices include the lower bound but exclude the upper bound, so (upper - lower) is the slice's length numbers = [ \"one\" , \"two\" , \"three\" , \"four\" , \"five\" ] print ( 'first element:' , numbers [ 0 ]) print ( 'last element:' , numbers [ - 1 ]) print ( 'middle elemnets:' , numbers [ 2 : 5 ]) first element: one last element: five middle elemnets: ['three', 'four', 'five'] Indexing beyond the end of a collection is an error # NBVAL_RAISES_EXCEPTION ## This code will fail print ( '99th element of numbers is:' , numbers [ 99 ]) --------------------------------------------------------------------------- IndexError Traceback (most recent call last) <ipython-input-38-89d4ca35c24b> in <module> 1 # NBVAL_RAISES_EXCEPTION 2 ## This code will fail ----> 3 print ( '99th element of numbers is:' , numbers [ 99 ] ) IndexError : list index out of range List values can be replaced by assigning to them \u00b6 Use an index expression on the left of assignment to replace a value. We say that lists are mutable because their contents can be changed after they are created pressures [ 0 ] = 0.265 print ( 'pressures is now:' , pressures ) pressures is now: [0.265, 0.275, 0.277, 0.275, 0.276] Appending items to a list lengthens it \u00b6 use list_name.append to add items to the end of a list. primes = [ 2 , 3 , 5 ] print ( 'primes is initially:' , primes ) primes . append ( 7 ) primes . append ( 9 ) print ( 'primes has become:' , primes ) primes is initially: [2, 3, 5] primes has become: [2, 3, 5, 7, 9] * append is a method of lists * like a function, but tied to a particular object Use object_name.method_name to call methods deliberately resembles the way we refer to things in a library We will meet other methods of lists as we go along Use help(list) for a preview Extending a list adds another list to it \u00b6 extend is similar to append , but it allows you to combine two lists. teen_primes = [ 11 , 13 , 17 , 19 ] older_primes = [ 23 , 31 , 47 , 59 ] print ( 'primes is currently:' , primes ) primes . extend ( teen_primes ) print ( 'primes has now become:' , primes ) primes . append ( older_primes ) print ( 'primes has finally become:' , primes ) primes is currently: [2, 3, 5, 7, 9] primes has now become: [2, 3, 5, 7, 9, 11, 13, 17, 19] primes has finally become: [2, 3, 5, 7, 9, 11, 13, 17, 19, [23, 31, 47, 59]] Note that while extend maintains the \"flat\" structure of the list, appending a list to a list makes the result two-dimensional. Use del to remove items from a list entirely \u00b6 del list_name[index] removes an item from a list and shortens the list. Not a function or method, but a statement in the language. print ( 'primes before removing item:' , primes ) del primes [ 4 ] print ( 'primes after removing item:' , primes ) primes before removing last item: [2, 3, 5, 7, 9, 11, 13, 17, 19, [23, 31, 47, 59]] primes after removing last item: [2, 3, 5, 7, 11, 13, 17, 19, [23, 31, 47, 59]] The empty list contains no values \u00b6 [] is \"the zero of lists\" Helpful as a starting point for collecting values NEVER use an empty list as a default argument in a function! Strings can be sliced and indexed just like lists \u00b6 You can think of strings as lists of characters greeting = \"My name is Ryan\" print ( 'first character:' , greeting [ 0 ]) print ( 'last character:' , greeting [ - 1 ]) print ( 'middle character:' , greeting [ 2 : 5 ]) first character: M last character: n middle character: na Unlike lists, strings are immutable \u00b6 Cannot change the characters in a string after it has been created. Python considers the string to be a single value with parts, not a collection of values. # NBVAL_RAISES_EXCEPTION element = 'helium' ## This code will fail element [ 0 ] = 'C' --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-44-789481aab7e2> in <module> 2 element = 'helium' 3 ## This code will fail ----> 4 element [ 0 ] = 'C' TypeError : 'str' object does not support item assignment Lesson 3: For loops \u00b6 A for loop can be used to repeat actions over a set of values. Let's print each letter in this list: name = [ 'J' , 'i' , 'm' , 'm' , 'y' ] for letter in name : print ( letter ) J i m m y For loop syntax \u00b6 For loops are constructed via the syntax for LOOP_VARIABLE in ITERABLE. The loop variable in the above example I've used is letter and the iterable I've used is the list name , which was defined as '['J', 'i', 'm', 'm', 'y']' . Other iterables include strings and dictionary keys, among others. For example, we could make name a string and iterate through it in the same way we iterated through the list: name = 'Jimmy' for letter in name : print ( letter ) J i m m y You can also use list indexing notation to limit iteration to a certain portion of an iterable. name = 'Jimmy' for letter in name [ 0 : 3 ]: print ( letter ) J i m Iterables have a length, and you can find this length using the len function. print ( \"Length of\" , name , \"is\" , len ( name )) Length of Jimmy is 5 Use enumerate() to get both an index and an item \u00b6 The enumerate function assigns an index (or counter) to each value of an iterable. It returns a tuple of (counter, value) that can be useful in for loops. For example, here we assign the index to the variable n and the value of the iterable to letter : for n , letter in enumerate ( name ): print ( \"Letter\" , n , \"-\" , letter ) Letter 0 - J Letter 1 - i Letter 2 - m Letter 3 - m Letter 4 - y Use zip() to loop over two iterables simultaneously \u00b6 The zip function can be used to loop through two iterables simultaneously (like two sides of a zipper). Here, we use zip to iterate through two strings that have the same length for letter1 , letter2 in zip ( \"Jimmy\" , \"Heath\" ): print ( letter1 , letter2 ) J H i e m a m t y h Use range() to iterate ranges of numbers \u00b6 The range function is used to construct an iterable corresponding to a set of numbers beginning at 0 and ending at a certain number: for number in range ( 6 ): print ( number ) 0 1 2 3 4 5 Logic within for loops \u00b6 range can take multiple arguments, where the first argument is interpreted as the beginning of the range. In the example below, we combine a for loop with an if statement to print only the even numbers. This makes use of the modulo % operator we covered in the Variables lesson. for number in range ( 2 , 10 ): if number % 2 == 0 : print ( number , \"is even\" ) 2 is even 4 is even 6 is even 8 is even break stops the loop \u00b6 The break statement is used to stop iterating through an iterable if some condition is met. Here, we will end our loop as soon as we encouter the number 6: for number in range ( 2 , 10 ): if number == 6 : break else : print ( number ) 2 3 4 5 A common use of for loops is to keep track of a running total of numbers. In this pattern, it's important to declare the variable that you're adding to outside the scope of the for loop. The example below makes use of the \"in place addition\" += operator, which says \"add the value on the right of the operator to the value of the variable on the left\". So x += 5 means \"add 5 to the current value of variable x . Python has similar \"in place\" operators for several other operations, including -= , *= , and /= for subtraction, multiplication, and division, respectively. my_sum = 0 for number in range ( 6 ): my_sum += number print ( \"Sum of numbers from 0 to 5 is\" , my_sum ) Sum of numbers from 0 to 5 is 15","title":"Basic Python"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#basic-python","text":"","title":"Basic Python"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#lesson-1-expressions-variables-and-built-in-functions","text":"","title":"Lesson 1: Expressions, variables and built-in functions"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#expressions","text":"An expression describes a computation. Python evaluates expressions and generates a value. We say that expressions \"evaluate to\" their result. 2019 2019 Python's arithmetic operators allows you to use a Python command line or Jupyter notebook cell as a \"calculator\" 2000 + 19 2019 2000 - 19 1981 Multiplication is done with an asterisk * 1 * 2 * ( 3 * 4 ) 24 Normal or \"true\" division is done with / . This operation will always return a float 10 / 2 5.0 Python has two other division operators. \"Floor\" division // , which returns the division rounded down to the lowest integer, and the modulo operator % , which returns the remainder of a division after substracting the next lowest integer. These are easier to understand by example: 10 // 6 1 10 % 6 4 6 // 2 3 6 % 3 0 To take an exponent, use two asterisks ** (NOT ^ ) 2 ** 3 8","title":"Expressions"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#variables","text":"* Variables are names for values. * In Python the = symbol assigns the value on the right to the name on the left. * The variable is created when a value is assigned to it. * Every variable has a type that describes what sort of data it contains. Some of the most common types are int (integer), float (floating point number), and string (text) * Unlike many other languages, in Python you do not have to specify the type when you create a variable. Python infers the data type based on the context. This is called 'duck typing'. int variables are simply numbers. Let's assign 27 to a variable 'age'. If the variable age does not already exist, this assignment expression will create it age = 27 You can find the type of a variable using the type() function. Let's examine the type of age . type ( age ) int float variables are created by adding a decimal point to a number. Let's redefine age as 27.0 and check the type age = 27.0 type ( age ) float string variables contain text and are created using quotation marks. Both single and double quotation marks are OK. Let's try making age a string first_name = \"Ryan\" type ( first_name ) str Note that it's possible to create a string that contains only numbers age = \"27\" type ( age ) str In the Jupyter notebook, variable names are preserved between cells. In more formal language, the namespace of a notebook is preserved unless the kernel is reset, which resets all of the variable names. You can see this if you execute the following cells out of sequence. Try it out. Also try resetting the kernel and executing just the latter half. age = 42 age 42 Assigning a new value to an existing variable will replace the value of that variable age = 29 age 29","title":"Variables"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#built-in-functions","text":"Now that we understand how Python and Jupyter handle variables, let's talk about built-in functions . These functions are available by default without issuing any special instructions. One such function is type , which we've already used. Functions are called using the function name and parentheses, which enclose the function arguments . In the example below, print is the function, and the string \"Hello world!\" is the argument. print ( \"Hello world!\" ) Hello world! print can accept multiple arguments, separate by commas, and will combine them together to generate its output, like this: print ( \"Age is\" , age , \"years\" ) Age is 29 years One of the most important things you can know when learning programming is where to access help on the things you're trying to use. There are a number of ways to access information on a function. Three of the easiest ways in Jupyter are Place your cursor inside the name of any function, and press SHIFT+TAB. This will open a small box with function information, which can be expanded by pressing tab again. Use the built-in help function, where the argument to help is the name of the function you want to know more about. Type the name of the function followed by ? , which will show the functions documentation or 'docstring'","title":"Built-in functions"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#finding-help","text":"## click your cursor inside 'print' and press SHIFT+TAB print ( \"this is cool\" ) this is cool help ( print ) Help on built-in function print in module builtins: print(...) print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False) Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline. flush: whether to forcibly flush the stream. print ?","title":"Finding help"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#importing-other-modules-and-functions","text":"To get a function that's not built in to Python, we use the import statement. In this example, we're going to import a module called math that contains a number of functions that can be accessed by using math.FUNCTION_NAME_HERE . import math math . exp ( 2 ) 7.38905609893065 print ( \"Exponent of 2:\" , math . exp ( 2 )) print ( \"Sine of 3.1415:\" , math . sin ( 3.1415 )) Exponent of 2: 7.38905609893065 Sine of 3.1415: 9.265358966049024e-05 The Standard library includes a number of modules that come pre-installed with the python programming language itself, which is summarized in this documentation . Python's real power, however, comes in how extensible it is. Python has an ecosystem of external libraries that provide special functions for many different tasks. Three of the most common external libraries in python are: numpy - for efficient numerical array manipulation and operation scipy - for a number of tools related to scientific computing matplotlib - for plotting data and creating figures Let's use some functions from numpy and matplotlib to create a plot import numpy as np from matplotlib import pyplot inflammation = np . loadtxt ( \"inflammation-01.csv\" , delimiter = ',' ) % matplotlib inline average = np . average ( inflammation , axis = 0 ) pyplot . plot ( average ) [<matplotlib.lines.Line2D at 0x7f97f8648580>]","title":"Importing other modules and functions"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#lesson-2-lists-and-strings","text":"","title":"Lesson 2: Lists and Strings"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#a-list-stores-many-values-in-a-single-structure","text":"A list stores many values together. Contained within square brackets [...] . Values separated by commas , . Use len to find out how many values are in a list. pressures = [ 0.273 , 0.275 , 0.277 , 0.275 , 0.276 ] print ( 'pressures:' , pressures ) pressures: [0.273, 0.275, 0.277, 0.275, 0.276]","title":"A list stores many values in a single structure."},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#use-the-built-in-function-len-to-find-the-length-of-a-list","text":"len ( pressures ) 5","title":"Use the built-in function len to find the length of a list"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#lists-may-be-heterogeneous","text":"Values can have different types goals = [ 1 , 'Create lists.' , 2 , 'Extract items from lists.' , 3 , 'Modify lists.' ]","title":"Lists may be heterogeneous"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#index-and-slice-to-get-information-out-of-a-stringlist","text":"Locations are numbered from 0 rather than 1 Negative indices count backward from the end of the string Slices include the lower bound but exclude the upper bound, so (upper - lower) is the slice's length numbers = [ \"one\" , \"two\" , \"three\" , \"four\" , \"five\" ] print ( 'first element:' , numbers [ 0 ]) print ( 'last element:' , numbers [ - 1 ]) print ( 'middle elemnets:' , numbers [ 2 : 5 ]) first element: one last element: five middle elemnets: ['three', 'four', 'five'] Indexing beyond the end of a collection is an error # NBVAL_RAISES_EXCEPTION ## This code will fail print ( '99th element of numbers is:' , numbers [ 99 ]) --------------------------------------------------------------------------- IndexError Traceback (most recent call last) <ipython-input-38-89d4ca35c24b> in <module> 1 # NBVAL_RAISES_EXCEPTION 2 ## This code will fail ----> 3 print ( '99th element of numbers is:' , numbers [ 99 ] ) IndexError : list index out of range","title":"Index and slice to get information out of a string/list"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#list-values-can-be-replaced-by-assigning-to-them","text":"Use an index expression on the left of assignment to replace a value. We say that lists are mutable because their contents can be changed after they are created pressures [ 0 ] = 0.265 print ( 'pressures is now:' , pressures ) pressures is now: [0.265, 0.275, 0.277, 0.275, 0.276]","title":"List values can be replaced by assigning to them"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#appending-items-to-a-list-lengthens-it","text":"use list_name.append to add items to the end of a list. primes = [ 2 , 3 , 5 ] print ( 'primes is initially:' , primes ) primes . append ( 7 ) primes . append ( 9 ) print ( 'primes has become:' , primes ) primes is initially: [2, 3, 5] primes has become: [2, 3, 5, 7, 9] * append is a method of lists * like a function, but tied to a particular object Use object_name.method_name to call methods deliberately resembles the way we refer to things in a library We will meet other methods of lists as we go along Use help(list) for a preview","title":"Appending items to a list lengthens it"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#extending-a-list-adds-another-list-to-it","text":"extend is similar to append , but it allows you to combine two lists. teen_primes = [ 11 , 13 , 17 , 19 ] older_primes = [ 23 , 31 , 47 , 59 ] print ( 'primes is currently:' , primes ) primes . extend ( teen_primes ) print ( 'primes has now become:' , primes ) primes . append ( older_primes ) print ( 'primes has finally become:' , primes ) primes is currently: [2, 3, 5, 7, 9] primes has now become: [2, 3, 5, 7, 9, 11, 13, 17, 19] primes has finally become: [2, 3, 5, 7, 9, 11, 13, 17, 19, [23, 31, 47, 59]] Note that while extend maintains the \"flat\" structure of the list, appending a list to a list makes the result two-dimensional.","title":"Extending a list adds another list to it"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#use-del-to-remove-items-from-a-list-entirely","text":"del list_name[index] removes an item from a list and shortens the list. Not a function or method, but a statement in the language. print ( 'primes before removing item:' , primes ) del primes [ 4 ] print ( 'primes after removing item:' , primes ) primes before removing last item: [2, 3, 5, 7, 9, 11, 13, 17, 19, [23, 31, 47, 59]] primes after removing last item: [2, 3, 5, 7, 11, 13, 17, 19, [23, 31, 47, 59]]","title":"Use del to remove items from a list entirely"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#the-empty-list-contains-no-values","text":"[] is \"the zero of lists\" Helpful as a starting point for collecting values NEVER use an empty list as a default argument in a function!","title":"The empty list contains no values"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#strings-can-be-sliced-and-indexed-just-like-lists","text":"You can think of strings as lists of characters greeting = \"My name is Ryan\" print ( 'first character:' , greeting [ 0 ]) print ( 'last character:' , greeting [ - 1 ]) print ( 'middle character:' , greeting [ 2 : 5 ]) first character: M last character: n middle character: na","title":"Strings can be sliced and indexed just like lists"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#unlike-lists-strings-are-immutable","text":"Cannot change the characters in a string after it has been created. Python considers the string to be a single value with parts, not a collection of values. # NBVAL_RAISES_EXCEPTION element = 'helium' ## This code will fail element [ 0 ] = 'C' --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-44-789481aab7e2> in <module> 2 element = 'helium' 3 ## This code will fail ----> 4 element [ 0 ] = 'C' TypeError : 'str' object does not support item assignment","title":"Unlike lists, strings are immutable"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#lesson-3-for-loops","text":"A for loop can be used to repeat actions over a set of values. Let's print each letter in this list: name = [ 'J' , 'i' , 'm' , 'm' , 'y' ] for letter in name : print ( letter ) J i m m y","title":"Lesson 3: For loops"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#for-loop-syntax","text":"For loops are constructed via the syntax for LOOP_VARIABLE in ITERABLE. The loop variable in the above example I've used is letter and the iterable I've used is the list name , which was defined as '['J', 'i', 'm', 'm', 'y']' . Other iterables include strings and dictionary keys, among others. For example, we could make name a string and iterate through it in the same way we iterated through the list: name = 'Jimmy' for letter in name : print ( letter ) J i m m y You can also use list indexing notation to limit iteration to a certain portion of an iterable. name = 'Jimmy' for letter in name [ 0 : 3 ]: print ( letter ) J i m Iterables have a length, and you can find this length using the len function. print ( \"Length of\" , name , \"is\" , len ( name )) Length of Jimmy is 5","title":"For loop syntax"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#use-enumerate-to-get-both-an-index-and-an-item","text":"The enumerate function assigns an index (or counter) to each value of an iterable. It returns a tuple of (counter, value) that can be useful in for loops. For example, here we assign the index to the variable n and the value of the iterable to letter : for n , letter in enumerate ( name ): print ( \"Letter\" , n , \"-\" , letter ) Letter 0 - J Letter 1 - i Letter 2 - m Letter 3 - m Letter 4 - y","title":"Use enumerate() to get both an index and an item"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#use-zip-to-loop-over-two-iterables-simultaneously","text":"The zip function can be used to loop through two iterables simultaneously (like two sides of a zipper). Here, we use zip to iterate through two strings that have the same length for letter1 , letter2 in zip ( \"Jimmy\" , \"Heath\" ): print ( letter1 , letter2 ) J H i e m a m t y h","title":"Use zip() to loop over two iterables simultaneously"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#use-range-to-iterate-ranges-of-numbers","text":"The range function is used to construct an iterable corresponding to a set of numbers beginning at 0 and ending at a certain number: for number in range ( 6 ): print ( number ) 0 1 2 3 4 5","title":"Use range() to iterate ranges of numbers"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#logic-within-for-loops","text":"range can take multiple arguments, where the first argument is interpreted as the beginning of the range. In the example below, we combine a for loop with an if statement to print only the even numbers. This makes use of the modulo % operator we covered in the Variables lesson. for number in range ( 2 , 10 ): if number % 2 == 0 : print ( number , \"is even\" ) 2 is even 4 is even 6 is even 8 is even","title":"Logic within for loops"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#break-stops-the-loop","text":"The break statement is used to stop iterating through an iterable if some condition is met. Here, we will end our loop as soon as we encouter the number 6: for number in range ( 2 , 10 ): if number == 6 : break else : print ( number ) 2 3 4 5 A common use of for loops is to keep track of a running total of numbers. In this pattern, it's important to declare the variable that you're adding to outside the scope of the for loop. The example below makes use of the \"in place addition\" += operator, which says \"add the value on the right of the operator to the value of the variable on the left\". So x += 5 means \"add 5 to the current value of variable x . Python has similar \"in place\" operators for several other operations, including -= , *= , and /= for subtraction, multiplication, and division, respectively. my_sum = 0 for number in range ( 6 ): my_sum += number print ( \"Sum of numbers from 0 to 5 is\" , my_sum ) Sum of numbers from 0 to 5 is 15","title":"break stops the loop"},{"location":"primer/01_basic_python/Exercise_Solutions/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Python Primer Exercises (with Solutions) \u00b6 Lesson 1 - Variables, Expressions, and Functions \u00b6 Exercise: Types \u00b6 Consider the following code: var1 = 1 var2 = 1. var3 = \"one\" var4 = \"3.14159\" What is the type of var1 ? int What is the type of var2 ? float What is the type of var3 ? str What is the type of var4 ? str Exercise: Find the type \u00b6 Determine the type of the variable mystery using a built-in function mystery = { \"a\" : 1 , \"b\" : 2 } mystery = { \"a\" : 1 , \"b\" : 2 } type ( mystery ) Exercise: Converting types \u00b6 Given this: var2 = 1. var4 = \"1.0\" Explain in simple terms what float(var4) does. Explain in simple terms what str(var2) does. var2 = 1. var4 = \"1.0\" ## float(var4) turns var4 from a str to a float float ( var4 ) ## str(var2) turns var2 from a float to a str str ( var2 ) Exercise: Imports \u00b6 Fill in the blanks so that the two programs below run without errors. import __ print ( \"The current directory is {} \" . format ( os . getcwd ())) import ____ print ( \"The square root of 2 is {} \" . format ( math . sqrt ( 2 ))) import os print ( \"The current directory is {} \" . format ( os . getcwd ())) import math print ( \"The square root of 2 is {} \" . format ( math . sqrt ( 2 ))) Lesson 2: Lists and Strings \u00b6 Exercise: Slicing \u00b6 What does the following print: material = 'carbon' print ( 'material[1:3] is:' , material [ 1 : 3 ]) In words, explain what does material[low:high] do? (where low and high are arbitrary numbers) material = 'carbon' print ( 'material[1:3] is:' , material [ 1 : 3 ]) ## it returns a slice of element from position low to position high (starting from 0), e.g. material [ 2 : 4 ] In words, explain what does material[low:] do? (where low is an arbitrary number) ## it returns everything in element starting from position low, e.g. material [ 2 :] In words, explain what does material[:high] do? (where low is an arbitrary number) ## it returns everything in element before position high, e.g. material [: 2 ] What does material[:] do? ## it returns the entire string material [:] What about material[::2] ? material[::-1] ? ## material[::2] returns every second character of material material [:: 2 ] ## material[:-1] returns every character, in reverse order material [:: - 1 ] Exercise: Fill in the blanks \u00b6 Fill in the blanks so that the program below produces the output shown. values = ____ values . ____ ( 1 ) values . ____ ( 3 ) values . ____ ( 5 ) print ( 'first time:' , values ) values = values [ ____ ] print ( 'second time:' , values ) \u00b6 first time: [1, 3, 5] second time: [3, 5] values = [] values . append ( 1 ) values . append ( 3 ) values . append ( 5 ) print ( 'first time:' , values ) values = values [ 1 :] print ( 'second time:' , values ) Exercise: From strings to lists and back \u00b6 Given this: print ( 'string to list:' , list ( 'tin' )) print ( 'list to string:' , '-' . join ([ 'g' , 'o' , 'l' , 'd' ])) \u00b6 ['t', 'i', 'n'] 'g-o-l-d' Explain in simple terms what list('some string') does. ## list('some string') returns a list, where each element of the list is one character of the string (including spaces), e.g. list ( 'some string' ) 2. What does ' <=> '.join(['x', 'y']) generate? ## '.'.join(list) returns the string of every element in a list, separated by the str that precedes 'join' ' <=> ' . join ([ 'x' , 'y' , 'z' ]) Exercise: Sort and Sorted \u00b6 What do these two programs print? In simple terms, explain the difference between sorted(letters) and letters.sort() . ## Program A letters = list ( 'gold' ) result = sorted ( letters ) print ( 'letters is' , letters , 'and result is' , result ) \u00b6 ## Program B letters = list ( 'gold' ) result = letters . sort () print ( 'letters is' , letters , 'and result is' , result ) sorted(letters) returns a new list containing the elements of letters sorted alphebetically ## Program A letters = list ( 'gold' ) result = sorted ( letters ) print ( 'letters is' , letters , 'and result is' , result ) letters.sort() sorts letters alphabetically and doesn't return anyting ( result is None ) ## Program B letters = list ( 'gold' ) result = letters . sort () print ( 'letters is' , letters , 'and result is' , result ) Exercise: Copying (or Not) \u00b6 What do these two programs print? In simple terms, explain the difference between new = old and new = old[:] . ## Program A old = list ( 'gold' ) new = old # simple assignment new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) \u00b6 ## Program B old = list ( 'gold' ) new = old [:] # assigning a slice new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) Because list is a mutable type, assignment of a list to another variable creates a reference from new to old in memory. Therefore, modifying new also modifies old old = list ( 'gold' ) new = old # simple assignment new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) On the other hand, a slice of a list is immutable , so assigning a slice of old to new creates a copy that can be modified independently of old old = list ( 'gold' ) new = old [:] # assigning a slice new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) Lesson 3: For loops \u00b6 Exercise: write a for loop that computes the sum of all of the squares from 2 to 11. \u00b6 s = 0 for i in range ( 10 ): s += pow ( i + 2 , 2 ) print ( s ) Exercise: write a for loop that prints each item in the list friends , but stops when it encounters the third value \u00b6 friends = [\"Rachel\", \"Monica\", \"Chandler\", \"Ross\", \"Joey\"] friends = [ \"Rachel\" , \"Monica\" , \"Chandler\" , \"Ross\" , \"Joey\" ] for i , friend in enumerate ( friends ): if i == 3 : break else : print ( friend ) Exercise: Explain in a few words what happens when you call zip on two iterables that have different lengths \u00b6 zip will stop when it reaches the end of the shorter iterable s1 = 'Jim' s2 = 'Spock' for a , b in zip ( s1 , s2 ): print ( a , b ) Exercise (bonus): Write a Python program to construct the following pattern, using a nested for loop. \u00b6 * * * * * * * * * * * * * * * * * * * * * * * * * Hint: by default the print function inserts a newline character at the end of every line it prints. To suppress this, set the end argument to \"\", like print(\"something\", end=\"\") Hint: you can iterate through a range of numbers in reverse order by passing a negative number as a third argument to range , e.g. range(0,10,-1) n = 5 for i in range ( n ): # rows for j in range ( i ): # columns print ( '* ' , end = \"\" ) print ( '' ) for i in range ( n , 0 , - 1 ): for j in range ( i ): print ( '* ' , end = \"\" ) print ( '' )","title":"Exercise Solutions"},{"location":"primer/01_basic_python/Exercise_Solutions/#python-primer-exercises-with-solutions","text":"","title":"Python Primer Exercises (with Solutions)"},{"location":"primer/01_basic_python/Exercise_Solutions/#lesson-1-variables-expressions-and-functions","text":"","title":"Lesson 1 - Variables, Expressions, and Functions"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-types","text":"Consider the following code: var1 = 1 var2 = 1. var3 = \"one\" var4 = \"3.14159\" What is the type of var1 ? int What is the type of var2 ? float What is the type of var3 ? str What is the type of var4 ? str","title":"Exercise: Types"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-find-the-type","text":"Determine the type of the variable mystery using a built-in function mystery = { \"a\" : 1 , \"b\" : 2 } mystery = { \"a\" : 1 , \"b\" : 2 } type ( mystery )","title":"Exercise: Find the type"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-converting-types","text":"Given this: var2 = 1. var4 = \"1.0\" Explain in simple terms what float(var4) does. Explain in simple terms what str(var2) does. var2 = 1. var4 = \"1.0\" ## float(var4) turns var4 from a str to a float float ( var4 ) ## str(var2) turns var2 from a float to a str str ( var2 )","title":"Exercise: Converting types"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-imports","text":"Fill in the blanks so that the two programs below run without errors. import __ print ( \"The current directory is {} \" . format ( os . getcwd ())) import ____ print ( \"The square root of 2 is {} \" . format ( math . sqrt ( 2 ))) import os print ( \"The current directory is {} \" . format ( os . getcwd ())) import math print ( \"The square root of 2 is {} \" . format ( math . sqrt ( 2 )))","title":"Exercise: Imports"},{"location":"primer/01_basic_python/Exercise_Solutions/#lesson-2-lists-and-strings","text":"","title":"Lesson 2: Lists and Strings"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-slicing","text":"What does the following print: material = 'carbon' print ( 'material[1:3] is:' , material [ 1 : 3 ]) In words, explain what does material[low:high] do? (where low and high are arbitrary numbers) material = 'carbon' print ( 'material[1:3] is:' , material [ 1 : 3 ]) ## it returns a slice of element from position low to position high (starting from 0), e.g. material [ 2 : 4 ] In words, explain what does material[low:] do? (where low is an arbitrary number) ## it returns everything in element starting from position low, e.g. material [ 2 :] In words, explain what does material[:high] do? (where low is an arbitrary number) ## it returns everything in element before position high, e.g. material [: 2 ] What does material[:] do? ## it returns the entire string material [:] What about material[::2] ? material[::-1] ? ## material[::2] returns every second character of material material [:: 2 ] ## material[:-1] returns every character, in reverse order material [:: - 1 ]","title":"Exercise: Slicing"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-fill-in-the-blanks","text":"Fill in the blanks so that the program below produces the output shown.","title":"Exercise: Fill in the blanks"},{"location":"primer/01_basic_python/Exercise_Solutions/#values-____-values____1-values____3-values____5-printfirst-time-values-values-values____-printsecond-time-values","text":"first time: [1, 3, 5] second time: [3, 5] values = [] values . append ( 1 ) values . append ( 3 ) values . append ( 5 ) print ( 'first time:' , values ) values = values [ 1 :] print ( 'second time:' , values )","title":"values = ____\nvalues.____(1)\nvalues.____(3)\nvalues.____(5)\nprint(&#39;first time:&#39;, values)\nvalues = values[____]\nprint(&#39;second time:&#39;, values)\n"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-from-strings-to-lists-and-back","text":"Given this:","title":"Exercise: From strings to lists and back"},{"location":"primer/01_basic_python/Exercise_Solutions/#printstring-to-list-listtin-printlist-to-string-joing-o-l-d","text":"['t', 'i', 'n'] 'g-o-l-d' Explain in simple terms what list('some string') does. ## list('some string') returns a list, where each element of the list is one character of the string (including spaces), e.g. list ( 'some string' ) 2. What does ' <=> '.join(['x', 'y']) generate? ## '.'.join(list) returns the string of every element in a list, separated by the str that precedes 'join' ' <=> ' . join ([ 'x' , 'y' , 'z' ])","title":"print(&#39;string to list:&#39;, list(&#39;tin&#39;))\nprint(&#39;list to string:&#39;, &#39;-&#39;.join([&#39;g&#39;, &#39;o&#39;, &#39;l&#39;, &#39;d&#39;]))\n"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-sort-and-sorted","text":"What do these two programs print? In simple terms, explain the difference between sorted(letters) and letters.sort() .","title":"Exercise: Sort and Sorted"},{"location":"primer/01_basic_python/Exercise_Solutions/#program-a-letters-listgold-result-sortedletters-printletters-is-letters-and-result-is-result","text":"## Program B letters = list ( 'gold' ) result = letters . sort () print ( 'letters is' , letters , 'and result is' , result ) sorted(letters) returns a new list containing the elements of letters sorted alphebetically ## Program A letters = list ( 'gold' ) result = sorted ( letters ) print ( 'letters is' , letters , 'and result is' , result ) letters.sort() sorts letters alphabetically and doesn't return anyting ( result is None ) ## Program B letters = list ( 'gold' ) result = letters . sort () print ( 'letters is' , letters , 'and result is' , result )","title":"## Program A\nletters = list(&#39;gold&#39;)\nresult = sorted(letters)\nprint(&#39;letters is&#39;, letters, &#39;and result is&#39;, result)\n"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-copying-or-not","text":"What do these two programs print? In simple terms, explain the difference between new = old and new = old[:] .","title":"Exercise: Copying (or Not)"},{"location":"primer/01_basic_python/Exercise_Solutions/#program-a-old-listgold-new-old-simple-assignment-new0-d-printnew-is-new-and-old-is-old","text":"## Program B old = list ( 'gold' ) new = old [:] # assigning a slice new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) Because list is a mutable type, assignment of a list to another variable creates a reference from new to old in memory. Therefore, modifying new also modifies old old = list ( 'gold' ) new = old # simple assignment new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) On the other hand, a slice of a list is immutable , so assigning a slice of old to new creates a copy that can be modified independently of old old = list ( 'gold' ) new = old [:] # assigning a slice new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old )","title":"## Program A\nold = list(&#39;gold&#39;)\nnew = old      # simple assignment\nnew[0] = &#39;D&#39;\nprint(&#39;new is&#39;, new, &#39;and old is&#39;, old)\n"},{"location":"primer/01_basic_python/Exercise_Solutions/#lesson-3-for-loops","text":"","title":"Lesson 3: For loops"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-write-a-for-loop-that-computes-the-sum-of-all-of-the-squares-from-2-to-11","text":"s = 0 for i in range ( 10 ): s += pow ( i + 2 , 2 ) print ( s )","title":"Exercise: write a for loop that computes the sum of all of the squares from 2 to 11."},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-write-a-for-loop-that-prints-each-item-in-the-list-friends-but-stops-when-it-encounters-the-third-value","text":"friends = [\"Rachel\", \"Monica\", \"Chandler\", \"Ross\", \"Joey\"] friends = [ \"Rachel\" , \"Monica\" , \"Chandler\" , \"Ross\" , \"Joey\" ] for i , friend in enumerate ( friends ): if i == 3 : break else : print ( friend )","title":"Exercise: write a for loop that prints each item in the list friends, but stops when it encounters the third value"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-explain-in-a-few-words-what-happens-when-you-call-zip-on-two-iterables-that-have-different-lengths","text":"zip will stop when it reaches the end of the shorter iterable s1 = 'Jim' s2 = 'Spock' for a , b in zip ( s1 , s2 ): print ( a , b )","title":"Exercise: Explain in a few words what happens when you call zip on two iterables that have different lengths"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-bonus-write-a-python-program-to-construct-the-following-pattern-using-a-nested-for-loop","text":"* * * * * * * * * * * * * * * * * * * * * * * * * Hint: by default the print function inserts a newline character at the end of every line it prints. To suppress this, set the end argument to \"\", like print(\"something\", end=\"\") Hint: you can iterate through a range of numbers in reverse order by passing a negative number as a third argument to range , e.g. range(0,10,-1) n = 5 for i in range ( n ): # rows for j in range ( i ): # columns print ( '* ' , end = \"\" ) print ( '' ) for i in range ( n , 0 , - 1 ): for j in range ( i ): print ( '* ' , end = \"\" ) print ( '' )","title":"Exercise (bonus): Write a Python program to construct the following pattern, using a nested for loop."},{"location":"primer/01_basic_python/Exercises/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Python Primer Exercises (with Solutions) \u00b6 Lesson 1 - Variables, Expressions, and Functions \u00b6 Exercise: Types \u00b6 Consider the following code: var1 = 1 var2 = 1. var3 = \"one\" var4 = \"3.14159\" What is the type of var1 ? What is the type of var2 ? What is the type of var3 ? What is the type of var4 ? Exercise: Find the type \u00b6 Determine the type of the variable mystery using a built-in function mystery = { \"a\" : 1 , \"b\" : 2 } Exercise: Converting types \u00b6 Given this: var2 = 1. var4 = \"1.0\" Explain in simple terms what float(var4) does. Explain in simple terms what str(var2) does. Exercise: Imports \u00b6 Fill in the blanks so that the two programs below run without errors. import __ print ( \"The current directory is {} \" . format ( os . getcwd ())) import ____ print ( \"The square root of 2 is {} \" . format ( math . sqrt ( 2 ))) Lesson 2: Lists and Strings \u00b6 Exercise: Slicing \u00b6 What does the following print: material = 'carbon' print ( 'material[1:3] is:' , material [ 1 : 3 ]) In words, explain what does material[low:high] do? (where low and high are arbitrary numbers) In words, explain what does material[low:] do? (where low is an arbitrary number) In words, explain what does material[:high] do? (where low is an arbitrary number) What does material[:] do? What about material[::2] ? material[::-1] ? Exercise: Fill in the blanks \u00b6 Fill in the blanks so that the program below produces the output shown. values = ____ values . ____ ( 1 ) values . ____ ( 3 ) values . ____ ( 5 ) print ( 'first time:' , values ) values = values [ ____ ] print ( 'second time:' , values ) \u00b6 first time: [1, 3, 5] second time: [3, 5] Exercise: From strings to lists and back \u00b6 Given this: print ( 'string to list:' , list ( 'tin' )) print ( 'list to string:' , '-' . join ([ 'g' , 'o' , 'l' , 'd' ])) \u00b6 ['t', 'i', 'n'] 'g-o-l-d' Explain in simple terms what list('some string') does. 2. What does ' <=> '.join(['x', 'y']) generate? Exercise: Sort and Sorted \u00b6 What do these two programs print? In simple terms, explain the difference between sorted(letters) and letters.sort() . ## Program A letters = list ( 'gold' ) result = sorted ( letters ) print ( 'letters is' , letters , 'and result is' , result ) \u00b6 ## Program B letters = list ( 'gold' ) result = letters . sort () print ( 'letters is' , letters , 'and result is' , result ) Exercise: Copying (or Not) \u00b6 What do these two programs print? In simple terms, explain the difference between new = old and new = old[:] . ## Program A old = list ( 'gold' ) new = old # simple assignment new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) \u00b6 ## Program B old = list ( 'gold' ) new = old [:] # assigning a slice new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) Lesson 3: For loops \u00b6 Exercise: write a for loop that computes the sum of all of the squares from 2 to 11. \u00b6 Exercise: write a for loop that prints each item in the list friends , but stops when it encounters the third value \u00b6 friends = [\"Rachel\", \"Monica\", \"Chandler\", \"Ross\", \"Joey\"] Exercise: Explain in a few words what happens when you call zip on two iterables that have different lengths \u00b6 Exercise (bonus): Write a Python program to construct the following pattern, using a nested for loop. \u00b6 * * * * * * * * * * * * * * * * * * * * * * * * * Hint: by default the print function inserts a newline character at the end of every line it prints. To suppress this, set the end argument to \"\", like print(\"something\", end=\"\") Hint: you can iterate through a range of numbers in reverse order by passing a negative number as a third argument to range , e.g. range(0,10,-1)","title":"Exercises"},{"location":"primer/01_basic_python/Exercises/#python-primer-exercises-with-solutions","text":"","title":"Python Primer Exercises (with Solutions)"},{"location":"primer/01_basic_python/Exercises/#lesson-1-variables-expressions-and-functions","text":"","title":"Lesson 1 - Variables, Expressions, and Functions"},{"location":"primer/01_basic_python/Exercises/#exercise-types","text":"Consider the following code: var1 = 1 var2 = 1. var3 = \"one\" var4 = \"3.14159\" What is the type of var1 ? What is the type of var2 ? What is the type of var3 ? What is the type of var4 ?","title":"Exercise: Types"},{"location":"primer/01_basic_python/Exercises/#exercise-find-the-type","text":"Determine the type of the variable mystery using a built-in function mystery = { \"a\" : 1 , \"b\" : 2 }","title":"Exercise: Find the type"},{"location":"primer/01_basic_python/Exercises/#exercise-converting-types","text":"Given this: var2 = 1. var4 = \"1.0\" Explain in simple terms what float(var4) does. Explain in simple terms what str(var2) does.","title":"Exercise: Converting types"},{"location":"primer/01_basic_python/Exercises/#exercise-imports","text":"Fill in the blanks so that the two programs below run without errors. import __ print ( \"The current directory is {} \" . format ( os . getcwd ())) import ____ print ( \"The square root of 2 is {} \" . format ( math . sqrt ( 2 )))","title":"Exercise: Imports"},{"location":"primer/01_basic_python/Exercises/#lesson-2-lists-and-strings","text":"","title":"Lesson 2: Lists and Strings"},{"location":"primer/01_basic_python/Exercises/#exercise-slicing","text":"What does the following print: material = 'carbon' print ( 'material[1:3] is:' , material [ 1 : 3 ]) In words, explain what does material[low:high] do? (where low and high are arbitrary numbers) In words, explain what does material[low:] do? (where low is an arbitrary number) In words, explain what does material[:high] do? (where low is an arbitrary number) What does material[:] do? What about material[::2] ? material[::-1] ?","title":"Exercise: Slicing"},{"location":"primer/01_basic_python/Exercises/#exercise-fill-in-the-blanks","text":"Fill in the blanks so that the program below produces the output shown.","title":"Exercise: Fill in the blanks"},{"location":"primer/01_basic_python/Exercises/#values-____-values____1-values____3-values____5-printfirst-time-values-values-values____-printsecond-time-values","text":"first time: [1, 3, 5] second time: [3, 5]","title":"values = ____\nvalues.____(1)\nvalues.____(3)\nvalues.____(5)\nprint(&#39;first time:&#39;, values)\nvalues = values[____]\nprint(&#39;second time:&#39;, values)\n"},{"location":"primer/01_basic_python/Exercises/#exercise-from-strings-to-lists-and-back","text":"Given this:","title":"Exercise: From strings to lists and back"},{"location":"primer/01_basic_python/Exercises/#printstring-to-list-listtin-printlist-to-string-joing-o-l-d","text":"['t', 'i', 'n'] 'g-o-l-d' Explain in simple terms what list('some string') does. 2. What does ' <=> '.join(['x', 'y']) generate?","title":"print(&#39;string to list:&#39;, list(&#39;tin&#39;))\nprint(&#39;list to string:&#39;, &#39;-&#39;.join([&#39;g&#39;, &#39;o&#39;, &#39;l&#39;, &#39;d&#39;]))\n"},{"location":"primer/01_basic_python/Exercises/#exercise-sort-and-sorted","text":"What do these two programs print? In simple terms, explain the difference between sorted(letters) and letters.sort() .","title":"Exercise: Sort and Sorted"},{"location":"primer/01_basic_python/Exercises/#program-a-letters-listgold-result-sortedletters-printletters-is-letters-and-result-is-result","text":"## Program B letters = list ( 'gold' ) result = letters . sort () print ( 'letters is' , letters , 'and result is' , result )","title":"## Program A\nletters = list(&#39;gold&#39;)\nresult = sorted(letters)\nprint(&#39;letters is&#39;, letters, &#39;and result is&#39;, result)\n"},{"location":"primer/01_basic_python/Exercises/#exercise-copying-or-not","text":"What do these two programs print? In simple terms, explain the difference between new = old and new = old[:] .","title":"Exercise: Copying (or Not)"},{"location":"primer/01_basic_python/Exercises/#program-a-old-listgold-new-old-simple-assignment-new0-d-printnew-is-new-and-old-is-old","text":"## Program B old = list ( 'gold' ) new = old [:] # assigning a slice new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old )","title":"## Program A\nold = list(&#39;gold&#39;)\nnew = old      # simple assignment\nnew[0] = &#39;D&#39;\nprint(&#39;new is&#39;, new, &#39;and old is&#39;, old)\n"},{"location":"primer/01_basic_python/Exercises/#lesson-3-for-loops","text":"","title":"Lesson 3: For loops"},{"location":"primer/01_basic_python/Exercises/#exercise-write-a-for-loop-that-computes-the-sum-of-all-of-the-squares-from-2-to-11","text":"","title":"Exercise: write a for loop that computes the sum of all of the squares from 2 to 11."},{"location":"primer/01_basic_python/Exercises/#exercise-write-a-for-loop-that-prints-each-item-in-the-list-friends-but-stops-when-it-encounters-the-third-value","text":"friends = [\"Rachel\", \"Monica\", \"Chandler\", \"Ross\", \"Joey\"]","title":"Exercise: write a for loop that prints each item in the list friends, but stops when it encounters the third value"},{"location":"primer/01_basic_python/Exercises/#exercise-explain-in-a-few-words-what-happens-when-you-call-zip-on-two-iterables-that-have-different-lengths","text":"","title":"Exercise: Explain in a few words what happens when you call zip on two iterables that have different lengths"},{"location":"primer/01_basic_python/Exercises/#exercise-bonus-write-a-python-program-to-construct-the-following-pattern-using-a-nested-for-loop","text":"* * * * * * * * * * * * * * * * * * * * * * * * * Hint: by default the print function inserts a newline character at the end of every line it prints. To suppress this, set the end argument to \"\", like print(\"something\", end=\"\") Hint: you can iterate through a range of numbers in reverse order by passing a negative number as a third argument to range , e.g. range(0,10,-1)","title":"Exercise (bonus): Write a Python program to construct the following pattern, using a nested for loop."},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Building Basic Logic in Python \u00b6 Lesson 5: Conditionals \u00b6 In our work, we often want to our programs to be make decisions based on what's going on at the time. Like most other programming languages, python supports conditional statements . The way in which we make decisions in our code based on conditions is through the if statement. Booleans \u00b6 The boolean, or bool , datatype in Python is useful for logic expressions, and can either be True or False . print ( 3 == 2 ) False mybool = 3 > 2 print ( \"My boolean type = \" , type ( mybool )) print ( \"My boolean value = \" , mybool ) My boolean type = <class 'bool'> My boolean value = True The if Statement \u00b6 Let's start with an illustrative example of the state of matter of water (H 2 O) based on the temperature: water_temperature = - 1 # degrees celsius Below is the simple if statement: \"if the temperature of the water is greater than 100 \u00b0C, it must be boiling\" if water_temperature > 100 : print ( 'Boiling!' ) Now, let's add an else catch to our if statement: \"if ... greater than ..., __otherwise__, the water is not boiling\" if water_temperature > 100 : print ( 'Boiling!' ) else : print ( 'Not boiling!' ) Not boiling! We can increase the number of levels of if statement in the following manner: if (condition #1): execute code for case #1 ... . . . elif (condition #k): execute code for case #k ... . . . elif (condition #n): execute code for case #n ... else: execute \"catch all\" case ... In principle, there is no limit to the number of intermediate elif or \"else, if\" checks. water_temperature = - 5 if water_temperature > 100 : print ( 'Boiling!' ) elif water_temperature > 0 : print ( 'Liquid!' ) else : print ( 'Solid!' ) Solid! Note that conditions are demarcated using indentation . This is a contentious property of Python, but is implemented primarily because it makes code much easier to read. Note also that the indentation level can be almost any combination of whitespace characters (tabs and spaces), but elements of the same indentation block must use the same type of indentation. Because it gets confusing to use multiple types, the python style guide strongly recommends using 4 spaces to indent, which is the default in the jupyter notebook for example. This is sometimes more difficult to toggle in text editors, but most of them have online resources for setting up your text editor to use tabs and indentation in a way that conforms to python's style. What is truth? \u00b6 We can typecast another datatype as bool using bool() (we can do this for other fundamental datatypes such as int and float ). The results of some of these casting examples are quite interesting! bool ( 5 ) True bool ( \"beauty\" ) True bool ( \"\" ) False bool ([]) False bool ({}) False bool ( 0 ) False bool ( None ) False Be very careful with this! Python's \"falsy\" functionality makes code fun to write and easier to read, but can cause problems. For example, many people will put a simple if statement as a conditional on whether the variable is stored as a falsy value (e. g. None). Part of the reason we're mentioning this today is that this is often the case in codes that use a lot of serialization like pymatgen. temperature = 0 # store the temperature as a number if you want it to do something if temperature : print ( \"Temperature is\" , temperature ) Lesson 6: Sets and Dictionaries \u00b6 Use a set to store unique values \u00b6 Possible to initialize a set with {...} But must use set() to create an empty set primes = { 2 , 3 , 5 , 7 } print ( 'is 3 prime?' , 3 in primes ) print ( 'is 9 prime?' , 9 in primes ) is 3 prime? True is 9 prime? False * Intersection, union, etc. odds = { 3 , 5 , 7 , 9 } print ( 'intersection' , odds & primes ) print ( 'union' , odds | primes ) intersection {3, 5, 7} union {2, 3, 5, 7, 9} Sets are mutable \u00b6 But only store unique values primes . add ( 11 ) print ( 'primes becomes' , primes ) primes . discard ( 7 ) print ( 'after removal' , primes ) primes . add ( 11 ) print ( 'after adding 11 again' , primes ) primes becomes {2, 3, 5, 7, 11} after removal {2, 3, 5, 11} after adding 11 again {2, 3, 5, 11} Sets are unordered \u00b6 Values are stored by hashing , which is intentionally as random as possible names = { 'Hopper' , 'Cori' , 'Kohn' } for n in names : print ( n ) Kohn Cori Hopper Use a dictionary to store key/value pairs \u00b6 Equivalently, store extra information with elements of a set. birthdays = { 'Hopper' : 1906 , 'Cori' : 1896 } print ( birthdays [ 'Hopper' ]) birthdays [ 'Kohn' ] = 1823 # oops birthdays [ 'Kohn' ] = 1923 # that's better print ( birthdays ) 1906 {'Hopper': 1906, 'Cori': 1896, 'Kohn': 1923} * Just an accident that keys are in order of when entered. * Like sets, dictionaries store keys by hashing, which is as random as possible Set values and dictionary keys must be immutable \u00b6 Changing them after insertion would leave data in the wrong place Use a tuple for multi-valued keys people = {( 'Grace' , 'Hopper' ): 1906 , ( 'Gerty' , 'Cory' ): 1896 , ( 'Walter' , 'Kohn' ): 1923 } You can destructure a tuple in the heading of a for loop: for ( first , last ) in people : print ( first , 'was born in' , people [( first , last )]) Grace was born in 1906 Gerty was born in 1896 Walter was born in 1923 Lesson 7: Writing Functions \u00b6 Break down programs into functions \u00b6 Readability: human beings can only keep a few items in working memory at a time. Encapsulate complexity so that we can treat it as a single \u201cthing\u201d. Reuse: write one time, use many times. Testing: components with well-defined boundaries are easier to test. Define a function using def with a name, parameters, and a block of code \u00b6 Function name must obey the same rules as variable names Put parameters in parentheses Then a colon, then an indented code block # Empty parentheses if the function doesn't take any inputs: def print_greeting (): print ( 'Hello!' ) Arguments in call are matched to parameters in definition \u00b6 def print_date ( year , month , day ): joined = str ( year ) + '/' + str ( month ) + '/' + str ( day ) print ( joined ) print_date ( 1871 , 3 , 19 ) 1871/3/19 Functions may return a result to their caller using return \u00b6 May occur anywhere in the function But functions are easier to understand if return occurs At the start, to handle special cases At the very end, with a final result Functions without explicit return produce None def average ( values ): if len ( values ) == 0 : return None return sum ( values ) / len ( values ) a = average ([ 1 , 3 , 4 ]) print ( 'average of actual values:' , a ) average of actual values: 2.6666666666666665 print ( 'average of empty list:' , average ([])) average of empty list: None result = print_date ( 1871 , 3 , 19 ) print ( 'result of call is:' , result ) 1871/3/19 result of call is: None Can specify default values for parameters \u00b6 All paramters with defaults must come after all parameters without. Otherwise, argument-to-parameter matching would be ambigious. Makes common cases simpler, and signals intent def my_sum ( values , scale = 1.0 ): result = 0.0 for v in values : result += v * scale return result print ( 'my_sum with default:' , my_sum ([ 1 , 2 , 3 ])) print ( 'sum with factor:' , my_sum ([ 1 , 2 , 3 ], 0.5 )) my_sum with default: 6.0 sum with factor: 3.0 # Succinctly... def my_sum ( values , scale = 1.0 ): return sum ( v * scale for v in values ) Can pass parameters by name \u00b6 Helpful when functions have lots of options If you have a procedure with ten parameters, you probably missed some. -- from \"Epigrams in Programming\", by Alan J. Perlis print ( 'out of order:' , my_sum ( scale = 0.25 , values = [ 1 , 2 , 3 ])) out of order: 1.5 Functions can take a variable number of arguments \u00b6 Prefix at most one parameter's name with * . By convention, everyone calls the parameters *args . All \"extra\" paramters are put in a list-like structure assigned to that parameter def total ( scale , * args ): return sum ( a * scale for a in args ) print ( 'with one value:' , total ( 0.5 , 1 )) print ( 'with two values:' , total ( 0.5 , 1 , 3 )) with one value: 0.5 with two values: 2.0 Functions can return multiple values \u00b6 This is just a special case of many-to-many assignment red , green , blue = 10 , 50 , 180 def order ( a , b ): if a < b : return a , b else : return b , a low , high = order ( 10 , 5 ) print ( 'order(10, 5):' , low , high ) order(10, 5): 5 10","title":"Advanced Python"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#building-basic-logic-in-python","text":"","title":"Building Basic Logic in Python"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#lesson-5-conditionals","text":"In our work, we often want to our programs to be make decisions based on what's going on at the time. Like most other programming languages, python supports conditional statements . The way in which we make decisions in our code based on conditions is through the if statement.","title":"Lesson 5: Conditionals"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#booleans","text":"The boolean, or bool , datatype in Python is useful for logic expressions, and can either be True or False . print ( 3 == 2 ) False mybool = 3 > 2 print ( \"My boolean type = \" , type ( mybool )) print ( \"My boolean value = \" , mybool ) My boolean type = <class 'bool'> My boolean value = True","title":"Booleans"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#the-if-statement","text":"Let's start with an illustrative example of the state of matter of water (H 2 O) based on the temperature: water_temperature = - 1 # degrees celsius Below is the simple if statement: \"if the temperature of the water is greater than 100 \u00b0C, it must be boiling\" if water_temperature > 100 : print ( 'Boiling!' ) Now, let's add an else catch to our if statement: \"if ... greater than ..., __otherwise__, the water is not boiling\" if water_temperature > 100 : print ( 'Boiling!' ) else : print ( 'Not boiling!' ) Not boiling! We can increase the number of levels of if statement in the following manner: if (condition #1): execute code for case #1 ... . . . elif (condition #k): execute code for case #k ... . . . elif (condition #n): execute code for case #n ... else: execute \"catch all\" case ... In principle, there is no limit to the number of intermediate elif or \"else, if\" checks. water_temperature = - 5 if water_temperature > 100 : print ( 'Boiling!' ) elif water_temperature > 0 : print ( 'Liquid!' ) else : print ( 'Solid!' ) Solid! Note that conditions are demarcated using indentation . This is a contentious property of Python, but is implemented primarily because it makes code much easier to read. Note also that the indentation level can be almost any combination of whitespace characters (tabs and spaces), but elements of the same indentation block must use the same type of indentation. Because it gets confusing to use multiple types, the python style guide strongly recommends using 4 spaces to indent, which is the default in the jupyter notebook for example. This is sometimes more difficult to toggle in text editors, but most of them have online resources for setting up your text editor to use tabs and indentation in a way that conforms to python's style.","title":"The if Statement"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#what-is-truth","text":"We can typecast another datatype as bool using bool() (we can do this for other fundamental datatypes such as int and float ). The results of some of these casting examples are quite interesting! bool ( 5 ) True bool ( \"beauty\" ) True bool ( \"\" ) False bool ([]) False bool ({}) False bool ( 0 ) False bool ( None ) False Be very careful with this! Python's \"falsy\" functionality makes code fun to write and easier to read, but can cause problems. For example, many people will put a simple if statement as a conditional on whether the variable is stored as a falsy value (e. g. None). Part of the reason we're mentioning this today is that this is often the case in codes that use a lot of serialization like pymatgen. temperature = 0 # store the temperature as a number if you want it to do something if temperature : print ( \"Temperature is\" , temperature )","title":"What is truth?"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#lesson-6-sets-and-dictionaries","text":"","title":"Lesson 6: Sets and Dictionaries"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#use-a-set-to-store-unique-values","text":"Possible to initialize a set with {...} But must use set() to create an empty set primes = { 2 , 3 , 5 , 7 } print ( 'is 3 prime?' , 3 in primes ) print ( 'is 9 prime?' , 9 in primes ) is 3 prime? True is 9 prime? False * Intersection, union, etc. odds = { 3 , 5 , 7 , 9 } print ( 'intersection' , odds & primes ) print ( 'union' , odds | primes ) intersection {3, 5, 7} union {2, 3, 5, 7, 9}","title":"Use a set to store unique values"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#sets-are-mutable","text":"But only store unique values primes . add ( 11 ) print ( 'primes becomes' , primes ) primes . discard ( 7 ) print ( 'after removal' , primes ) primes . add ( 11 ) print ( 'after adding 11 again' , primes ) primes becomes {2, 3, 5, 7, 11} after removal {2, 3, 5, 11} after adding 11 again {2, 3, 5, 11}","title":"Sets are mutable"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#sets-are-unordered","text":"Values are stored by hashing , which is intentionally as random as possible names = { 'Hopper' , 'Cori' , 'Kohn' } for n in names : print ( n ) Kohn Cori Hopper","title":"Sets are unordered"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#use-a-dictionary-to-store-keyvalue-pairs","text":"Equivalently, store extra information with elements of a set. birthdays = { 'Hopper' : 1906 , 'Cori' : 1896 } print ( birthdays [ 'Hopper' ]) birthdays [ 'Kohn' ] = 1823 # oops birthdays [ 'Kohn' ] = 1923 # that's better print ( birthdays ) 1906 {'Hopper': 1906, 'Cori': 1896, 'Kohn': 1923} * Just an accident that keys are in order of when entered. * Like sets, dictionaries store keys by hashing, which is as random as possible","title":"Use a dictionary to store key/value pairs"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#set-values-and-dictionary-keys-must-be-immutable","text":"Changing them after insertion would leave data in the wrong place Use a tuple for multi-valued keys people = {( 'Grace' , 'Hopper' ): 1906 , ( 'Gerty' , 'Cory' ): 1896 , ( 'Walter' , 'Kohn' ): 1923 } You can destructure a tuple in the heading of a for loop: for ( first , last ) in people : print ( first , 'was born in' , people [( first , last )]) Grace was born in 1906 Gerty was born in 1896 Walter was born in 1923","title":"Set values and dictionary keys must be immutable"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#lesson-7-writing-functions","text":"","title":"Lesson 7: Writing Functions"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#break-down-programs-into-functions","text":"Readability: human beings can only keep a few items in working memory at a time. Encapsulate complexity so that we can treat it as a single \u201cthing\u201d. Reuse: write one time, use many times. Testing: components with well-defined boundaries are easier to test.","title":"Break down programs into functions"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#define-a-function-using-def-with-a-name-parameters-and-a-block-of-code","text":"Function name must obey the same rules as variable names Put parameters in parentheses Then a colon, then an indented code block # Empty parentheses if the function doesn't take any inputs: def print_greeting (): print ( 'Hello!' )","title":"Define a function using def with a name, parameters, and a block of code"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#arguments-in-call-are-matched-to-parameters-in-definition","text":"def print_date ( year , month , day ): joined = str ( year ) + '/' + str ( month ) + '/' + str ( day ) print ( joined ) print_date ( 1871 , 3 , 19 ) 1871/3/19","title":"Arguments in call are matched to parameters in definition"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#functions-may-return-a-result-to-their-caller-using-return","text":"May occur anywhere in the function But functions are easier to understand if return occurs At the start, to handle special cases At the very end, with a final result Functions without explicit return produce None def average ( values ): if len ( values ) == 0 : return None return sum ( values ) / len ( values ) a = average ([ 1 , 3 , 4 ]) print ( 'average of actual values:' , a ) average of actual values: 2.6666666666666665 print ( 'average of empty list:' , average ([])) average of empty list: None result = print_date ( 1871 , 3 , 19 ) print ( 'result of call is:' , result ) 1871/3/19 result of call is: None","title":"Functions may return a result to their caller using return"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#can-specify-default-values-for-parameters","text":"All paramters with defaults must come after all parameters without. Otherwise, argument-to-parameter matching would be ambigious. Makes common cases simpler, and signals intent def my_sum ( values , scale = 1.0 ): result = 0.0 for v in values : result += v * scale return result print ( 'my_sum with default:' , my_sum ([ 1 , 2 , 3 ])) print ( 'sum with factor:' , my_sum ([ 1 , 2 , 3 ], 0.5 )) my_sum with default: 6.0 sum with factor: 3.0 # Succinctly... def my_sum ( values , scale = 1.0 ): return sum ( v * scale for v in values )","title":"Can specify default values for parameters"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#can-pass-parameters-by-name","text":"Helpful when functions have lots of options If you have a procedure with ten parameters, you probably missed some. -- from \"Epigrams in Programming\", by Alan J. Perlis print ( 'out of order:' , my_sum ( scale = 0.25 , values = [ 1 , 2 , 3 ])) out of order: 1.5","title":"Can pass parameters by name"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#functions-can-take-a-variable-number-of-arguments","text":"Prefix at most one parameter's name with * . By convention, everyone calls the parameters *args . All \"extra\" paramters are put in a list-like structure assigned to that parameter def total ( scale , * args ): return sum ( a * scale for a in args ) print ( 'with one value:' , total ( 0.5 , 1 )) print ( 'with two values:' , total ( 0.5 , 1 , 3 )) with one value: 0.5 with two values: 2.0","title":"Functions can take a variable number of arguments"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#functions-can-return-multiple-values","text":"This is just a special case of many-to-many assignment red , green , blue = 10 , 50 , 180 def order ( a , b ): if a < b : return a , b else : return b , a low , high = order ( 10 , 5 ) print ( 'order(10, 5):' , low , high ) order(10, 5): 5 10","title":"Functions can return multiple values"},{"location":"primer/02_building_logic/Exercise_Solutions/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Python Primer Part II Exercises (with Solutions) \u00b6 Lesson 5: Conditionals \u00b6 Exercise: \u00b6 Write a Python program to convert temperatures to and from celsius, fahrenheit. Formula : c/5 = f-32/9 (where c = temperature in celsius and f = temperature in fahrenheit ) Expected Output : 60\u00b0C is 140 in Fahrenheit 45\u00b0F is 7 in Celsius # gather input from the user temp = input ( \"Input the temperature you like to convert? (e.g., 45F, 102C etc.) : \" ) # parse the string of input from the user degree = int ( temp [: - 1 ]) i_convention = temp [ - 1 ] if i_convention . upper () == 'F' : result = int ( round (( 9 * degree ) / 5 + 32 )) o_convention = \"Fahrenheit\" elif i_convention . upper () == 'C' : result = int ( round (( degree - 32 ) * 5 / 9 )) o_convention = \"Celsius\" else : print ( \"Input proper convention.\" ) quit () print ( \"The temperature in\" , o_convention , \"is\" , result , \"degrees.\" ) Input the temperature you like to convert? (e.g., 45F, 102C etc.) : 100C The temperature in Celsius is 38 degrees. Exercise: \u00b6 Who discovered your favorite elements? Let's write a simple test to see which elements were discovered by discoverer A, discoverer B, and both! import os from monty.serialization import loadfn data_dir = \"./data/\" # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) from pymatgen.core import Element # The discoverers we want to explore... discover0 = \"Berkeley\" #discover0 = \"Ghiorso\" discover1 = \"Russia\" # Loop through discoverers to find which elements they discovered for element_name in discovery_dict : names = discovery_dict [ element_name ][ 'discovered_by' ] A , B = False , False for name in names : if discover0 in name : A = True if discover1 in name : B = True if A and B : print ( \"For \" , element_name , \", A and B is true!\" ) elif A : print ( \"For \" , element_name , \", A is true!\" ) elif B : print ( \"For \" , element_name , \", B is true!\" ) For Bohrium , B is true! For Dubnium , A and B is true! For Flerovium , B is true! For Livermorium , B is true! For Rutherfordium , B is true! Lesson 6: Sets and Dictionaries \u00b6 Exercise: create a histogram \u00b6 numbers = [ 1 , 0 , 1 , 2 , 0 , 0 , 1 , 2 , 1 , 3 , 1 , 0 , 2 ] count = {} for n in numbers : if n not in count : count [ n ] = 1 else : count [ n ] = count [ n ] + 1 print ( count ) {1: 5, 0: 4, 2: 3, 3: 1} Reminder: there are lots of useful Python libraries, especially the \"standard library\" that comes with Python: from collections import Counter print ( Counter ( numbers )) print ( dict ( Counter ( numbers ))) Counter({1: 5, 0: 4, 2: 3, 3: 1}) {1: 5, 0: 4, 2: 3, 3: 1} Exercise: How heavy is this molecule? \u00b6 You are given two things: a dictionary mapping atomic symbols to atomic weights ( mp_workshop.data.atomic_weights ), and a list of (atomic_symbol, count) pairs for a molecule. # Example molecules: methane = [( 'C' , 1 ), ( 'H' , 4 )] aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] Print that molecule's molecular weight. import os from monty.serialization import loadfn data_dir = \"./data/\" atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # atomic weight is 16.0423 methane = [( 'C' , 1 ), ( 'H' , 4 )] # atomic weight is 100.1421 aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] # 2. Pick a molecule to test molecule = methane # 3. Do stuff to calculate `mol_weight` mol_weight = 0.0 for specie , number in methane : mol_weight += number * atomic_weights [ specie ] print ( mol_weight ) 16.04246 Lesson 7: Writing Functions \u00b6 Exercise: Find the first \u00b6 Fill in the blanks to create a function that takes a list of numbers as an argument and returns the first negative value in the list. What does your function do if the list is empty? def first_negative ( values ): for v in values : if v < 0 : return v Exercise : Running sum \u00b6 Write a function that calculates the running sum of any number of input arguments, returning the result as a list. For example: running(1, 2) => [1, 3] running(-5, 2, 7) => [-5, -3, 4] What should running() return, and why? Exercise: How's your phase-change memory? \u00b6 A chalcogenide is a chemical compound consisting of at least one chalcogen anion (commonly restricted to \u2018S\u2019, \u2018Se\u2019, or \u2018Te\u2019) and at least one more electropositive element. Generalize the halide function below as compound_class , a function that takes a crystal and function as parameters and returns whether or not the compound is of that class. # %load code/phase_change_memory.py import random from pymatgen import Element import os from monty.serialization import loadfn data_dir = \"./data/\" crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) def halogen ( element ): return element . is_halogen def halide ( crystal ): elts = [ Element ( s ) for s in crystal [ 'elements' ]] anion = sorted ( elts )[ - 1 ] # sorts by electronegativity return halogen ( anion ) def chalcogen ( element ): return element . is_chalogen def compound_class ( crystal , predicate ): elts = [ Element ( s ) for s in crystal [ 'elements' ]] anion = sorted ( elts )[ - 1 ] # sorts by electronegativity return predicate ( anion ) my_crystal = random . sample ( [ c for c in crystals if halide ( c )], 1 )[ 0 ] print ( compound_class ( my_crystal , halogen ) == halide ( my_crystal )) True Lesson 8: Test your Skills \u00b6 Now it's time to put your skills to the test! \u00b6 Exercise: As a materials investigator, your team has just finished running calculations for a large number of crystal structures. Now, you want to analyze the dataset by writing functions that utilize logic (in the form of conditionals ) to parse through the datasets in the forms of dictionaries and lists . First, load the relevant datasets import os from monty.serialization import loadfn data_dir = \"./data/\" # Our crystal structures, in addition to useful elemental information crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) atomic_numbers = loadfn ( os . path . join ( data_dir , \"atomic_numbers.json\" )) atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # Names of elements associated with an element symbol (e.g. {\"Al\": \"Aluminium\"}) element_names = loadfn ( os . path . join ( data_dir , \"element_names.json\" )) # Elemental mass fraction of Earth's crust (source: https://en.wikipedia.org/wiki/Abundances_of_the_elements_(data_page)) mass_frac_earth_crust = loadfn ( os . path . join ( data_dir , \"mass_frac_earth_crust.json\" )) # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) We have the mapping from symbol \\rightarrow \\rightarrow name , now let's obtain name \\rightarrow \\rightarrow symbol (we'll need it later) print ( element_names [ \"Ag\" ]) element_symbols = { v : k for k , v in element_names . items ()} print ( element_symbols [ \"Silver\" ]) Silver Ag Next, we'll choose the set of elements that we would like to start with. Each element has a unique story associated with it. We can explore these stories with the information from the element discovery timeline. Our task: Build a function that takes a list of element symbols as input. In addition, if we want to add the elements associated with a particular materials discoverer, we can include some regex (or \"regular expression\") strings corresponding to the discoverers we would like to feature. from pymatgen.core import Element , Composition def my_element_discoverer ( elements : list = [], discoverers : list = [], prior_to : int = 2020 ): # Start with elements provided by user # (use copy() to not modify list passed to function) all_elements = elements . copy () # Loop through discoverers to find which elements they discovered # and then add them to your list for discoverer in discoverers : for element_name in discovery_dict : for name in discovery_dict [ element_name ][ 'discovered_by' ]: if discoverer in name : elem = Element ( element_symbols [ element_name ]) all_elements . append ( elem ) # Create a new list that will contain only the elements discovered # before the year you provide elements_pruned = [] for elem in all_elements : element_name = element_names [ str ( elem )] if discovery_dict [ element_name ][ 'year' ] != '?' : year_discovered = int ( discovery_dict [ element_name ][ 'year' ]) else : # Unknown discovery date (known since ancient times) year_discovered = - 2000 if year_discovered < prior_to : elem = Element ( elem ) elements_pruned . append ( elem ) all_elements = elements_pruned # Use set() to convert your list into a unique set # then recast as a list() all_elements = list ( set ( all_elements )) return all_elements Let's test out our function! Say we want to use oxygen in addition to elements discovered by scientists with Curie in their name (Marie and Pierre), as well as elements discovered by scientists in Berkeley my_elements = my_element_discoverer ( elements = [ \"O\" ], discoverers = [ \"Curie\" , \"Lawrence Berkeley\" ], prior_to = 2020 ) print ( my_elements ) [Element O, Element Db, Element Ra, Element Po] Can you spot which elements are missing? (Hint below) # Discovered by scientists at UC Berkeley my_elements = my_element_discoverer ( discoverers = [ \"Ghiorso\" ], prior_to = 2020 ) print ( my_elements ) [Element Cm, Element Bk, Element Cf, Element Es, Element Fm, Element Md, Element No, Element Lr, Element Rf, Element Sg, Element Am] Platinum was found in gold alloys in present day Columbia dating as far back as 800 BC my_elements = my_element_discoverer ( elements = [ \"Ni\" ], discoverers = [ \"Indigenous People of South America\" ], prior_to = 1800 ) print ( my_elements ) [Element Ni, Element Pt] Next, our goal is to find all of the crystals that contain the elements in our list. Once we obtain this list, it is often useful to sort these materials based on a particular metric, depending on which properties that we would like to assess. The two criteria we will use in this study are the molar mass and abundance: Molar mass = \\sum_{i=1}^N x_i n_i \\sum_{i=1}^N x_i n_i , where n_i n_i is the elemental molar mass, and x_i x_i is the molar fraction Abundance metric = \\prod_{i=1}^N a_i^{y_i} \\prod_{i=1}^N a_i^{y_i} , where a_i a_i is the mass abundance of the element i i , and y_i y_i is the mass fraction in the material import numpy as np def compute_molar_weight ( crystal ): # Obtain atomic fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) atomic_fractions = [ comp . get_atomic_fraction ( Element ( elem )) for elem in crystal [ 'elements' ]] # Obtain atomic weights of elements in material weights = [ atomic_weights [ elem ] for elem in crystal [ 'elements' ]] # Compute molar weight of material (weighted mean) molar_weight = 0.0 for elem , frac , weight in zip ( crystal [ \"elements\" ], atomic_fractions , weights ): molar_weight += frac * weight return molar_weight def compute_abundance_metric ( crystal ): # Obtain mass fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) molar_weight = compute_molar_weight ( crystal ) mass_fractions = [ comp . get_atomic_fraction ( Element ( elem )) * ( atomic_weights [ elem ] / molar_weight ) for elem in crystal [ 'elements' ]] # Obtain atomic abundances of elements in material abundances = [ mass_frac_earth_crust [ elem ] for elem in crystal [ 'elements' ]] # Compute abundance metric (geometric mean) abundance_metric = 1.0 for elem , frac , abundance in zip ( crystal [ \"elements\" ], mass_fractions , abundances ): abundance_metric *= ( 100 * abundance ) ** frac return abundance_metric crystal = crystals [ 0 ] print ( \"Material:\" , crystal [ \"pretty_formula\" ]) print ( \"Molar weight (g / mol / # atoms per formula unit) = \" , compute_molar_weight ( crystal )) print ( \"Abundance metric (% kg/kg) = \" , compute_abundance_metric ( crystal )) Material: Ca3Ge3(MoO6)2 Molar weight (g / mol / # atoms per formula unit) = 36.10134 Abundance metric (% kg/kg) = 0.022347289066530374 Now that we have our sorting metrics, let's find the materials in our dataset that contain the elements we have provided, and sort them based on the criteria above. A helpful relation: For finite sets A A and B B , B \\subseteq A B \\subseteq A if and only if B = A \\cap B B = A \\cap B def get_crystals_from_elements ( elements : list , crystals : list , sort_scheme : int = 0 ): crystals_matched = [] for crystal in crystals : crystal_elems = [ Element ( elem ) for elem in crystal [ 'elements' ]] # We can check if the material contains the elements that we have provided # (set B in A) by checking if B = intersection(A,B) intersection = set ( elements ) & set ( crystal_elems ) if set ( elements ) == intersection : crystals_matched . append ( crystal ) if sort_scheme == 0 : # Sort by molar weight sort_key = \"Molar weight (g / mol / # atoms per formula unit)\" sortable_values = [ compute_molar_weight ( crystal ) for crystal in crystals_matched ] elif sort_scheme == 1 : # Sort by abundance metric sort_key = \"Abundance metric (% kg/kg)\" sortable_values = [ compute_abundance_metric ( crystal ) for crystal in crystals_matched ] else : # Catch all case - no sorting provided sortable_values = [] print ( \"Warning: Invalid sort scheme!\" ) return [], [], \"\" if sortable_values : #print(sortable_values) # Sort crystals based on sorting metric (reverse to descending order) value_map = [{ \"value\" : v , \"crystal\" : c } for v , c in zip ( sortable_values , crystals_matched )] value_map = sorted ( value_map , key = lambda x : x [ \"value\" ], reverse = True ) #sortable_values, crystals_matched = zip(*sorted(zip(sortable_values, crystals_matched), reverse=True)) # Extract desired values after sorting sortable_values = [ x [ 'value' ] for x in value_map ] crystals_matched = [ x [ 'crystal' ] for x in value_map ] #print(sortable_values) return crystals_matched , sortable_values , sort_key We've built our functions! Now let's test them to search the materials in our dataset # The elements we would like to search our dataset elements = [ Element ( elem ) for elem in [ 'Ca' , 'O' ]] # Testing our function crystals_matched , sorted_values , sort_key = get_crystals_from_elements ( elements , crystals , sort_scheme = 0 ) # The formulas of the crystals that we searched for formulas = [ crystal [ 'pretty_formula' ] for crystal in crystals_matched ] print ( \"Number of crystals found: \" , len ( crystals_matched )) # print(formulas) Number of crystals found: 445 For a large number of materials, we often gain the most information by perfoming an analysis of how the sorting criteria is distributed. In this case, we can create a histogram of the data using the matplotlib package. import matplotlib.pyplot as plt number_of_bins = 20 plt . hist ( sorted_values , number_of_bins ) plt . ylabel ( 'Counts' ) plt . xlabel ( sort_key ) plt . show ()","title":"Exercise Solutions"},{"location":"primer/02_building_logic/Exercise_Solutions/#python-primer-part-ii-exercises-with-solutions","text":"","title":"Python Primer Part II Exercises (with Solutions)"},{"location":"primer/02_building_logic/Exercise_Solutions/#lesson-5-conditionals","text":"","title":"Lesson 5: Conditionals"},{"location":"primer/02_building_logic/Exercise_Solutions/#exercise","text":"Write a Python program to convert temperatures to and from celsius, fahrenheit. Formula : c/5 = f-32/9 (where c = temperature in celsius and f = temperature in fahrenheit ) Expected Output : 60\u00b0C is 140 in Fahrenheit 45\u00b0F is 7 in Celsius # gather input from the user temp = input ( \"Input the temperature you like to convert? (e.g., 45F, 102C etc.) : \" ) # parse the string of input from the user degree = int ( temp [: - 1 ]) i_convention = temp [ - 1 ] if i_convention . upper () == 'F' : result = int ( round (( 9 * degree ) / 5 + 32 )) o_convention = \"Fahrenheit\" elif i_convention . upper () == 'C' : result = int ( round (( degree - 32 ) * 5 / 9 )) o_convention = \"Celsius\" else : print ( \"Input proper convention.\" ) quit () print ( \"The temperature in\" , o_convention , \"is\" , result , \"degrees.\" ) Input the temperature you like to convert? (e.g., 45F, 102C etc.) : 100C The temperature in Celsius is 38 degrees.","title":"Exercise:"},{"location":"primer/02_building_logic/Exercise_Solutions/#exercise_1","text":"Who discovered your favorite elements? Let's write a simple test to see which elements were discovered by discoverer A, discoverer B, and both! import os from monty.serialization import loadfn data_dir = \"./data/\" # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) from pymatgen.core import Element # The discoverers we want to explore... discover0 = \"Berkeley\" #discover0 = \"Ghiorso\" discover1 = \"Russia\" # Loop through discoverers to find which elements they discovered for element_name in discovery_dict : names = discovery_dict [ element_name ][ 'discovered_by' ] A , B = False , False for name in names : if discover0 in name : A = True if discover1 in name : B = True if A and B : print ( \"For \" , element_name , \", A and B is true!\" ) elif A : print ( \"For \" , element_name , \", A is true!\" ) elif B : print ( \"For \" , element_name , \", B is true!\" ) For Bohrium , B is true! For Dubnium , A and B is true! For Flerovium , B is true! For Livermorium , B is true! For Rutherfordium , B is true!","title":"Exercise:"},{"location":"primer/02_building_logic/Exercise_Solutions/#lesson-6-sets-and-dictionaries","text":"","title":"Lesson 6: Sets and Dictionaries"},{"location":"primer/02_building_logic/Exercise_Solutions/#exercise-create-a-histogram","text":"numbers = [ 1 , 0 , 1 , 2 , 0 , 0 , 1 , 2 , 1 , 3 , 1 , 0 , 2 ] count = {} for n in numbers : if n not in count : count [ n ] = 1 else : count [ n ] = count [ n ] + 1 print ( count ) {1: 5, 0: 4, 2: 3, 3: 1} Reminder: there are lots of useful Python libraries, especially the \"standard library\" that comes with Python: from collections import Counter print ( Counter ( numbers )) print ( dict ( Counter ( numbers ))) Counter({1: 5, 0: 4, 2: 3, 3: 1}) {1: 5, 0: 4, 2: 3, 3: 1}","title":"Exercise: create a histogram"},{"location":"primer/02_building_logic/Exercise_Solutions/#exercise-how-heavy-is-this-molecule","text":"You are given two things: a dictionary mapping atomic symbols to atomic weights ( mp_workshop.data.atomic_weights ), and a list of (atomic_symbol, count) pairs for a molecule. # Example molecules: methane = [( 'C' , 1 ), ( 'H' , 4 )] aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] Print that molecule's molecular weight. import os from monty.serialization import loadfn data_dir = \"./data/\" atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # atomic weight is 16.0423 methane = [( 'C' , 1 ), ( 'H' , 4 )] # atomic weight is 100.1421 aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] # 2. Pick a molecule to test molecule = methane # 3. Do stuff to calculate `mol_weight` mol_weight = 0.0 for specie , number in methane : mol_weight += number * atomic_weights [ specie ] print ( mol_weight ) 16.04246","title":"Exercise: How heavy is this molecule?"},{"location":"primer/02_building_logic/Exercise_Solutions/#lesson-7-writing-functions","text":"","title":"Lesson 7: Writing Functions"},{"location":"primer/02_building_logic/Exercise_Solutions/#exercise-find-the-first","text":"Fill in the blanks to create a function that takes a list of numbers as an argument and returns the first negative value in the list. What does your function do if the list is empty? def first_negative ( values ): for v in values : if v < 0 : return v","title":"Exercise: Find the first"},{"location":"primer/02_building_logic/Exercise_Solutions/#exercise-running-sum","text":"Write a function that calculates the running sum of any number of input arguments, returning the result as a list. For example: running(1, 2) => [1, 3] running(-5, 2, 7) => [-5, -3, 4] What should running() return, and why?","title":"Exercise : Running sum"},{"location":"primer/02_building_logic/Exercise_Solutions/#exercise-hows-your-phase-change-memory","text":"A chalcogenide is a chemical compound consisting of at least one chalcogen anion (commonly restricted to \u2018S\u2019, \u2018Se\u2019, or \u2018Te\u2019) and at least one more electropositive element. Generalize the halide function below as compound_class , a function that takes a crystal and function as parameters and returns whether or not the compound is of that class. # %load code/phase_change_memory.py import random from pymatgen import Element import os from monty.serialization import loadfn data_dir = \"./data/\" crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) def halogen ( element ): return element . is_halogen def halide ( crystal ): elts = [ Element ( s ) for s in crystal [ 'elements' ]] anion = sorted ( elts )[ - 1 ] # sorts by electronegativity return halogen ( anion ) def chalcogen ( element ): return element . is_chalogen def compound_class ( crystal , predicate ): elts = [ Element ( s ) for s in crystal [ 'elements' ]] anion = sorted ( elts )[ - 1 ] # sorts by electronegativity return predicate ( anion ) my_crystal = random . sample ( [ c for c in crystals if halide ( c )], 1 )[ 0 ] print ( compound_class ( my_crystal , halogen ) == halide ( my_crystal )) True","title":"Exercise: How's your phase-change memory?"},{"location":"primer/02_building_logic/Exercise_Solutions/#lesson-8-test-your-skills","text":"","title":"Lesson 8: Test your Skills"},{"location":"primer/02_building_logic/Exercise_Solutions/#now-its-time-to-put-your-skills-to-the-test","text":"Exercise: As a materials investigator, your team has just finished running calculations for a large number of crystal structures. Now, you want to analyze the dataset by writing functions that utilize logic (in the form of conditionals ) to parse through the datasets in the forms of dictionaries and lists . First, load the relevant datasets import os from monty.serialization import loadfn data_dir = \"./data/\" # Our crystal structures, in addition to useful elemental information crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) atomic_numbers = loadfn ( os . path . join ( data_dir , \"atomic_numbers.json\" )) atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # Names of elements associated with an element symbol (e.g. {\"Al\": \"Aluminium\"}) element_names = loadfn ( os . path . join ( data_dir , \"element_names.json\" )) # Elemental mass fraction of Earth's crust (source: https://en.wikipedia.org/wiki/Abundances_of_the_elements_(data_page)) mass_frac_earth_crust = loadfn ( os . path . join ( data_dir , \"mass_frac_earth_crust.json\" )) # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) We have the mapping from symbol \\rightarrow \\rightarrow name , now let's obtain name \\rightarrow \\rightarrow symbol (we'll need it later) print ( element_names [ \"Ag\" ]) element_symbols = { v : k for k , v in element_names . items ()} print ( element_symbols [ \"Silver\" ]) Silver Ag Next, we'll choose the set of elements that we would like to start with. Each element has a unique story associated with it. We can explore these stories with the information from the element discovery timeline. Our task: Build a function that takes a list of element symbols as input. In addition, if we want to add the elements associated with a particular materials discoverer, we can include some regex (or \"regular expression\") strings corresponding to the discoverers we would like to feature. from pymatgen.core import Element , Composition def my_element_discoverer ( elements : list = [], discoverers : list = [], prior_to : int = 2020 ): # Start with elements provided by user # (use copy() to not modify list passed to function) all_elements = elements . copy () # Loop through discoverers to find which elements they discovered # and then add them to your list for discoverer in discoverers : for element_name in discovery_dict : for name in discovery_dict [ element_name ][ 'discovered_by' ]: if discoverer in name : elem = Element ( element_symbols [ element_name ]) all_elements . append ( elem ) # Create a new list that will contain only the elements discovered # before the year you provide elements_pruned = [] for elem in all_elements : element_name = element_names [ str ( elem )] if discovery_dict [ element_name ][ 'year' ] != '?' : year_discovered = int ( discovery_dict [ element_name ][ 'year' ]) else : # Unknown discovery date (known since ancient times) year_discovered = - 2000 if year_discovered < prior_to : elem = Element ( elem ) elements_pruned . append ( elem ) all_elements = elements_pruned # Use set() to convert your list into a unique set # then recast as a list() all_elements = list ( set ( all_elements )) return all_elements Let's test out our function! Say we want to use oxygen in addition to elements discovered by scientists with Curie in their name (Marie and Pierre), as well as elements discovered by scientists in Berkeley my_elements = my_element_discoverer ( elements = [ \"O\" ], discoverers = [ \"Curie\" , \"Lawrence Berkeley\" ], prior_to = 2020 ) print ( my_elements ) [Element O, Element Db, Element Ra, Element Po] Can you spot which elements are missing? (Hint below) # Discovered by scientists at UC Berkeley my_elements = my_element_discoverer ( discoverers = [ \"Ghiorso\" ], prior_to = 2020 ) print ( my_elements ) [Element Cm, Element Bk, Element Cf, Element Es, Element Fm, Element Md, Element No, Element Lr, Element Rf, Element Sg, Element Am] Platinum was found in gold alloys in present day Columbia dating as far back as 800 BC my_elements = my_element_discoverer ( elements = [ \"Ni\" ], discoverers = [ \"Indigenous People of South America\" ], prior_to = 1800 ) print ( my_elements ) [Element Ni, Element Pt] Next, our goal is to find all of the crystals that contain the elements in our list. Once we obtain this list, it is often useful to sort these materials based on a particular metric, depending on which properties that we would like to assess. The two criteria we will use in this study are the molar mass and abundance: Molar mass = \\sum_{i=1}^N x_i n_i \\sum_{i=1}^N x_i n_i , where n_i n_i is the elemental molar mass, and x_i x_i is the molar fraction Abundance metric = \\prod_{i=1}^N a_i^{y_i} \\prod_{i=1}^N a_i^{y_i} , where a_i a_i is the mass abundance of the element i i , and y_i y_i is the mass fraction in the material import numpy as np def compute_molar_weight ( crystal ): # Obtain atomic fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) atomic_fractions = [ comp . get_atomic_fraction ( Element ( elem )) for elem in crystal [ 'elements' ]] # Obtain atomic weights of elements in material weights = [ atomic_weights [ elem ] for elem in crystal [ 'elements' ]] # Compute molar weight of material (weighted mean) molar_weight = 0.0 for elem , frac , weight in zip ( crystal [ \"elements\" ], atomic_fractions , weights ): molar_weight += frac * weight return molar_weight def compute_abundance_metric ( crystal ): # Obtain mass fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) molar_weight = compute_molar_weight ( crystal ) mass_fractions = [ comp . get_atomic_fraction ( Element ( elem )) * ( atomic_weights [ elem ] / molar_weight ) for elem in crystal [ 'elements' ]] # Obtain atomic abundances of elements in material abundances = [ mass_frac_earth_crust [ elem ] for elem in crystal [ 'elements' ]] # Compute abundance metric (geometric mean) abundance_metric = 1.0 for elem , frac , abundance in zip ( crystal [ \"elements\" ], mass_fractions , abundances ): abundance_metric *= ( 100 * abundance ) ** frac return abundance_metric crystal = crystals [ 0 ] print ( \"Material:\" , crystal [ \"pretty_formula\" ]) print ( \"Molar weight (g / mol / # atoms per formula unit) = \" , compute_molar_weight ( crystal )) print ( \"Abundance metric (% kg/kg) = \" , compute_abundance_metric ( crystal )) Material: Ca3Ge3(MoO6)2 Molar weight (g / mol / # atoms per formula unit) = 36.10134 Abundance metric (% kg/kg) = 0.022347289066530374 Now that we have our sorting metrics, let's find the materials in our dataset that contain the elements we have provided, and sort them based on the criteria above. A helpful relation: For finite sets A A and B B , B \\subseteq A B \\subseteq A if and only if B = A \\cap B B = A \\cap B def get_crystals_from_elements ( elements : list , crystals : list , sort_scheme : int = 0 ): crystals_matched = [] for crystal in crystals : crystal_elems = [ Element ( elem ) for elem in crystal [ 'elements' ]] # We can check if the material contains the elements that we have provided # (set B in A) by checking if B = intersection(A,B) intersection = set ( elements ) & set ( crystal_elems ) if set ( elements ) == intersection : crystals_matched . append ( crystal ) if sort_scheme == 0 : # Sort by molar weight sort_key = \"Molar weight (g / mol / # atoms per formula unit)\" sortable_values = [ compute_molar_weight ( crystal ) for crystal in crystals_matched ] elif sort_scheme == 1 : # Sort by abundance metric sort_key = \"Abundance metric (% kg/kg)\" sortable_values = [ compute_abundance_metric ( crystal ) for crystal in crystals_matched ] else : # Catch all case - no sorting provided sortable_values = [] print ( \"Warning: Invalid sort scheme!\" ) return [], [], \"\" if sortable_values : #print(sortable_values) # Sort crystals based on sorting metric (reverse to descending order) value_map = [{ \"value\" : v , \"crystal\" : c } for v , c in zip ( sortable_values , crystals_matched )] value_map = sorted ( value_map , key = lambda x : x [ \"value\" ], reverse = True ) #sortable_values, crystals_matched = zip(*sorted(zip(sortable_values, crystals_matched), reverse=True)) # Extract desired values after sorting sortable_values = [ x [ 'value' ] for x in value_map ] crystals_matched = [ x [ 'crystal' ] for x in value_map ] #print(sortable_values) return crystals_matched , sortable_values , sort_key We've built our functions! Now let's test them to search the materials in our dataset # The elements we would like to search our dataset elements = [ Element ( elem ) for elem in [ 'Ca' , 'O' ]] # Testing our function crystals_matched , sorted_values , sort_key = get_crystals_from_elements ( elements , crystals , sort_scheme = 0 ) # The formulas of the crystals that we searched for formulas = [ crystal [ 'pretty_formula' ] for crystal in crystals_matched ] print ( \"Number of crystals found: \" , len ( crystals_matched )) # print(formulas) Number of crystals found: 445 For a large number of materials, we often gain the most information by perfoming an analysis of how the sorting criteria is distributed. In this case, we can create a histogram of the data using the matplotlib package. import matplotlib.pyplot as plt number_of_bins = 20 plt . hist ( sorted_values , number_of_bins ) plt . ylabel ( 'Counts' ) plt . xlabel ( sort_key ) plt . show ()","title":"Now it's time to put your skills to the test!"},{"location":"primer/02_building_logic/Exercises/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Python Primer Part II Exercises \u00b6 Lesson 5: Conditionals \u00b6 Exercise: \u00b6 Write a Python program to convert temperatures to and from celsius, fahrenheit. Formula : c/5 = f-32/9 (where c = temperature in celsius and f = temperature in fahrenheit ) Expected Output : 60\u00b0C is 140 in Fahrenheit 45\u00b0F is 7 in Celsius # gather input from the user temp = input ( \"Input the temperature you like to convert? (e.g., 45F, 102C etc.) : \" ) # parse the string of input from the user degree = int ( temp [: - 1 ]) i_convention = temp [ - 1 ] if i_convention . upper () == __ : result = int ( round (( 9 * degree ) / 5 + 32 )) o_convention = \"Fahrenheit\" elif i_convention . upper () == __ : result = int ( round (( degree - 32 ) * 5 / 9 )) o_convention = \"Celsius\" else : print ( \"Input proper convention.\" ) quit () print ( \"The temperature in\" , o_convention , \"is\" , result , \"degrees.\" ) Input the temperature you like to convert? (e.g., 45F, 102C etc.) : 100C The temperature in Celsius is 38 degrees. Exercise: \u00b6 Who discovered your favorite elements? Let's write a simple test to see which elements were discovered by discoverer \"A,\" discoverer \"B,\" and both. import os from monty.serialization import loadfn data_dir = \"./data/\" # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) from pymatgen.core import Element # The discoverers we want to explore... discover0 = \"Berkeley\" #discover0 = \"Ghiorso\" discover1 = \"Russia\" # Loop through discoverers to find which elements they discovered for element_name in discovery_dict : names = discovery_dict [ element_name ][ 'discovered_by' ] A , B = __ , __ for name in names : if discover0 in name : A = __ if discover1 in name : B = __ if __ and __ : print ( \"For \" , element_name , \", A and B is true!\" ) elif __ : print ( \"For \" , element_name , \", A is true!\" ) elif __ : print ( \"For \" , element_name , \", B is true!\" ) Lesson 6: Sets and Dictionaries \u00b6 Exercise: create a histogram \u00b6 numbers = [ 1 , 0 , 1 , 2 , 0 , 0 , 1 , 2 , 1 , 3 , 1 , 0 , 2 ] count = {} for n in numbers : if __ not in __ : count [ n ] = 1 else : count [ n ] = count [ n ] + 1 print ( count ) {1: 5, 0: 4, 2: 3, 3: 1} Reminder: there are lots of useful Python libraries, especially the \"standard library\" that comes with Python: from collections import Counter print ( Counter ( numbers )) print ( dict ( Counter ( numbers ))) Counter({1: 5, 0: 4, 2: 3, 3: 1}) {1: 5, 0: 4, 2: 3, 3: 1} Exercise: How heavy is this molecule? \u00b6 You are given two things: a dictionary mapping atomic symbols to atomic weights ( mp_workshop.data.atomic_weights ), and a list of (atomic_symbol, count) pairs for a molecule. # Example molecules: methane = [( 'C' , 1 ), ( 'H' , 4 )] aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] Print that molecule's molecular weight. import os from monty.serialization import loadfn data_dir = \"./data/\" atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # atomic weight is 16.0423 methane = [( 'C' , 1 ), ( 'H' , 4 )] # atomic weight is 100.1421 aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] # 2. Pick a molecule to test molecule = methane # 3. Do stuff to calculate `mol_weight` # ... #print(mol_weight) 103 Lesson 7: Writing Functions \u00b6 Exercise: Find the first \u00b6 Fill in the blanks to create a function that takes a list of numbers as an argument and returns the first negative value in the list. What does your function do if the list is empty? def first_negative ( values ): for v in ____ : if ____ : return ____ Exercise : Running sum \u00b6 Write a function that calculates the running sum of any number of input arguments, returning the result as a list. For example: running(1, 2) => [1, 3] running(-5, 2, 7) => [-5, -3, 4] What should running() return, and why? Exercise: How's your phase-change memory? \u00b6 A chalcogenide is a chemical compound consisting of at least one chalcogen anion (commonly restricted to \u2018S\u2019, \u2018Se\u2019, or \u2018Te\u2019) and at least one more electropositive element. Generalize the halide function below as compound_class , a function that takes a crystal and function as parameters and returns whether or not the compound is of that class. # %load code/phase_change_memory.py import random from pymatgen import Element import os from monty.serialization import loadfn data_dir = \"./data/\" crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) def halogen ( element ): return element . is_halogen def halide ( crystal ): elts = [ Element ( s ) for s in crystal [ 'elements' ]] anion = sorted ( elts )[ - 1 ] # sorts by electronegativity return halogen ( anion ) def chalcogen ( element ): return element . is_chalogen def compound_class ( crystal , predicate ): # Fill this in. pass my_crystal = random . sample ( [ c for c in crystals if halide ( c )], 1 )[ 0 ] print ( compound_class ( my_crystal , halogen ) == halide ( my_crystal )) False Lesson 8: Test your Skills \u00b6 Now it's time to put your Python skills to the test! \u00b6 Exercise: As a materials investigator, your team has just finished running calculations for a large number of crystal structures. Now, you want to analyze the dataset by writing functions that utilize logic (in the form of conditionals ) to parse through the datasets in the forms of dictionaries and lists . First, load the relevant datasets import os from monty.serialization import loadfn data_dir = \"./data/\" # Our crystal structures, in addition to useful elemental information crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) atomic_numbers = loadfn ( os . path . join ( data_dir , \"atomic_numbers.json\" )) atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # Names of elements associated with an element symbol (e.g. {\"Al\": \"Aluminium\"}) element_names = loadfn ( os . path . join ( data_dir , \"element_names.json\" )) # Elemental mass fraction of Earth's crust (source: https://en.wikipedia.org/wiki/Abundances_of_the_elements_(data_page)) mass_frac_earth_crust = loadfn ( os . path . join ( data_dir , \"mass_frac_earth_crust.json\" )) # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) We have the mapping from symbol \\rightarrow \\rightarrow name , now let's obtain name \\rightarrow \\rightarrow symbol (we'll need it later) print ( element_names [ \"Ag\" ]) element_symbols = { __ : __ for k , v in element_names . items ()} print ( element_symbols [ \"Silver\" ]) Silver Ag Next, we'll choose the set of elements that we would like to start with. Each element has a unique story associated with it. We can explore these stories with the information from the element discovery timeline. Our task: Build a function that takes a list of element symbols as input. In addition, if we want to add the elements associated with a particular materials discoverer, we can include some regex (or \"regular expression\") strings corresponding to the discoverers we would like to feature. from pymatgen.core import Element , Composition def my_element_discoverer ( elements : list = [], discoverers : list = [], prior_to : int = 2020 ): # Start with elements provided by user # (use copy() to not modify list passed to function) all_elements = elements . copy () # Loop through discoverers to find which elements they discovered # and then add them to your list for discoverer in discoverers : for element_name in discovery_dict : for name in discovery_dict [ __ ][ 'discovered_by' ]: if discoverer in __ : elem = Element ( element_symbols [ element_name ]) all_elements . append ( __ ) # Create a new list that will contain only the elements discovered # before the year you provide elements_pruned = [] for elem in all_elements : element_name = element_names [ str ( elem )] if discovery_dict [ element_name ][ __ ] != '?' : year_discovered = int ( discovery_dict [ element_name ][ 'year' ]) else : # Unknown discovery date (known since ancient times) year_discovered = - 2000 # If statement if \"year_discovered\" is less than \"prior_to\" if __ : elem = Element ( elem ) elements_pruned . append ( elem ) all_elements = elements_pruned # Use set() to convert your list into a unique set # then recast as a list() all_elements = list ( set ( all_elements )) return all_elements Let's test out our function! Say we want to use oxygen in addition to elements discovered by scientists with Curie in their name (Marie and Pierre), as well as elements discovered by scientists in Berkeley my_elements = my_element_discoverer ( elements = [ \"O\" ], discoverers = [ \"Curie\" , \"Lawrence Berkeley\" ], prior_to = 2020 ) print ( my_elements ) Can you spot which elements are missing? (Hint below) # Discovered by scientists at UC Berkeley my_elements = my_element_discoverer ( discoverers = [ \"Ghiorso\" ], prior_to = 2020 ) print ( my_elements ) Platinum was found in gold alloys in present day Columbia dating as far back as 800 BC my_elements = my_element_discoverer ( elements = [ \"Ni\" ], discoverers = [ \"Indigenous People of South America\" ], prior_to = 1800 ) print ( my_elements ) Next, our goal is to find all of the crystals that contain the elements in our list. Once we obtain this list, it is often useful to sort these materials based on a particular metric, depending on which properties that we would like to assess. The two criteria we will use in this study are the molar mass and abundance: Molar mass = \\sum_{i=1}^N x_i n_i \\sum_{i=1}^N x_i n_i , where n_i n_i is the elemental molar mass, and x_i x_i is the molar fraction Abundance metric = \\prod_{i=1}^N a_i^{y_i} \\prod_{i=1}^N a_i^{y_i} , where a_i a_i is the mass abundance of the element i i , and y_i y_i is the mass fraction in the material import numpy as np def compute_molar_weight ( crystal ): # Obtain atomic fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) atomic_fractions = [ comp . get_atomic_fraction ( Element ( elem )) for elem in crystal [ 'elements' ]] # Obtain atomic weights of elements in material weights = [ atomic_weights [ __ ] for elem in crystal [ 'elements' ]] # Compute molar weight of material (weighted mean) molar_weight = 0.0 for elem , frac , weight in zip ( crystal [ __ ], atomic_fractions , __ ): molar_weight += __ * weight return molar_weight def compute_abundance_metric ( crystal ): # Obtain mass fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) molar_weight = compute_molar_weight ( crystal ) mass_fractions = [ comp . get_atomic_fraction ( Element ( elem )) * ( atomic_weights [ elem ] / molar_weight ) for elem in crystal [ 'elements' ]] # Obtain atomic abundances of elements in material abundances = [ mass_frac_earth_crust [ elem ] for __ in crystal [ 'elements' ]] # Compute abundance metric (geometric mean) abundance_metric = 1.0 for elem , frac , abundance in zip ( crystal [ \"elements\" ], __ , abundances ): abundance_metric *= ( abundance ) ** frac abundance_metric *= 100 return abundance_metric crystal = crystals [ 0 ] print ( \"Material:\" , crystal [ \"pretty_formula\" ]) print ( \"Molar weight (g / mol / # atoms per formula unit) = \" , compute_molar_weight ( crystal )) print ( \"Abundance metric (% kg/kg) = \" , compute_abundance_metric ( crystal )) Now that we have our sorting metrics, let's find the materials in our dataset that contain the elements we have provided, and sort them based on the criteria above. A helpful relation: For finite sets A A and B B , B \\subseteq A B \\subseteq A if and only if B = A \\cap B B = A \\cap B def get_crystals_from_elements ( elements : list , crystals : list , sort_scheme : int = 0 ): crystals_matched = [] for crystal in crystals : crystal_elems = [ Element ( elem ) for elem in crystal [ 'elements' ]] # We can check if the material contains the elements that we have provided # (set B in A) by checking if B = intersection(A,B) # Hint: \"&\" operator is used for intersection of two sets, #. and \"|\" for union intersection = set ( elements ) __ set ( crystal_elems ) if set ( elements ) == intersection : crystals_matched . append ( crystal ) if sort_scheme == 0 : # Sort by molar weight sort_key = \"Molar weight (g / mol / # atoms per formula unit)\" sortable_values = [ compute_molar_weight ( __ ) for crystal in crystals_matched ] elif sort_scheme == 1 : # Sort by abundance metric sort_key = \"Abundance metric (% kg/kg)\" sortable_values = [ compute_abundance_metric ( __ ) for crystal in crystals_matched ] else : # Catch all case - no sorting provided sortable_values = [] print ( \"Warning: Invalid sort scheme!\" ) return [], [], \"\" if sortable_values : #print(sortable_values) # Sort crystals based on sorting metric (reverse to descending order) value_map = [{ \"value\" : __ , \"crystal\" : __ } for v , c in zip ( sortable_values , crystals_matched )] value_map = sorted ( value_map , key = lambda x : x [ __ ], reverse = True ) #sortable_values, crystals_matched = zip(*sorted(zip(sortable_values, crystals_matched), reverse=True)) # Extract desired values after sorting sortable_values = [ x [ __ ] for x in value_map ] crystals_matched = [ x [ __ ] for x in value_map ] #print(sortable_values) return crystals_matched , sortable_values , sort_key We've built our functions! Now let's test them to search the materials in our dataset # The elements we would like to search our dataset elements = [ Element ( elem ) for elem in [ 'Ca' , 'O' ]] # Testing our function crystals_matched , sorted_values , sort_key = get_crystals_from_elements ( elements , crystals , sort_scheme = 0 ) # The formulas of the crystals that we searched for formulas = [ crystal [ __ ] for crystal in crystals_matched ] print ( \"Number of crystals found: \" , __ ( crystals_matched )) # print(formulas) For a large number of materials, we often gain the most information by perfoming an analysis of how the sorting criteria is distributed. In this case, we can create a histogram of the data using the matplotlib package. import matplotlib.pyplot as plt number_of_bins = 20 plt . hist ( sorted_values , number_of_bins ) plt . ylabel ( 'Counts' ) plt . xlabel ( sort_key ) plt . show ()","title":"Exercises"},{"location":"primer/02_building_logic/Exercises/#python-primer-part-ii-exercises","text":"","title":"Python Primer Part II Exercises"},{"location":"primer/02_building_logic/Exercises/#lesson-5-conditionals","text":"","title":"Lesson 5: Conditionals"},{"location":"primer/02_building_logic/Exercises/#exercise","text":"Write a Python program to convert temperatures to and from celsius, fahrenheit. Formula : c/5 = f-32/9 (where c = temperature in celsius and f = temperature in fahrenheit ) Expected Output : 60\u00b0C is 140 in Fahrenheit 45\u00b0F is 7 in Celsius # gather input from the user temp = input ( \"Input the temperature you like to convert? (e.g., 45F, 102C etc.) : \" ) # parse the string of input from the user degree = int ( temp [: - 1 ]) i_convention = temp [ - 1 ] if i_convention . upper () == __ : result = int ( round (( 9 * degree ) / 5 + 32 )) o_convention = \"Fahrenheit\" elif i_convention . upper () == __ : result = int ( round (( degree - 32 ) * 5 / 9 )) o_convention = \"Celsius\" else : print ( \"Input proper convention.\" ) quit () print ( \"The temperature in\" , o_convention , \"is\" , result , \"degrees.\" ) Input the temperature you like to convert? (e.g., 45F, 102C etc.) : 100C The temperature in Celsius is 38 degrees.","title":"Exercise:"},{"location":"primer/02_building_logic/Exercises/#exercise_1","text":"Who discovered your favorite elements? Let's write a simple test to see which elements were discovered by discoverer \"A,\" discoverer \"B,\" and both. import os from monty.serialization import loadfn data_dir = \"./data/\" # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) from pymatgen.core import Element # The discoverers we want to explore... discover0 = \"Berkeley\" #discover0 = \"Ghiorso\" discover1 = \"Russia\" # Loop through discoverers to find which elements they discovered for element_name in discovery_dict : names = discovery_dict [ element_name ][ 'discovered_by' ] A , B = __ , __ for name in names : if discover0 in name : A = __ if discover1 in name : B = __ if __ and __ : print ( \"For \" , element_name , \", A and B is true!\" ) elif __ : print ( \"For \" , element_name , \", A is true!\" ) elif __ : print ( \"For \" , element_name , \", B is true!\" )","title":"Exercise:"},{"location":"primer/02_building_logic/Exercises/#lesson-6-sets-and-dictionaries","text":"","title":"Lesson 6: Sets and Dictionaries"},{"location":"primer/02_building_logic/Exercises/#exercise-create-a-histogram","text":"numbers = [ 1 , 0 , 1 , 2 , 0 , 0 , 1 , 2 , 1 , 3 , 1 , 0 , 2 ] count = {} for n in numbers : if __ not in __ : count [ n ] = 1 else : count [ n ] = count [ n ] + 1 print ( count ) {1: 5, 0: 4, 2: 3, 3: 1} Reminder: there are lots of useful Python libraries, especially the \"standard library\" that comes with Python: from collections import Counter print ( Counter ( numbers )) print ( dict ( Counter ( numbers ))) Counter({1: 5, 0: 4, 2: 3, 3: 1}) {1: 5, 0: 4, 2: 3, 3: 1}","title":"Exercise: create a histogram"},{"location":"primer/02_building_logic/Exercises/#exercise-how-heavy-is-this-molecule","text":"You are given two things: a dictionary mapping atomic symbols to atomic weights ( mp_workshop.data.atomic_weights ), and a list of (atomic_symbol, count) pairs for a molecule. # Example molecules: methane = [( 'C' , 1 ), ( 'H' , 4 )] aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] Print that molecule's molecular weight. import os from monty.serialization import loadfn data_dir = \"./data/\" atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # atomic weight is 16.0423 methane = [( 'C' , 1 ), ( 'H' , 4 )] # atomic weight is 100.1421 aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] # 2. Pick a molecule to test molecule = methane # 3. Do stuff to calculate `mol_weight` # ... #print(mol_weight) 103","title":"Exercise: How heavy is this molecule?"},{"location":"primer/02_building_logic/Exercises/#lesson-7-writing-functions","text":"","title":"Lesson 7: Writing Functions"},{"location":"primer/02_building_logic/Exercises/#exercise-find-the-first","text":"Fill in the blanks to create a function that takes a list of numbers as an argument and returns the first negative value in the list. What does your function do if the list is empty? def first_negative ( values ): for v in ____ : if ____ : return ____","title":"Exercise: Find the first"},{"location":"primer/02_building_logic/Exercises/#exercise-running-sum","text":"Write a function that calculates the running sum of any number of input arguments, returning the result as a list. For example: running(1, 2) => [1, 3] running(-5, 2, 7) => [-5, -3, 4] What should running() return, and why?","title":"Exercise : Running sum"},{"location":"primer/02_building_logic/Exercises/#exercise-hows-your-phase-change-memory","text":"A chalcogenide is a chemical compound consisting of at least one chalcogen anion (commonly restricted to \u2018S\u2019, \u2018Se\u2019, or \u2018Te\u2019) and at least one more electropositive element. Generalize the halide function below as compound_class , a function that takes a crystal and function as parameters and returns whether or not the compound is of that class. # %load code/phase_change_memory.py import random from pymatgen import Element import os from monty.serialization import loadfn data_dir = \"./data/\" crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) def halogen ( element ): return element . is_halogen def halide ( crystal ): elts = [ Element ( s ) for s in crystal [ 'elements' ]] anion = sorted ( elts )[ - 1 ] # sorts by electronegativity return halogen ( anion ) def chalcogen ( element ): return element . is_chalogen def compound_class ( crystal , predicate ): # Fill this in. pass my_crystal = random . sample ( [ c for c in crystals if halide ( c )], 1 )[ 0 ] print ( compound_class ( my_crystal , halogen ) == halide ( my_crystal )) False","title":"Exercise: How's your phase-change memory?"},{"location":"primer/02_building_logic/Exercises/#lesson-8-test-your-skills","text":"","title":"Lesson 8: Test your Skills"},{"location":"primer/02_building_logic/Exercises/#now-its-time-to-put-your-python-skills-to-the-test","text":"Exercise: As a materials investigator, your team has just finished running calculations for a large number of crystal structures. Now, you want to analyze the dataset by writing functions that utilize logic (in the form of conditionals ) to parse through the datasets in the forms of dictionaries and lists . First, load the relevant datasets import os from monty.serialization import loadfn data_dir = \"./data/\" # Our crystal structures, in addition to useful elemental information crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) atomic_numbers = loadfn ( os . path . join ( data_dir , \"atomic_numbers.json\" )) atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # Names of elements associated with an element symbol (e.g. {\"Al\": \"Aluminium\"}) element_names = loadfn ( os . path . join ( data_dir , \"element_names.json\" )) # Elemental mass fraction of Earth's crust (source: https://en.wikipedia.org/wiki/Abundances_of_the_elements_(data_page)) mass_frac_earth_crust = loadfn ( os . path . join ( data_dir , \"mass_frac_earth_crust.json\" )) # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) We have the mapping from symbol \\rightarrow \\rightarrow name , now let's obtain name \\rightarrow \\rightarrow symbol (we'll need it later) print ( element_names [ \"Ag\" ]) element_symbols = { __ : __ for k , v in element_names . items ()} print ( element_symbols [ \"Silver\" ]) Silver Ag Next, we'll choose the set of elements that we would like to start with. Each element has a unique story associated with it. We can explore these stories with the information from the element discovery timeline. Our task: Build a function that takes a list of element symbols as input. In addition, if we want to add the elements associated with a particular materials discoverer, we can include some regex (or \"regular expression\") strings corresponding to the discoverers we would like to feature. from pymatgen.core import Element , Composition def my_element_discoverer ( elements : list = [], discoverers : list = [], prior_to : int = 2020 ): # Start with elements provided by user # (use copy() to not modify list passed to function) all_elements = elements . copy () # Loop through discoverers to find which elements they discovered # and then add them to your list for discoverer in discoverers : for element_name in discovery_dict : for name in discovery_dict [ __ ][ 'discovered_by' ]: if discoverer in __ : elem = Element ( element_symbols [ element_name ]) all_elements . append ( __ ) # Create a new list that will contain only the elements discovered # before the year you provide elements_pruned = [] for elem in all_elements : element_name = element_names [ str ( elem )] if discovery_dict [ element_name ][ __ ] != '?' : year_discovered = int ( discovery_dict [ element_name ][ 'year' ]) else : # Unknown discovery date (known since ancient times) year_discovered = - 2000 # If statement if \"year_discovered\" is less than \"prior_to\" if __ : elem = Element ( elem ) elements_pruned . append ( elem ) all_elements = elements_pruned # Use set() to convert your list into a unique set # then recast as a list() all_elements = list ( set ( all_elements )) return all_elements Let's test out our function! Say we want to use oxygen in addition to elements discovered by scientists with Curie in their name (Marie and Pierre), as well as elements discovered by scientists in Berkeley my_elements = my_element_discoverer ( elements = [ \"O\" ], discoverers = [ \"Curie\" , \"Lawrence Berkeley\" ], prior_to = 2020 ) print ( my_elements ) Can you spot which elements are missing? (Hint below) # Discovered by scientists at UC Berkeley my_elements = my_element_discoverer ( discoverers = [ \"Ghiorso\" ], prior_to = 2020 ) print ( my_elements ) Platinum was found in gold alloys in present day Columbia dating as far back as 800 BC my_elements = my_element_discoverer ( elements = [ \"Ni\" ], discoverers = [ \"Indigenous People of South America\" ], prior_to = 1800 ) print ( my_elements ) Next, our goal is to find all of the crystals that contain the elements in our list. Once we obtain this list, it is often useful to sort these materials based on a particular metric, depending on which properties that we would like to assess. The two criteria we will use in this study are the molar mass and abundance: Molar mass = \\sum_{i=1}^N x_i n_i \\sum_{i=1}^N x_i n_i , where n_i n_i is the elemental molar mass, and x_i x_i is the molar fraction Abundance metric = \\prod_{i=1}^N a_i^{y_i} \\prod_{i=1}^N a_i^{y_i} , where a_i a_i is the mass abundance of the element i i , and y_i y_i is the mass fraction in the material import numpy as np def compute_molar_weight ( crystal ): # Obtain atomic fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) atomic_fractions = [ comp . get_atomic_fraction ( Element ( elem )) for elem in crystal [ 'elements' ]] # Obtain atomic weights of elements in material weights = [ atomic_weights [ __ ] for elem in crystal [ 'elements' ]] # Compute molar weight of material (weighted mean) molar_weight = 0.0 for elem , frac , weight in zip ( crystal [ __ ], atomic_fractions , __ ): molar_weight += __ * weight return molar_weight def compute_abundance_metric ( crystal ): # Obtain mass fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) molar_weight = compute_molar_weight ( crystal ) mass_fractions = [ comp . get_atomic_fraction ( Element ( elem )) * ( atomic_weights [ elem ] / molar_weight ) for elem in crystal [ 'elements' ]] # Obtain atomic abundances of elements in material abundances = [ mass_frac_earth_crust [ elem ] for __ in crystal [ 'elements' ]] # Compute abundance metric (geometric mean) abundance_metric = 1.0 for elem , frac , abundance in zip ( crystal [ \"elements\" ], __ , abundances ): abundance_metric *= ( abundance ) ** frac abundance_metric *= 100 return abundance_metric crystal = crystals [ 0 ] print ( \"Material:\" , crystal [ \"pretty_formula\" ]) print ( \"Molar weight (g / mol / # atoms per formula unit) = \" , compute_molar_weight ( crystal )) print ( \"Abundance metric (% kg/kg) = \" , compute_abundance_metric ( crystal )) Now that we have our sorting metrics, let's find the materials in our dataset that contain the elements we have provided, and sort them based on the criteria above. A helpful relation: For finite sets A A and B B , B \\subseteq A B \\subseteq A if and only if B = A \\cap B B = A \\cap B def get_crystals_from_elements ( elements : list , crystals : list , sort_scheme : int = 0 ): crystals_matched = [] for crystal in crystals : crystal_elems = [ Element ( elem ) for elem in crystal [ 'elements' ]] # We can check if the material contains the elements that we have provided # (set B in A) by checking if B = intersection(A,B) # Hint: \"&\" operator is used for intersection of two sets, #. and \"|\" for union intersection = set ( elements ) __ set ( crystal_elems ) if set ( elements ) == intersection : crystals_matched . append ( crystal ) if sort_scheme == 0 : # Sort by molar weight sort_key = \"Molar weight (g / mol / # atoms per formula unit)\" sortable_values = [ compute_molar_weight ( __ ) for crystal in crystals_matched ] elif sort_scheme == 1 : # Sort by abundance metric sort_key = \"Abundance metric (% kg/kg)\" sortable_values = [ compute_abundance_metric ( __ ) for crystal in crystals_matched ] else : # Catch all case - no sorting provided sortable_values = [] print ( \"Warning: Invalid sort scheme!\" ) return [], [], \"\" if sortable_values : #print(sortable_values) # Sort crystals based on sorting metric (reverse to descending order) value_map = [{ \"value\" : __ , \"crystal\" : __ } for v , c in zip ( sortable_values , crystals_matched )] value_map = sorted ( value_map , key = lambda x : x [ __ ], reverse = True ) #sortable_values, crystals_matched = zip(*sorted(zip(sortable_values, crystals_matched), reverse=True)) # Extract desired values after sorting sortable_values = [ x [ __ ] for x in value_map ] crystals_matched = [ x [ __ ] for x in value_map ] #print(sortable_values) return crystals_matched , sortable_values , sort_key We've built our functions! Now let's test them to search the materials in our dataset # The elements we would like to search our dataset elements = [ Element ( elem ) for elem in [ 'Ca' , 'O' ]] # Testing our function crystals_matched , sorted_values , sort_key = get_crystals_from_elements ( elements , crystals , sort_scheme = 0 ) # The formulas of the crystals that we searched for formulas = [ crystal [ __ ] for crystal in crystals_matched ] print ( \"Number of crystals found: \" , __ ( crystals_matched )) # print(formulas) For a large number of materials, we often gain the most information by perfoming an analysis of how the sorting criteria is distributed. In this case, we can create a histogram of the data using the matplotlib package. import matplotlib.pyplot as plt number_of_bins = 20 plt . hist ( sorted_values , number_of_bins ) plt . ylabel ( 'Counts' ) plt . xlabel ( sort_key ) plt . show ()","title":"Now it's time to put your Python skills to the test!"},{"location":"primer/03_MongoDB_part1/exercise_01/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Intro to MongoDB and the Nobel Prize Dataset - Exercise \u00b6 1. Instantiate MongoClient and connect to the to the nobel database. \u00b6 from __ import __ client = __ db = __ . __ print ( db ) 2. Obtain a document from the laureates collection and display its contents. \u00b6 doc = db . __ . __ ( __ ) doc 3. Obtain a list of tuples containing the first ( \"firstname\" ) and last ( \"surname\" ) name of each laureate in the database who died ( \"diedCountry\" ) in USA. \u00b6 cursor = db . __ . __ ({ __ : __ }) names = [( doc [ __ ], doc [ __ ]) for __ in __ ] names 4. Did any of the above laureates receive more than one prize? Generate a list of tuples with their first name and the total number they were awarded. \u00b6 cursor = db . __ . __ ( __ ) names = [( doc [ __ ], len ( doc [ __ ])) for __ in __ if len ( doc [ __ ]) > 1 ] names","title":"Exercise 01"},{"location":"primer/03_MongoDB_part1/exercise_01/#intro-to-mongodb-and-the-nobel-prize-dataset-exercise","text":"","title":"Intro to MongoDB and the Nobel Prize Dataset - Exercise"},{"location":"primer/03_MongoDB_part1/exercise_01/#1-instantiate-mongoclient-and-connect-to-the-to-the-nobel-database","text":"from __ import __ client = __ db = __ . __ print ( db )","title":"1. Instantiate MongoClient and connect to the to the nobel database."},{"location":"primer/03_MongoDB_part1/exercise_01/#2-obtain-a-document-from-the-laureates-collection-and-display-its-contents","text":"doc = db . __ . __ ( __ ) doc","title":"2. Obtain a document from the laureates collection and display its contents."},{"location":"primer/03_MongoDB_part1/exercise_01/#3-obtain-a-list-of-tuples-containing-the-first-firstname-and-last-surname-name-of-each-laureate-in-the-database-who-died-diedcountry-in-usa","text":"cursor = db . __ . __ ({ __ : __ }) names = [( doc [ __ ], doc [ __ ]) for __ in __ ] names","title":"3. Obtain a list of tuples containing the first (\"firstname\") and last (\"surname\") name of each laureate in the database who died (\"diedCountry\") in USA."},{"location":"primer/03_MongoDB_part1/exercise_01/#4-did-any-of-the-above-laureates-receive-more-than-one-prize-generate-a-list-of-tuples-with-their-first-name-and-the-total-number-they-were-awarded","text":"cursor = db . __ . __ ( __ ) names = [( doc [ __ ], len ( doc [ __ ])) for __ in __ if len ( doc [ __ ]) > 1 ] names","title":"4. Did any of the above laureates receive more than one prize? Generate a list of tuples with their first name and the total number they were awarded."},{"location":"primer/03_MongoDB_part1/exercise_02/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Listing and Counting - Exercise \u00b6 1. Instantiate MongoClient and connect to the to the nobel database. \u00b6 from __ import __ client = __ db = __ . __ print ( db ) 2. Obtain a document from the prizes collection and display its contents. \u00b6 doc = db . __ . __ ( __ ) doc 3. Use count_documents to identify which of the following statements is true? \u00b6 A. the number of prizes and laureates are equal B. prizes outnumber laureates by < 2x C. prizes outnumber laureates by > 2x D. laureates outnumber prizes by < 2x E. laureates outnumber prizes by > 2x num_prizes = db . __ . __ ( __ ) num_laureates = db . __ . __ ( __ ) num_laureates / num_prizes Is the number of peace prizes awarded in 1911 ( \"year\" ) larger or smaller than the number of laureates who were born ( \"bornCountry\" ) in Finland? \u00b6 num_prizes = db . __ . __ ({ __ : __ }) num_laureates = db . __ . __ ({ __ : __ }) num_laureates > num_prizes","title":"Exercise 02"},{"location":"primer/03_MongoDB_part1/exercise_02/#listing-and-counting-exercise","text":"","title":"Listing and Counting - Exercise"},{"location":"primer/03_MongoDB_part1/exercise_02/#1-instantiate-mongoclient-and-connect-to-the-to-the-nobel-database","text":"from __ import __ client = __ db = __ . __ print ( db )","title":"1. Instantiate MongoClient and connect to the to the nobel database."},{"location":"primer/03_MongoDB_part1/exercise_02/#2-obtain-a-document-from-the-prizes-collection-and-display-its-contents","text":"doc = db . __ . __ ( __ ) doc","title":"2. Obtain a document from the prizes collection and display its contents."},{"location":"primer/03_MongoDB_part1/exercise_02/#3-use-count_documents-to-identify-which-of-the-following-statements-is-true","text":"A. the number of prizes and laureates are equal B. prizes outnumber laureates by < 2x C. prizes outnumber laureates by > 2x D. laureates outnumber prizes by < 2x E. laureates outnumber prizes by > 2x num_prizes = db . __ . __ ( __ ) num_laureates = db . __ . __ ( __ ) num_laureates / num_prizes","title":"3. Use count_documents to identify which of the following statements is true?"},{"location":"primer/03_MongoDB_part1/exercise_02/#is-the-number-of-peace-prizes-awarded-in-1911-year-larger-or-smaller-than-the-number-of-laureates-who-were-born-borncountry-in-finland","text":"num_prizes = db . __ . __ ({ __ : __ }) num_laureates = db . __ . __ ({ __ : __ }) num_laureates > num_prizes","title":"Is the number of peace prizes awarded in 1911 (\"year\") larger or smaller than the number of laureates who were born (\"bornCountry\") in Finland?"},{"location":"primer/03_MongoDB_part1/exercise_03/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Finding, and Dot Notation - Exercise \u00b6 1. Instantiate MongoClient and connect to the to the nobel database. \u00b6 from __ import __ client = __ db = __ . __ print ( db ) 2. Find the total number of laureates who died ( \"diedCountry\" ) in Canada and were not born ( \"bornCountry\" ) in Germany using the $ne operator. \u00b6 criteria = { __ : __ , __ : { __ : __ }} count = db . laureates . count_documents ( criteria ) count 3. Use the $in and $gt operators to count the total number of physics and chemistry prizes awarded after the year 1930. Recall the structure of a document in prizes : \u00b6 {'_id': ObjectId('5f1746222466f220f494d00c'), 'year': '2019', 'category': 'chemistry', 'laureates': [{'id': '976', 'firstname': 'John', 'surname': 'Goodenough', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '977', 'firstname': 'M. Stanley', 'surname': 'Whittingham', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '978', 'firstname': 'Akira', 'surname': 'Yoshino', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}]} criteria = { __ : { __ : [ \"physics\" , \"chemistry\" ]}, __ :{ __ : \"1930\" }} count = db . prizes . count_documents ( criteria ) count 4. Let's define \"high-share\" prizes as those shared by at least three people. Use dot notation and the $exists operator to find the number of \"high-share\" physics and chemistry prizes awarded after the year 2001. Remember arrays start with index 0 ! \u00b6 criteria = { __ : { __ : [ \"physics\" , \"chemistry\" ]}, __ :{ __ : \"2001\" }, \"__.__\" : { __ : True }} count = db . prizes . count_documents ( criteria ) count 5. Use the $size operator to find the total number of awarded peace prizes shared by exactly three people. \u00b6 criteria = { __ : __ , __ : { __ : 3 }} count = db . prizes . count_documents ( criteria ) count 6. Estimate the number of laureates who were awarded a prize affiliated with the USA, but were born in a different country. Use only the first prize and affiliation in each respective array. Recall the structure of a document in laureates : \u00b6 {'_id': ObjectId('5f1746222466f220f494d292'), 'id': '1', 'firstname': 'Wilhelm Conrad', 'surname': 'R\u00f6ntgen', 'born': '1845-03-27', 'died': '1923-02-10', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'bornCity': 'Lennep (now Remscheid)', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'diedCity': 'Munich', 'gender': 'male', 'prizes': [{'year': '1901', 'category': 'physics', 'share': '1', 'motivation': '\"in recognition of the extraordinary services he has rendered by the discovery of the remarkable rays subsequently named after him\"', 'affiliations': [{'name': 'Munich University', 'city': 'Munich', 'country': 'Germany'}]}]} criteria = { __ : { __ : \"USA\" }, \"__.__.__.__.__\" : \"USA\" } count = db . laureates . count_documents ( criteria ) count","title":"Exercise 03"},{"location":"primer/03_MongoDB_part1/exercise_03/#finding-and-dot-notation-exercise","text":"","title":"Finding, and Dot Notation - Exercise"},{"location":"primer/03_MongoDB_part1/exercise_03/#1-instantiate-mongoclient-and-connect-to-the-to-the-nobel-database","text":"from __ import __ client = __ db = __ . __ print ( db )","title":"1. Instantiate MongoClient and connect to the to the nobel database."},{"location":"primer/03_MongoDB_part1/exercise_03/#2-find-the-total-number-of-laureates-who-died-diedcountry-in-canada-and-were-not-born-borncountry-in-germany-using-the-ne-operator","text":"criteria = { __ : __ , __ : { __ : __ }} count = db . laureates . count_documents ( criteria ) count","title":"2. Find the total number of laureates who died (\"diedCountry\") in Canada and were not born (\"bornCountry\") in Germany using the $ne operator."},{"location":"primer/03_MongoDB_part1/exercise_03/#3-use-the-in-and-gt-operators-to-count-the-total-number-of-physics-and-chemistry-prizes-awarded-after-the-year-1930-recall-the-structure-of-a-document-in-prizes","text":"{'_id': ObjectId('5f1746222466f220f494d00c'), 'year': '2019', 'category': 'chemistry', 'laureates': [{'id': '976', 'firstname': 'John', 'surname': 'Goodenough', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '977', 'firstname': 'M. Stanley', 'surname': 'Whittingham', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '978', 'firstname': 'Akira', 'surname': 'Yoshino', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}]} criteria = { __ : { __ : [ \"physics\" , \"chemistry\" ]}, __ :{ __ : \"1930\" }} count = db . prizes . count_documents ( criteria ) count","title":"3. Use the $in and $gt operators to count the total number of physics and chemistry prizes awarded after the year 1930. Recall the structure of a document in prizes:"},{"location":"primer/03_MongoDB_part1/exercise_03/#4-lets-define-high-share-prizes-as-those-shared-by-at-least-three-people-use-dot-notation-and-the-exists-operator-to-find-the-number-of-high-share-physics-and-chemistry-prizes-awarded-after-the-year-2001-remember-arrays-start-with-index-0","text":"criteria = { __ : { __ : [ \"physics\" , \"chemistry\" ]}, __ :{ __ : \"2001\" }, \"__.__\" : { __ : True }} count = db . prizes . count_documents ( criteria ) count","title":"4. Let's define \"high-share\" prizes as those shared by at least three people. Use dot notation and the $exists operator to find the number of \"high-share\" physics and chemistry prizes awarded after the year 2001. Remember arrays start with index 0!"},{"location":"primer/03_MongoDB_part1/exercise_03/#5-use-the-size-operator-to-find-the-total-number-of-awarded-peace-prizes-shared-by-exactly-three-people","text":"criteria = { __ : __ , __ : { __ : 3 }} count = db . prizes . count_documents ( criteria ) count","title":"5. Use the $size operator to find the total number of awarded peace prizes shared by exactly three people."},{"location":"primer/03_MongoDB_part1/exercise_03/#6-estimate-the-number-of-laureates-who-were-awarded-a-prize-affiliated-with-the-usa-but-were-born-in-a-different-country-use-only-the-first-prize-and-affiliation-in-each-respective-array-recall-the-structure-of-a-document-in-laureates","text":"{'_id': ObjectId('5f1746222466f220f494d292'), 'id': '1', 'firstname': 'Wilhelm Conrad', 'surname': 'R\u00f6ntgen', 'born': '1845-03-27', 'died': '1923-02-10', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'bornCity': 'Lennep (now Remscheid)', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'diedCity': 'Munich', 'gender': 'male', 'prizes': [{'year': '1901', 'category': 'physics', 'share': '1', 'motivation': '\"in recognition of the extraordinary services he has rendered by the discovery of the remarkable rays subsequently named after him\"', 'affiliations': [{'name': 'Munich University', 'city': 'Munich', 'country': 'Germany'}]}]} criteria = { __ : { __ : \"USA\" }, \"__.__.__.__.__\" : \"USA\" } count = db . laureates . count_documents ( criteria ) count","title":"6. Estimate the number of laureates who were awarded a prize affiliated with the USA, but were born in a different country. Use only the first prize and affiliation in each respective array. Recall the structure of a document in laureates:"},{"location":"primer/03_MongoDB_part1/lessons/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Intro to MongoDB and the Nobel Prize Dataset - Lesson 1 \u00b6 Why MongoDB? \u00b6 All Materials Project data is stored using MongoDB Our API query language is based on MongoDB syntax MongoDB Structure \u00b6 Data objects represented by documents Documents organized into collections Collections make up a database Data Structure \u00b6 object \u2192 { field : value , field1 : value1 , ...} fields: string values: string , int/double , true , false , null , array , object , ... example: { name: Sue, age: 28, lawSpecialties: [copyright, tax], canMeet: { mon: True, tues: False, wed: True, thurs: True, fri: False, } } JavaScript Object Notation (JSON) \u00b6 object \u2192 { string : value , string1 : value1 , ...} values: string , number , true , false , null , object , array JSON \\longleftrightarrow \\longleftrightarrow Python \u00b6 objects \u2192 { string : value , string1 : value1 , ...} ---> dictionaries (with str keys) arrays \u2192 [ value , value1 , ...] ---> lists values: string , number , true , false , null , object , array str , int , float , True , False , None , dict , list Accessing MongoDB \u00b6 We can access our MongoDB databases using an instance of MongoClient from the pymongo package. from pymongo import MongoClient client = MongoClient () print ( client ) MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True) You can access databases and collections as attributes and/or treat them as dictionary keys. client . nobel == client [ \"nobel\" ] True client . nobel . prizes == client [ \"nobel\" ][ \"prizes\" ] True We can also connect to the nobel database. db = client . nobel print ( db ) Database(MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True), 'nobel') Searching for documents \u00b6 Let's see what a document looks like in the prizes collection using the find_one() method. This takes an optional filter argument. Passing an empty filter ( {} ) is the same as passing no filter. In Python, the returned document takes the form of a dictionary. The keys of the dictionary are the (root-level) \"fields\" of the document. db . prizes . find_one ({}) {'_id': ObjectId('5f1f4e9430688833f8e30309'), 'year': '2019', 'category': 'chemistry', 'laureates': [{'id': '976', 'firstname': 'John', 'surname': 'Goodenough', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '977', 'firstname': 'M. Stanley', 'surname': 'Whittingham', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '978', 'firstname': 'Akira', 'surname': 'Yoshino', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}]} We can now add a filter to our search to ensure that the returned prizes document contains data for a physics nobel prize. criteria = { \"category\" : \"physics\" } db . prizes . find_one ( criteria ) {'_id': ObjectId('5f1f4e9430688833f8e3030d'), 'year': '2019', 'category': 'physics', 'overallMotivation': '\"for contributions to our understanding of the evolution of the universe and Earth\u2019s place in the cosmos\"', 'laureates': [{'id': '973', 'firstname': 'James', 'surname': 'Peebles', 'motivation': '\"for theoretical discoveries in physical cosmology\"', 'share': '2'}, {'id': '974', 'firstname': 'Michel', 'surname': 'Mayor', 'motivation': '\"for the discovery of an exoplanet orbiting a solar-type star\"', 'share': '4'}, {'id': '975', 'firstname': 'Didier', 'surname': 'Queloz', 'motivation': '\"for the discovery of an exoplanet orbiting a solar-type star\"', 'share': '4'}]} You may iterate over a collection, collecting from each document. However, a collection is not a list, so we can't write for doc in <collection> to iterate over documents. Instead, we can use the find() method to produce an iterable called a cursor , and instead write for doc in <collection>.find() to iterate over documents. - Using find() to iterate over documents in the laureates collection, sum the total number of laureate prizes. The length of doc[\"prizes\"] for a laureate document doc is the number of prizes won by that laureate. Store the sum in the variable count . # Compute the total number of laureate prizes count = 0 cursor = db . laureates . find ({}) for doc in cursor : num_prizes = len ( doc [ \"prizes\" ]) count += num_prizes count 950 Listing and Counting - Lesson 2 \u00b6 from pymongo import MongoClient client = MongoClient () print ( client ) MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True) Listing databases and collections \u00b6 Recall: - Data objects represented by documents - Documents organized into collections - Collections make up a database We can list database names by calling list_database_names() on a client instance, and we can list collection names by calling list_collection_names() on a database instance. - How many databases are managed by client ? # Save a list of names of the databases managed by client db_names = client . list_database_names () print ( db_names ) # Save a list of names of the collections managed by the \"nobel\" database nobel_coll_names = client . nobel . list_collection_names () print ( nobel_coll_names ) ['admin', 'config', 'drone_test', 'fireworks', 'local', 'maggma_test', 'mp_workshop', 'nobel'] ['prizes', 'laureates'] Counting documents \u00b6 # Connect to our \"nobel\" database db = client . nobel The count_documents() method of a collection can be used to count the number of documents matching a particular filter. Let's use the method to count the total number of nobel laureates who died in the USA. An example laureates document: {'_id': ObjectId('5b9ac94ff35b63cf5231ccb1'), 'born': '1845-03-27', 'bornCity': 'Lennep (now Remscheid)', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'died': '1923-02-10', 'diedCity': 'Munich', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'firstname': 'Wilhelm Conrad', 'gender': 'male', 'id': '1', 'prizes': [{'affiliations': [{'city': 'Munich', 'country': 'Germany', 'name': 'Munich University'}], 'category': 'physics', 'motivation': '\"in recognition of the extraordinary services ' 'he has rendered by the discovery of the ' 'remarkable rays subsequently named after him\"', 'share': '1', 'year': '1901'}], 'surname': 'R\u00f6ntgen'} db . laureates . count_documents ({ \"diedCountry\" : \"USA\" }) 222 We can now build out our filter to reduce the total number of matching documents: Create a filter criteria to count the number of laureates who died in the USA but were born ( \"bornCountry\" ) in Germany. # Create a filter for laureates who died in the USA but were born in Germany criteria = { \"diedCountry\" : \"USA\" , \"bornCountry\" : \"Germany\" } # Save a count count = db . laureates . count_documents ( criteria ) print ( count ) 5 - Count laureates who died in the USA, were born in Germany, and whose first name ( \"firstname\" ) was \"Albert\". # Create a filter for laureates who died in the USA, were born in Germany, and whose first name was Albert. criteria = { \"diedCountry\" : \"USA\" , \"bornCountry\" : \"Germany\" , \"firstname\" : \"Albert\" } # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 1 db . laureates . find_one ( criteria ) {'_id': ObjectId('5f1f4e418defad6d9f1ccead'), 'id': '26', 'firstname': 'Albert', 'surname': 'Einstein', 'born': '1879-03-14', 'died': '1955-04-18', 'bornCountry': 'Germany', 'bornCountryCode': 'DE', 'bornCity': 'Ulm', 'diedCountry': 'USA', 'diedCountryCode': 'US', 'diedCity': 'Princeton, NJ', 'gender': 'male', 'prizes': [{'year': '1921', 'category': 'physics', 'share': '1', 'motivation': '\"for his services to Theoretical Physics, and especially for his discovery of the law of the photoelectric effect\"', 'affiliations': [{'name': 'Kaiser-Wilhelm-Institut (now Max-Planck-Institut) f\u00fcr Physik', 'city': 'Berlin', 'country': 'Germany'}]}]} Finding, and Dot Notation - Lesson 3 \u00b6 from pymongo import MongoClient client = MongoClient () db = client . nobel print ( client ) print ( db ) MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True) Database(MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True), 'nobel') Query operators \u00b6 Query operators provide us more options when constructing filters. For example, we may wish to find documents where a field's value matches any of a set of options. To do this we can use the $in query operator. - How many laureates were born in any of \"Canada\", \"Mexico\", or \"USA\"? #Save a filter for laureates who were born in with Canada, Mexico, or the USA. criteria = { \"bornCountry\" : { \"$in\" : [ \"Canada\" , \"Mexico\" , \"USA\" ]}} # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 295 If we wish to accept all but one option as a value for a field, we can use the $ne ( n ot e qual) operator. - How many laureates died in the USA but were not born in the USA? # Save a filter for laureates who died in the USA and were not born there. criteria = { \"bornCountry\" : { \"$ne\" : \"USA\" }, \"diedCountry\" : \"USA\" } # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 71 Below is a list of comparison query operators that are available in MongoDB: $eq -- Matches values that are equal to a specified value. $gt -- Matches values that are greater than a specified value. $gte -- Matches values that are greater than or equal to a specified value. $in -- Matches any of the values specified in an array. $lt -- Matches values that are less than a specified value. $lte -- Matches values that are less than or equal to a specified value. $ne -- Matches all values that are not equal to a specified value. $nin -- Matches none of the values specified in an array. In addition to comparison query operators, we can use logical query operators in our filters as well. - How many laureates died in Canada OR were born in France? #Save a filter for laureates who were born in Canada OR died in France. criteria = { \"$or\" :[{ \"diedCountry\" : \"Canada\" }, { \"bornCountry\" : \"France\" }]} # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 59 Below is a list of logical query operators that are available in MongoDB: $and -- Joins query clauses with a logical AND returns all documents that match the conditions of both clauses. $not -- Inverts the effect of a query expression and returns documents that do not match the query expression. $nor -- Joins query clauses with a logical NOR returns all documents that fail to match both clauses. $or -- Joins query clauses with a logical OR returns all documents that match the conditions of either clause. See https://docs.mongodb.com/manual/reference/operator/query/ for more operators! Using dot notation \u00b6 You will notice that the prizes field of a laureates document consists of an array of subdocuments: An example laureates document: {'_id': ObjectId('5b9ac94ff35b63cf5231ccb1'), 'born': '1845-03-27', 'bornCity': 'Lennep (now Remscheid)', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'died': '1923-02-10', 'diedCity': 'Munich', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'firstname': 'Wilhelm Conrad', 'gender': 'male', 'id': '1', 'prizes': [{'affiliations': [{'city': 'Munich', 'country': 'Germany', 'name': 'Munich University'}], 'category': 'physics', 'motivation': '\"in recognition of the extraordinary services ' 'he has rendered by the discovery of the ' 'remarkable rays subsequently named after him\"', 'share': '1', 'year': '1901'}], 'surname': 'R\u00f6ntgen'} An easy way to construct filters for array entries or subdocument fields is to use dot notation. - Use the $exists operator to find out how many laureates were awarded at least two prizes? #Save a filter for laureates who were awarded at least two prizes. criteria = { \"prizes.1\" :{ \"$exists\" : True }} # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 6 - Estimate how many laureates were awarded at least two prizes in physics specifically? #Save a filter to estimate the number of laureates who were awarded at least two prizes in physics. criteria = { \"prizes.0.category\" : \"physics\" , \"prizes.1.category\" : \"physics\" } # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 1 db . laureates . find_one ( criteria ) {'_id': ObjectId('5f1f4e418defad6d9f1cced5'), 'id': '66', 'firstname': 'John', 'surname': 'Bardeen', 'born': '1908-05-23', 'died': '1991-01-30', 'bornCountry': 'USA', 'bornCountryCode': 'US', 'bornCity': 'Madison, WI', 'diedCountry': 'USA', 'diedCountryCode': 'US', 'diedCity': 'Boston, MA', 'gender': 'male', 'prizes': [{'year': '1956', 'category': 'physics', 'share': '3', 'motivation': '\"for their researches on semiconductors and their discovery of the transistor effect\"', 'affiliations': [{'name': 'University of Illinois', 'city': 'Urbana, IL', 'country': 'USA'}]}, {'year': '1972', 'category': 'physics', 'share': '3', 'motivation': '\"for their jointly developed theory of superconductivity, usually called the BCS-theory\"', 'affiliations': [{'name': 'University of Illinois', 'city': 'Urbana, IL', 'country': 'USA'}]}]}","title":"Intro to MongoDB"},{"location":"primer/03_MongoDB_part1/lessons/#intro-to-mongodb-and-the-nobel-prize-dataset-lesson-1","text":"","title":"Intro to MongoDB and the Nobel Prize Dataset - Lesson 1"},{"location":"primer/03_MongoDB_part1/lessons/#why-mongodb","text":"All Materials Project data is stored using MongoDB Our API query language is based on MongoDB syntax","title":"Why MongoDB?"},{"location":"primer/03_MongoDB_part1/lessons/#mongodb-structure","text":"Data objects represented by documents Documents organized into collections Collections make up a database","title":"MongoDB Structure"},{"location":"primer/03_MongoDB_part1/lessons/#data-structure","text":"object \u2192 { field : value , field1 : value1 , ...} fields: string values: string , int/double , true , false , null , array , object , ... example: { name: Sue, age: 28, lawSpecialties: [copyright, tax], canMeet: { mon: True, tues: False, wed: True, thurs: True, fri: False, } }","title":"Data Structure"},{"location":"primer/03_MongoDB_part1/lessons/#javascript-object-notation-json","text":"object \u2192 { string : value , string1 : value1 , ...} values: string , number , true , false , null , object , array","title":"JavaScript Object Notation (JSON)"},{"location":"primer/03_MongoDB_part1/lessons/#json-longleftrightarrowlongleftrightarrow-python","text":"objects \u2192 { string : value , string1 : value1 , ...} ---> dictionaries (with str keys) arrays \u2192 [ value , value1 , ...] ---> lists values: string , number , true , false , null , object , array str , int , float , True , False , None , dict , list","title":"JSON \\longleftrightarrow\\longleftrightarrow Python"},{"location":"primer/03_MongoDB_part1/lessons/#accessing-mongodb","text":"We can access our MongoDB databases using an instance of MongoClient from the pymongo package. from pymongo import MongoClient client = MongoClient () print ( client ) MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True) You can access databases and collections as attributes and/or treat them as dictionary keys. client . nobel == client [ \"nobel\" ] True client . nobel . prizes == client [ \"nobel\" ][ \"prizes\" ] True We can also connect to the nobel database. db = client . nobel print ( db ) Database(MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True), 'nobel')","title":"Accessing MongoDB"},{"location":"primer/03_MongoDB_part1/lessons/#searching-for-documents","text":"Let's see what a document looks like in the prizes collection using the find_one() method. This takes an optional filter argument. Passing an empty filter ( {} ) is the same as passing no filter. In Python, the returned document takes the form of a dictionary. The keys of the dictionary are the (root-level) \"fields\" of the document. db . prizes . find_one ({}) {'_id': ObjectId('5f1f4e9430688833f8e30309'), 'year': '2019', 'category': 'chemistry', 'laureates': [{'id': '976', 'firstname': 'John', 'surname': 'Goodenough', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '977', 'firstname': 'M. Stanley', 'surname': 'Whittingham', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '978', 'firstname': 'Akira', 'surname': 'Yoshino', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}]} We can now add a filter to our search to ensure that the returned prizes document contains data for a physics nobel prize. criteria = { \"category\" : \"physics\" } db . prizes . find_one ( criteria ) {'_id': ObjectId('5f1f4e9430688833f8e3030d'), 'year': '2019', 'category': 'physics', 'overallMotivation': '\"for contributions to our understanding of the evolution of the universe and Earth\u2019s place in the cosmos\"', 'laureates': [{'id': '973', 'firstname': 'James', 'surname': 'Peebles', 'motivation': '\"for theoretical discoveries in physical cosmology\"', 'share': '2'}, {'id': '974', 'firstname': 'Michel', 'surname': 'Mayor', 'motivation': '\"for the discovery of an exoplanet orbiting a solar-type star\"', 'share': '4'}, {'id': '975', 'firstname': 'Didier', 'surname': 'Queloz', 'motivation': '\"for the discovery of an exoplanet orbiting a solar-type star\"', 'share': '4'}]} You may iterate over a collection, collecting from each document. However, a collection is not a list, so we can't write for doc in <collection> to iterate over documents. Instead, we can use the find() method to produce an iterable called a cursor , and instead write for doc in <collection>.find() to iterate over documents. - Using find() to iterate over documents in the laureates collection, sum the total number of laureate prizes. The length of doc[\"prizes\"] for a laureate document doc is the number of prizes won by that laureate. Store the sum in the variable count . # Compute the total number of laureate prizes count = 0 cursor = db . laureates . find ({}) for doc in cursor : num_prizes = len ( doc [ \"prizes\" ]) count += num_prizes count 950","title":"Searching for documents"},{"location":"primer/03_MongoDB_part1/lessons/#listing-and-counting-lesson-2","text":"from pymongo import MongoClient client = MongoClient () print ( client ) MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True)","title":"Listing and Counting - Lesson 2"},{"location":"primer/03_MongoDB_part1/lessons/#listing-databases-and-collections","text":"Recall: - Data objects represented by documents - Documents organized into collections - Collections make up a database We can list database names by calling list_database_names() on a client instance, and we can list collection names by calling list_collection_names() on a database instance. - How many databases are managed by client ? # Save a list of names of the databases managed by client db_names = client . list_database_names () print ( db_names ) # Save a list of names of the collections managed by the \"nobel\" database nobel_coll_names = client . nobel . list_collection_names () print ( nobel_coll_names ) ['admin', 'config', 'drone_test', 'fireworks', 'local', 'maggma_test', 'mp_workshop', 'nobel'] ['prizes', 'laureates']","title":"Listing databases and collections"},{"location":"primer/03_MongoDB_part1/lessons/#counting-documents","text":"# Connect to our \"nobel\" database db = client . nobel The count_documents() method of a collection can be used to count the number of documents matching a particular filter. Let's use the method to count the total number of nobel laureates who died in the USA. An example laureates document: {'_id': ObjectId('5b9ac94ff35b63cf5231ccb1'), 'born': '1845-03-27', 'bornCity': 'Lennep (now Remscheid)', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'died': '1923-02-10', 'diedCity': 'Munich', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'firstname': 'Wilhelm Conrad', 'gender': 'male', 'id': '1', 'prizes': [{'affiliations': [{'city': 'Munich', 'country': 'Germany', 'name': 'Munich University'}], 'category': 'physics', 'motivation': '\"in recognition of the extraordinary services ' 'he has rendered by the discovery of the ' 'remarkable rays subsequently named after him\"', 'share': '1', 'year': '1901'}], 'surname': 'R\u00f6ntgen'} db . laureates . count_documents ({ \"diedCountry\" : \"USA\" }) 222 We can now build out our filter to reduce the total number of matching documents: Create a filter criteria to count the number of laureates who died in the USA but were born ( \"bornCountry\" ) in Germany. # Create a filter for laureates who died in the USA but were born in Germany criteria = { \"diedCountry\" : \"USA\" , \"bornCountry\" : \"Germany\" } # Save a count count = db . laureates . count_documents ( criteria ) print ( count ) 5 - Count laureates who died in the USA, were born in Germany, and whose first name ( \"firstname\" ) was \"Albert\". # Create a filter for laureates who died in the USA, were born in Germany, and whose first name was Albert. criteria = { \"diedCountry\" : \"USA\" , \"bornCountry\" : \"Germany\" , \"firstname\" : \"Albert\" } # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 1 db . laureates . find_one ( criteria ) {'_id': ObjectId('5f1f4e418defad6d9f1ccead'), 'id': '26', 'firstname': 'Albert', 'surname': 'Einstein', 'born': '1879-03-14', 'died': '1955-04-18', 'bornCountry': 'Germany', 'bornCountryCode': 'DE', 'bornCity': 'Ulm', 'diedCountry': 'USA', 'diedCountryCode': 'US', 'diedCity': 'Princeton, NJ', 'gender': 'male', 'prizes': [{'year': '1921', 'category': 'physics', 'share': '1', 'motivation': '\"for his services to Theoretical Physics, and especially for his discovery of the law of the photoelectric effect\"', 'affiliations': [{'name': 'Kaiser-Wilhelm-Institut (now Max-Planck-Institut) f\u00fcr Physik', 'city': 'Berlin', 'country': 'Germany'}]}]}","title":"Counting documents"},{"location":"primer/03_MongoDB_part1/lessons/#finding-and-dot-notation-lesson-3","text":"from pymongo import MongoClient client = MongoClient () db = client . nobel print ( client ) print ( db ) MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True) Database(MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True), 'nobel')","title":"Finding, and Dot Notation - Lesson 3"},{"location":"primer/03_MongoDB_part1/lessons/#query-operators","text":"Query operators provide us more options when constructing filters. For example, we may wish to find documents where a field's value matches any of a set of options. To do this we can use the $in query operator. - How many laureates were born in any of \"Canada\", \"Mexico\", or \"USA\"? #Save a filter for laureates who were born in with Canada, Mexico, or the USA. criteria = { \"bornCountry\" : { \"$in\" : [ \"Canada\" , \"Mexico\" , \"USA\" ]}} # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 295 If we wish to accept all but one option as a value for a field, we can use the $ne ( n ot e qual) operator. - How many laureates died in the USA but were not born in the USA? # Save a filter for laureates who died in the USA and were not born there. criteria = { \"bornCountry\" : { \"$ne\" : \"USA\" }, \"diedCountry\" : \"USA\" } # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 71 Below is a list of comparison query operators that are available in MongoDB: $eq -- Matches values that are equal to a specified value. $gt -- Matches values that are greater than a specified value. $gte -- Matches values that are greater than or equal to a specified value. $in -- Matches any of the values specified in an array. $lt -- Matches values that are less than a specified value. $lte -- Matches values that are less than or equal to a specified value. $ne -- Matches all values that are not equal to a specified value. $nin -- Matches none of the values specified in an array. In addition to comparison query operators, we can use logical query operators in our filters as well. - How many laureates died in Canada OR were born in France? #Save a filter for laureates who were born in Canada OR died in France. criteria = { \"$or\" :[{ \"diedCountry\" : \"Canada\" }, { \"bornCountry\" : \"France\" }]} # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 59 Below is a list of logical query operators that are available in MongoDB: $and -- Joins query clauses with a logical AND returns all documents that match the conditions of both clauses. $not -- Inverts the effect of a query expression and returns documents that do not match the query expression. $nor -- Joins query clauses with a logical NOR returns all documents that fail to match both clauses. $or -- Joins query clauses with a logical OR returns all documents that match the conditions of either clause. See https://docs.mongodb.com/manual/reference/operator/query/ for more operators!","title":"Query operators"},{"location":"primer/03_MongoDB_part1/lessons/#using-dot-notation","text":"You will notice that the prizes field of a laureates document consists of an array of subdocuments: An example laureates document: {'_id': ObjectId('5b9ac94ff35b63cf5231ccb1'), 'born': '1845-03-27', 'bornCity': 'Lennep (now Remscheid)', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'died': '1923-02-10', 'diedCity': 'Munich', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'firstname': 'Wilhelm Conrad', 'gender': 'male', 'id': '1', 'prizes': [{'affiliations': [{'city': 'Munich', 'country': 'Germany', 'name': 'Munich University'}], 'category': 'physics', 'motivation': '\"in recognition of the extraordinary services ' 'he has rendered by the discovery of the ' 'remarkable rays subsequently named after him\"', 'share': '1', 'year': '1901'}], 'surname': 'R\u00f6ntgen'} An easy way to construct filters for array entries or subdocument fields is to use dot notation. - Use the $exists operator to find out how many laureates were awarded at least two prizes? #Save a filter for laureates who were awarded at least two prizes. criteria = { \"prizes.1\" :{ \"$exists\" : True }} # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 6 - Estimate how many laureates were awarded at least two prizes in physics specifically? #Save a filter to estimate the number of laureates who were awarded at least two prizes in physics. criteria = { \"prizes.0.category\" : \"physics\" , \"prizes.1.category\" : \"physics\" } # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 1 db . laureates . find_one ( criteria ) {'_id': ObjectId('5f1f4e418defad6d9f1cced5'), 'id': '66', 'firstname': 'John', 'surname': 'Bardeen', 'born': '1908-05-23', 'died': '1991-01-30', 'bornCountry': 'USA', 'bornCountryCode': 'US', 'bornCity': 'Madison, WI', 'diedCountry': 'USA', 'diedCountryCode': 'US', 'diedCity': 'Boston, MA', 'gender': 'male', 'prizes': [{'year': '1956', 'category': 'physics', 'share': '3', 'motivation': '\"for their researches on semiconductors and their discovery of the transistor effect\"', 'affiliations': [{'name': 'University of Illinois', 'city': 'Urbana, IL', 'country': 'USA'}]}, {'year': '1972', 'category': 'physics', 'share': '3', 'motivation': '\"for their jointly developed theory of superconductivity, usually called the BCS-theory\"', 'affiliations': [{'name': 'University of Illinois', 'city': 'Urbana, IL', 'country': 'USA'}]}]}","title":"Using dot notation"},{"location":"primer/03_MongoDB_part1/solved/exercise_01_solved/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Intro to MongoDB and the Nobel Prize Dataset - Exercise \u00b6 1. Instantiate MongoClient and connect to the to the nobel database. \u00b6 from pymongo import MongoClient client = MongoClient () db = client . nobel print ( db ) 2. Obtain a document from the laureates collection and display its contents. \u00b6 doc = db . laureates . find_one ({}) doc Obtain a list of field values for this document that have a string value. \u00b6 fields = [ field for field in doc if type ( doc [ field ]) is str ] fields 3. Obtain a list of tuples containing the first and last name of each laureate in the database who died in USA. i.e. (FirstName, LastName) \u00b6 cursor = db . laureates . find ({ \"diedCountry\" : \"USA\" }) names = [( doc [ \"firstname\" ], doc [ \"surname\" ]) for doc in cursor ] names 4. Did any of the above laureates receive more than one prize? Generate a list of tuples with their first name and the total number they were awarded. \u00b6 cursor = db . laureates . find ({}) names = [( doc [ \"firstname\" ], len ( doc [ \"prizes\" ])) for doc in cursor if len ( doc [ \"prizes\" ]) > 1 ] names","title":"Exercise 01 solved"},{"location":"primer/03_MongoDB_part1/solved/exercise_01_solved/#intro-to-mongodb-and-the-nobel-prize-dataset-exercise","text":"","title":"Intro to MongoDB and the Nobel Prize Dataset - Exercise"},{"location":"primer/03_MongoDB_part1/solved/exercise_01_solved/#1-instantiate-mongoclient-and-connect-to-the-to-the-nobel-database","text":"from pymongo import MongoClient client = MongoClient () db = client . nobel print ( db )","title":"1. Instantiate MongoClient and connect to the to the nobel database."},{"location":"primer/03_MongoDB_part1/solved/exercise_01_solved/#2-obtain-a-document-from-the-laureates-collection-and-display-its-contents","text":"doc = db . laureates . find_one ({}) doc","title":"2. Obtain a document from the laureates collection and display its contents."},{"location":"primer/03_MongoDB_part1/solved/exercise_01_solved/#obtain-a-list-of-field-values-for-this-document-that-have-a-string-value","text":"fields = [ field for field in doc if type ( doc [ field ]) is str ] fields","title":"Obtain a list of field values for this document that have a string value."},{"location":"primer/03_MongoDB_part1/solved/exercise_01_solved/#3-obtain-a-list-of-tuples-containing-the-first-and-last-name-of-each-laureate-in-the-database-who-died-in-usa-ie-firstname-lastname","text":"cursor = db . laureates . find ({ \"diedCountry\" : \"USA\" }) names = [( doc [ \"firstname\" ], doc [ \"surname\" ]) for doc in cursor ] names","title":"3. Obtain a list of tuples containing the first and last name of each laureate in the database who died in USA. i.e. (FirstName, LastName)"},{"location":"primer/03_MongoDB_part1/solved/exercise_01_solved/#4-did-any-of-the-above-laureates-receive-more-than-one-prize-generate-a-list-of-tuples-with-their-first-name-and-the-total-number-they-were-awarded","text":"cursor = db . laureates . find ({}) names = [( doc [ \"firstname\" ], len ( doc [ \"prizes\" ])) for doc in cursor if len ( doc [ \"prizes\" ]) > 1 ] names","title":"4. Did any of the above laureates receive more than one prize? Generate a list of tuples with their first name and the total number they were awarded."},{"location":"primer/03_MongoDB_part1/solved/exercise_02_solved/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Listing and Counting - Exercise \u00b6 1. Instantiate MongoClient and connect to the to the nobel database. \u00b6 from pymongo import MongoClient client = MongoClient () db = client . nobel print ( db ) 2. Obtain a document from the prizes collection and display its contents. \u00b6 doc = db . prizes . find_one ({}) doc 3. Use count_documents to identify which of the following statements is true? \u00b6 A. the number of prizes and laureates are equal B. prizes outnumber laureates by < 2x C. prizes outnumber laureates by > 2x D. laureates outnumber prizes by < 2x E. laureates outnumber prizes by > 2x num_prizes = db . prizes . count_documents ({}) num_laureates = db . laureates . count_documents ({}) num_laureates / num_prizes # D is correct. Is the number of peace prizes awarded in 1911 larger or smaller than the number of laureates who were born ( \"bornCountry\" ) in Finland? \u00b6 num_prizes = db . prizes . count_documents ({ \"year\" : \"1911\" }) num_laureates = db . laureates . count_documents ({ \"bornCountry\" : \"Finland\" }) num_laureates > num_prizes","title":"Exercise 02 solved"},{"location":"primer/03_MongoDB_part1/solved/exercise_02_solved/#listing-and-counting-exercise","text":"","title":"Listing and Counting - Exercise"},{"location":"primer/03_MongoDB_part1/solved/exercise_02_solved/#1-instantiate-mongoclient-and-connect-to-the-to-the-nobel-database","text":"from pymongo import MongoClient client = MongoClient () db = client . nobel print ( db )","title":"1. Instantiate MongoClient and connect to the to the nobel database."},{"location":"primer/03_MongoDB_part1/solved/exercise_02_solved/#2-obtain-a-document-from-the-prizes-collection-and-display-its-contents","text":"doc = db . prizes . find_one ({}) doc","title":"2. Obtain a document from the prizes collection and display its contents."},{"location":"primer/03_MongoDB_part1/solved/exercise_02_solved/#3-use-count_documents-to-identify-which-of-the-following-statements-is-true","text":"A. the number of prizes and laureates are equal B. prizes outnumber laureates by < 2x C. prizes outnumber laureates by > 2x D. laureates outnumber prizes by < 2x E. laureates outnumber prizes by > 2x num_prizes = db . prizes . count_documents ({}) num_laureates = db . laureates . count_documents ({}) num_laureates / num_prizes # D is correct.","title":"3. Use count_documents to identify which of the following statements is true?"},{"location":"primer/03_MongoDB_part1/solved/exercise_02_solved/#is-the-number-of-peace-prizes-awarded-in-1911-larger-or-smaller-than-the-number-of-laureates-who-were-born-borncountry-in-finland","text":"num_prizes = db . prizes . count_documents ({ \"year\" : \"1911\" }) num_laureates = db . laureates . count_documents ({ \"bornCountry\" : \"Finland\" }) num_laureates > num_prizes","title":"Is the number of peace prizes awarded in 1911 larger or smaller than the number of laureates who were born (\"bornCountry\") in Finland?"},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Finding, and Dot Notation - Exercise \u00b6 1. Instantiate MongoClient and connect to the to the nobel database. \u00b6 from pymongo import MongoClient client = MongoClient () db = client . nobel print ( db ) 2. Find the total number of laureates who died ( \"diedCountry\" ) in Canada and were not born in Germany using the $ne operator. \u00b6 criteria = { \"diedCountry\" : \"Canada\" , \"bornCountry\" : { \"$ne\" : \"Germany\" }} count = db . laureates . count_documents ( criteria ) count 3. Use the $in and $gt operators to count the total number of physics and chemistry prizes awarded after the year 1930. Recall the structure of a document in prizes : \u00b6 {'_id': ObjectId('5f1746222466f220f494d00c'), 'year': '2019', 'category': 'chemistry', 'laureates': [{'id': '976', 'firstname': 'John', 'surname': 'Goodenough', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '977', 'firstname': 'M. Stanley', 'surname': 'Whittingham', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '978', 'firstname': 'Akira', 'surname': 'Yoshino', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}]} criteria = { \"category\" : { \"$in\" : [ \"physics\" , \"chemistry\" ]}, \"year\" :{ \"$gt\" : \"1930\" }} count = db . prizes . count_documents ( criteria ) count 4. Let's define \"high-share\" prizes as those shared by at least three people. Use dot notation and the $exists operator to find the number of \"high-share\" physics and chemistry prizes awarded after the year 2001. Remember arrays start with index 0 ! \u00b6 criteria = { \"category\" : { \"$in\" : [ \"physics\" , \"chemistry\" ]}, \"year\" :{ \"$gt\" : \"2001\" }, \"laureates.2\" : { \"$exists\" : True }} count = db . prizes . count_documents ( criteria ) count 5. Use the $size operator to find the total number of awarded peace prizes shared by exactly three people. \u00b6 criteria = { \"category\" : \"peace\" , \"laureates\" : { \"$size\" : 3 }} count = db . prizes . count_documents ( criteria ) count 6. Estimate the number of laureates who were awarded a prize ( \"prizes\" ) affiliated with the USA, but were born in a different country ( \"bornCountry\" ). Use only the first prize and affiliation in each respective array. Recall the structure of a document in laureates : \u00b6 {'_id': ObjectId('5f1746222466f220f494d292'), 'id': '1', 'firstname': 'Wilhelm Conrad', 'surname': 'R\u00f6ntgen', 'born': '1845-03-27', 'died': '1923-02-10', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'bornCity': 'Lennep (now Remscheid)', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'diedCity': 'Munich', 'gender': 'male', 'prizes': [{'year': '1901', 'category': 'physics', 'share': '1', 'motivation': '\"in recognition of the extraordinary services he has rendered by the discovery of the remarkable rays subsequently named after him\"', 'affiliations': [{'name': 'Munich University', 'city': 'Munich', 'country': 'Germany'}]}]} criteria = { \"bornCountry\" : { \"$ne\" : \"USA\" }, \"prizes.0.affiliations.0.country\" : \"USA\" } count = db . laureates . count_documents ( criteria ) count","title":"Exercise 03 solved"},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/#finding-and-dot-notation-exercise","text":"","title":"Finding, and Dot Notation - Exercise"},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/#1-instantiate-mongoclient-and-connect-to-the-to-the-nobel-database","text":"from pymongo import MongoClient client = MongoClient () db = client . nobel print ( db )","title":"1. Instantiate MongoClient and connect to the to the nobel database."},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/#2-find-the-total-number-of-laureates-who-died-diedcountry-in-canada-and-were-not-born-in-germany-using-the-ne-operator","text":"criteria = { \"diedCountry\" : \"Canada\" , \"bornCountry\" : { \"$ne\" : \"Germany\" }} count = db . laureates . count_documents ( criteria ) count","title":"2. Find the total number of laureates who died (\"diedCountry\") in Canada and were not born in Germany using the $ne operator."},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/#3-use-the-in-and-gt-operators-to-count-the-total-number-of-physics-and-chemistry-prizes-awarded-after-the-year-1930-recall-the-structure-of-a-document-in-prizes","text":"{'_id': ObjectId('5f1746222466f220f494d00c'), 'year': '2019', 'category': 'chemistry', 'laureates': [{'id': '976', 'firstname': 'John', 'surname': 'Goodenough', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '977', 'firstname': 'M. Stanley', 'surname': 'Whittingham', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '978', 'firstname': 'Akira', 'surname': 'Yoshino', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}]} criteria = { \"category\" : { \"$in\" : [ \"physics\" , \"chemistry\" ]}, \"year\" :{ \"$gt\" : \"1930\" }} count = db . prizes . count_documents ( criteria ) count","title":"3. Use the $in and $gt operators to count the total number of physics and chemistry prizes awarded after the year 1930. Recall the structure of a document in prizes:"},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/#4-lets-define-high-share-prizes-as-those-shared-by-at-least-three-people-use-dot-notation-and-the-exists-operator-to-find-the-number-of-high-share-physics-and-chemistry-prizes-awarded-after-the-year-2001-remember-arrays-start-with-index-0","text":"criteria = { \"category\" : { \"$in\" : [ \"physics\" , \"chemistry\" ]}, \"year\" :{ \"$gt\" : \"2001\" }, \"laureates.2\" : { \"$exists\" : True }} count = db . prizes . count_documents ( criteria ) count","title":"4. Let's define \"high-share\" prizes as those shared by at least three people. Use dot notation and the $exists operator to find the number of \"high-share\" physics and chemistry prizes awarded after the year 2001. Remember arrays start with index 0!"},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/#5-use-the-size-operator-to-find-the-total-number-of-awarded-peace-prizes-shared-by-exactly-three-people","text":"criteria = { \"category\" : \"peace\" , \"laureates\" : { \"$size\" : 3 }} count = db . prizes . count_documents ( criteria ) count","title":"5. Use the $size operator to find the total number of awarded peace prizes shared by exactly three people."},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/#6-estimate-the-number-of-laureates-who-were-awarded-a-prize-prizes-affiliated-with-the-usa-but-were-born-in-a-different-country-borncountry-use-only-the-first-prize-and-affiliation-in-each-respective-array-recall-the-structure-of-a-document-in-laureates","text":"{'_id': ObjectId('5f1746222466f220f494d292'), 'id': '1', 'firstname': 'Wilhelm Conrad', 'surname': 'R\u00f6ntgen', 'born': '1845-03-27', 'died': '1923-02-10', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'bornCity': 'Lennep (now Remscheid)', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'diedCity': 'Munich', 'gender': 'male', 'prizes': [{'year': '1901', 'category': 'physics', 'share': '1', 'motivation': '\"in recognition of the extraordinary services he has rendered by the discovery of the remarkable rays subsequently named after him\"', 'affiliations': [{'name': 'Munich University', 'city': 'Munich', 'country': 'Germany'}]}]} criteria = { \"bornCountry\" : { \"$ne\" : \"USA\" }, \"prizes.0.affiliations.0.country\" : \"USA\" } count = db . laureates . count_documents ( criteria ) count","title":"6. Estimate the number of laureates who were awarded a prize (\"prizes\") affiliated with the USA, but were born in a different country (\"bornCountry\"). Use only the first prize and affiliation in each respective array. Recall the structure of a document in laureates:"},{"location":"primer/04_MongoDB_part2/exercises/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); MongoDB Part 2 Exercises \u00b6 1: Working with Distinct Values, $elemMatch, and Regex \u00b6 from pymongo import MongoClient client = MongoClient () db = client . nobel Never from there, but sometimes there at last \u00b6 There are some recorded countries of death ( \"diedCountry\" ) that do not appear as a country of birth ( \"bornCountry\" ) for laureates. One such country is \"East Germany\". Return a set of all such countries as countries . # Countries recorded as countries of death but not as countries of birth countries = set ( ____ ) - set ( ____ ) print ( countries ) Countries of affiliation \u00b6 We saw in the last exercise that countries can be associated with a laureate as their country of birth and as their country of death. For each prize a laureate received, they may also have been affiliated with an institution at the time, located in a country. Determine the number of distinct countries recorded as part of an affiliation for laureates' prizes. Save this as count . # The number of distinct countries of laureate affiliation for prizes count = ____ ( db . laureates . ____ ( ____ )) print ( count ) Triple plays (mostly) all around \u00b6 All prize categories but one \u2013 literature \u2013 have had prizes shared by three or more laureates. Save a filter document criteria that, when passed to db.prizes.distinct , returns all prize categories shared by three or more laureates. That is, \"laureates.2\" must exist for such documents. Save these prize categories as a Python set called triple_play_categories . Confirm via an assertion that \"literature\" is the only prize category with no prizes shared by three or more laureates. # Save a filter for prize documents with three or more laureates criteria = { ____ : { ____ : ____ }} # Save the set of distinct prize categories in documents satisfying the criteria triple_play_categories = ____ ( db . prizes . distinct ( ____ , criteria )) # Confirm literature as the only category not satisfying the criteria. assert set ( db . prizes . distinct ( ____ )) - triple_play_categories == { ____ } Other sharing after World War II \u00b6 Similar to the example in the lesson, what is the approximate ratio of the number of laureates who won an unshared prize in categories other than physics, chemistry, and medicine after World War II to the number of laureates who won a shared prize in categories other than physics, chemistry, and medicine after World War II? Save an $elemMatch filter unshared to count laureates with unshared prizes in categories other than (\"not in\") [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. Save an $elemMatch filter shared to count laureates with shared (i.e., \"share\" is not \"1\") prizes in categories other than [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. # Save a filter for laureates with unshared prizes unshared = { \"prizes\" : { ____ : { ____ : { ____ : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : \"1\" , \"year\" : { ____ : \"1945\" }, }}} # Save a filter for laureates with shared prizes shared = { \"prizes\" : { ____ : { ____ : { ____ : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : { ____ : \"1\" }, \"year\" : { ____ : \"1945\" }, }}} ratio = db . laureates . ____ ( ____ ) / db . laureates . ____ ( ____ ) print ( ratio ) Organizations and prizes over time \u00b6 How many organizations won prizes before 1945 versus in or after 1945? - Save a filter before to count organization laureates with prizes won before 1945. Recall that organization status is encoded with the \"gender\" field, and that dot notation is needed to access a laureate's \"year\" field within its \"prizes\" array. - Save a filter in_or_after to count organization laureates with prizes won in or after 1945. # Save a filter for organization laureates with prizes won before 1945 before = { ____ : ____ , ____ : { ____ : \"1945\" }, } # Save a filter for organization laureates with prizes won in or after 1945 in_or_after = { ____ : ____ , ____ : { ____ : \"1945\" }, } n_before = db . laureates . count_documents ( before ) n_in_or_after = db . laureates . count_documents ( in_or_after ) ratio = n_in_or_after / ( n_in_or_after + n_before ) print ( ratio ) Germany, then and now \u00b6 Just as we saw with Poland, there are laureates who were born somewhere that was in Germany at the time but is now not, and others born somewhere that was not in Germany at the time but now is. - Use a regular expression object to filter for laureates with \"Germany\" in their \"bornCountry\" value. # Filter for laureates with \"Germany\" in their \"bornCountry\" value criteria = { \"bornCountry\" : { \"$regex\" : ____ }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates with a \"bornCountry\" value starting with \"Germany\". # Filter for laureates with a \"bornCountry\" value starting with \"Germany\" criteria = { \"bornCountry\" : { ____ : ____ }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what was at the time Germany but is now another country. # Fill in a string value to be sandwiched between the strings \"^\" and \"now\" criteria = { \"bornCountry\" : { ____ : \"^\" + ____ + \"now\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what is now Germany but at the time was another country. # Filter for currently-Germany countries of birth. # Fill in a string value to be sandwiched between the strings \"now\" and \"$\" criteria = { \"bornCountry\" : { ____ : \"now\" + ____ + \"$\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) The prized transistor \u00b6 Three people shared a Nobel prize \"for their researches on semiconductors and their discovery of the transistor effect\". We can filter on \"transistor\" as a substring of a laureate's \"prizes.motivation\" field value to find these laureates. Save a filter criteria that finds laureates with prizes.motivation values containing \"transistor\" as a substring. The substring can appear anywhere within the value, so no anchoring characters are needed. Save to first and last the field names corresponding to a laureate's first name and last name (i.e. \"surname\") so that we can print out the names of these laureates. # Save a filter for laureates with prize motivation values containing \"transistor\" as a substring criteria = { ____ : { ____ : ____ }} # Save the field names corresponding to a laureate's first name and last name first , last = ____ , ____ print ([( laureate [ first ], laureate [ last ]) for laureate in db . laureates . find ( criteria )]) 2: Projection and Sorting \u00b6 Rounding up the G.S. crew \u00b6 We can use the regular expression operator $regex to find laureates whose initials are G.S. Let's use projection and list comprehension to collect the full names of these laureates by concatenating their first (\"firstname\") and last (\"surname\") names. Fill in the blanks to save a list names of full names (\"firstname\" plus \"surname\") of laureates with initials G.S. (ignoring middles names/initials). You'll need to both filter on names as well as project out the fields required to collect the full names. # Collect a list of full names names = [ \" \" . join ([ doc [ ____ ], doc [ ____ ]]) for doc in db . laureates . find ( { ____ : { \"$regex\" : \"^G\" }, ____ : { \"$regex\" : \"^S\" }}, { ____ : 1 , ____ : 1 })] print ( names ) Sorting together: MongoDB + Python \u00b6 You will print out the names of all physics laureates, with one line printed for each award year, in chronological order. Each line will list laureates for that year in alphabetical order by surname (\"last\" name). I encourage you to print intermediate results and understand the nested structure of prize documents. - Construct a sort specification sort_spec to fetch physics prizes by ascending year. from operator import itemgetter # Sort by ascending year sort_spec = [( ____ , ____ )] - Use <collection>.find to construct a cursor that fetches prizes with a \"category\" of \"physics\", sorts by ascending year, and projects the year and first laureate full name ( laureates.firstname and laureates.surname ). You should encounter an error at year 1916 . # Construct a cursor over physics prizes cursor = db . prizes . ____ ({ ____ : ____ }, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - The error is caused by the fact that the Nobel Prize in physics was not awarded in 1916 due to World War I. Supplement the cursor's filter to avoid the error: # Construct a fixed cursor over physics prizes cursor = db . prizes . ____ ({ ____ : ____ , ____ : { ____ : True }}, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - Complete the definition of the function names so that, given a prize document, it returns a list of formatted names, sorted by ascending \"surname\", for each of the \"laureates\" in that prize document. # Define a function names() to return a list of formatted names def names ( doc ): formatted_names = [ \" {firstname} {surname} \" . format ( ** laureate ) for laureate in sorted ( doc [ ____ ], key = itemgetter ( ____ ))] return formatted_names lines = [ \" {year} : {names} \" . format ( year = doc [ \"year\" ], names = \" and \" . join ( names ( doc ))) for doc in cursor ] for line in lines : print ( line ) Gap years \u00b6 As we saw above, there have been years for which prizes in one or more of the original categories were not awarded. Sorting first by reverse chronological order and second by alphabetical order of category, collect and format prize documents to produce one formatted entry per year listing categories missing for that year. - Construct a set original_categories of prize categories awarded in 1901. import itertools from operator import itemgetter # Save the set of prize categories awarded in 1901 original_categories = set ( db . prizes . ____ ( \"category\" , { ____ : \"1901\" })) print ( original_categories ) - Use <collection>.find to construct a cursor that yields prize documents only for categories in the list of original categories which contain the laureates key and thus were awarded, sorted first by decreasing year and second by increasing category. # Construct a cursor over original-category prizes cursor = db . prizes . ____ ({ \"category\" : { ____ : list ( original_categories )}, ____ : { ____ : ____ }}, { \"category\" : 1 , \"year\" : 1 }, sort = [( ____ , ____ ), ( ____ , ____ )]) - Collect a list not_awarded of entries to be printed, one per line, that displays a year and the categories missing for that year. You will collect \"category\" values for each year and set-subtract them from the original categories. # Collect entries for missing prize categories not_awarded = [] for key , group in itertools . groupby ( cursor , key = itemgetter ( \"year\" )): year_categories = set ( prize [ ____ ] for prize in group ) missing = \", \" . join ( sorted ( ____ - ____ )) if missing : not_awarded . append ( \" {} : {} \" . format ( key , missing )) for line in not_awarded : print ( line ) 3: Indexing \u00b6 An index for high-share categories \u00b6 We want to speed up the following operation: db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) - Confirm that the operation takes approximately 1 ms without an index. - Specify a compound index model index_model to pass to db.prizes.create_index . index_model = [( ____ , ____ ), ( ____ , ____ )] db . prizes . create_index ( index_model ) - Confirm that the execution time is now below 400 \u00b5s. # Drop the index for consistency db . prizes . drop_index ( index_model ) Recently single? \u00b6 A prize might be awarded to a single laureate or to several. For each prize category, report the most recent year that a single laureate -- rather than several -- received a prize in that category. Specify an index model index_model to pass to db.prizes.create_index that speeds up finding prizes by category and sorting results by decreasing year. That is, the model should index first on category (ascending) and second on year (descending). Save a string report for printing the last single-laureate year for each distinct category, one category per line. To do this, for each distinct prize category, find the latest-year prize of that category with a laureate share of \"1\". # Specify an index model for compound sorting index_model = [( ____ , 1 ), ( ____ , - 1 )] db . prizes . create_index ( index_model ) # Collect the last single-laureate year for each category report = \"\" for category in sorted ( db . prizes . ____ ( \"category\" )): doc = db . prizes . find_one ( { ____ : ____ , \"laureates.share\" : \"1\" }, sort = [( ____ , ____ )] ) report += \" {category} : {year} \\n \" . format ( ** doc ) print ( report ) # Drop the index for consistency db . prizes . drop_index ( index_model ) Born and affiliated \u00b6 Some countries are, for one or more laureates, both their country of birth (\"bornCountry\") and a country of affiliation for one or more of their prizes (\"prizes.affiliations.country\"). You will find the five countries of birth with the highest counts of such laureates. Create an index on country of birth (\"bornCountry\") for db.laureates to ensure efficient gathering of distinct values and counting of documents Complete the skeleton dictionary comprehension to construct n_born_and_affiliated , the count of laureates as described above for each distinct country of birth. from collections import Counter # Ensure an index on country of birth db . laureates . create_index ([( ____ , 1 )]) # Collect a count of laureates for each country of birth n_born_and_affiliated = { country : db . laureates . count_documents ({ ____ : ____ , \"prizes.affiliations.country\" : ____ }) for ____ in db . laureates . distinct ( \"bornCountry\" ) } five_most_common = Counter ( n_born_and_affiliated ) . most_common ( 5 ) print ( five_most_common ) # Drop the index for consistency db . laureates . drop_index ([( ____ , 1 )])","title":"Exercises"},{"location":"primer/04_MongoDB_part2/exercises/#mongodb-part-2-exercises","text":"","title":"MongoDB Part 2 Exercises"},{"location":"primer/04_MongoDB_part2/exercises/#1-working-with-distinct-values-elemmatch-and-regex","text":"from pymongo import MongoClient client = MongoClient () db = client . nobel","title":"1: Working with Distinct Values, $elemMatch, and Regex"},{"location":"primer/04_MongoDB_part2/exercises/#never-from-there-but-sometimes-there-at-last","text":"There are some recorded countries of death ( \"diedCountry\" ) that do not appear as a country of birth ( \"bornCountry\" ) for laureates. One such country is \"East Germany\". Return a set of all such countries as countries . # Countries recorded as countries of death but not as countries of birth countries = set ( ____ ) - set ( ____ ) print ( countries )","title":"Never from there, but sometimes there at last"},{"location":"primer/04_MongoDB_part2/exercises/#countries-of-affiliation","text":"We saw in the last exercise that countries can be associated with a laureate as their country of birth and as their country of death. For each prize a laureate received, they may also have been affiliated with an institution at the time, located in a country. Determine the number of distinct countries recorded as part of an affiliation for laureates' prizes. Save this as count . # The number of distinct countries of laureate affiliation for prizes count = ____ ( db . laureates . ____ ( ____ )) print ( count )","title":"Countries of affiliation"},{"location":"primer/04_MongoDB_part2/exercises/#triple-plays-mostly-all-around","text":"All prize categories but one \u2013 literature \u2013 have had prizes shared by three or more laureates. Save a filter document criteria that, when passed to db.prizes.distinct , returns all prize categories shared by three or more laureates. That is, \"laureates.2\" must exist for such documents. Save these prize categories as a Python set called triple_play_categories . Confirm via an assertion that \"literature\" is the only prize category with no prizes shared by three or more laureates. # Save a filter for prize documents with three or more laureates criteria = { ____ : { ____ : ____ }} # Save the set of distinct prize categories in documents satisfying the criteria triple_play_categories = ____ ( db . prizes . distinct ( ____ , criteria )) # Confirm literature as the only category not satisfying the criteria. assert set ( db . prizes . distinct ( ____ )) - triple_play_categories == { ____ }","title":"Triple plays (mostly) all around"},{"location":"primer/04_MongoDB_part2/exercises/#other-sharing-after-world-war-ii","text":"Similar to the example in the lesson, what is the approximate ratio of the number of laureates who won an unshared prize in categories other than physics, chemistry, and medicine after World War II to the number of laureates who won a shared prize in categories other than physics, chemistry, and medicine after World War II? Save an $elemMatch filter unshared to count laureates with unshared prizes in categories other than (\"not in\") [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. Save an $elemMatch filter shared to count laureates with shared (i.e., \"share\" is not \"1\") prizes in categories other than [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. # Save a filter for laureates with unshared prizes unshared = { \"prizes\" : { ____ : { ____ : { ____ : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : \"1\" , \"year\" : { ____ : \"1945\" }, }}} # Save a filter for laureates with shared prizes shared = { \"prizes\" : { ____ : { ____ : { ____ : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : { ____ : \"1\" }, \"year\" : { ____ : \"1945\" }, }}} ratio = db . laureates . ____ ( ____ ) / db . laureates . ____ ( ____ ) print ( ratio )","title":"Other sharing after World War II"},{"location":"primer/04_MongoDB_part2/exercises/#organizations-and-prizes-over-time","text":"How many organizations won prizes before 1945 versus in or after 1945? - Save a filter before to count organization laureates with prizes won before 1945. Recall that organization status is encoded with the \"gender\" field, and that dot notation is needed to access a laureate's \"year\" field within its \"prizes\" array. - Save a filter in_or_after to count organization laureates with prizes won in or after 1945. # Save a filter for organization laureates with prizes won before 1945 before = { ____ : ____ , ____ : { ____ : \"1945\" }, } # Save a filter for organization laureates with prizes won in or after 1945 in_or_after = { ____ : ____ , ____ : { ____ : \"1945\" }, } n_before = db . laureates . count_documents ( before ) n_in_or_after = db . laureates . count_documents ( in_or_after ) ratio = n_in_or_after / ( n_in_or_after + n_before ) print ( ratio )","title":"Organizations and prizes over time"},{"location":"primer/04_MongoDB_part2/exercises/#germany-then-and-now","text":"Just as we saw with Poland, there are laureates who were born somewhere that was in Germany at the time but is now not, and others born somewhere that was not in Germany at the time but now is. - Use a regular expression object to filter for laureates with \"Germany\" in their \"bornCountry\" value. # Filter for laureates with \"Germany\" in their \"bornCountry\" value criteria = { \"bornCountry\" : { \"$regex\" : ____ }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates with a \"bornCountry\" value starting with \"Germany\". # Filter for laureates with a \"bornCountry\" value starting with \"Germany\" criteria = { \"bornCountry\" : { ____ : ____ }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what was at the time Germany but is now another country. # Fill in a string value to be sandwiched between the strings \"^\" and \"now\" criteria = { \"bornCountry\" : { ____ : \"^\" + ____ + \"now\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what is now Germany but at the time was another country. # Filter for currently-Germany countries of birth. # Fill in a string value to be sandwiched between the strings \"now\" and \"$\" criteria = { \"bornCountry\" : { ____ : \"now\" + ____ + \"$\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria )))","title":"Germany, then and now"},{"location":"primer/04_MongoDB_part2/exercises/#the-prized-transistor","text":"Three people shared a Nobel prize \"for their researches on semiconductors and their discovery of the transistor effect\". We can filter on \"transistor\" as a substring of a laureate's \"prizes.motivation\" field value to find these laureates. Save a filter criteria that finds laureates with prizes.motivation values containing \"transistor\" as a substring. The substring can appear anywhere within the value, so no anchoring characters are needed. Save to first and last the field names corresponding to a laureate's first name and last name (i.e. \"surname\") so that we can print out the names of these laureates. # Save a filter for laureates with prize motivation values containing \"transistor\" as a substring criteria = { ____ : { ____ : ____ }} # Save the field names corresponding to a laureate's first name and last name first , last = ____ , ____ print ([( laureate [ first ], laureate [ last ]) for laureate in db . laureates . find ( criteria )])","title":"The prized transistor"},{"location":"primer/04_MongoDB_part2/exercises/#2-projection-and-sorting","text":"","title":"2: Projection and Sorting"},{"location":"primer/04_MongoDB_part2/exercises/#rounding-up-the-gs-crew","text":"We can use the regular expression operator $regex to find laureates whose initials are G.S. Let's use projection and list comprehension to collect the full names of these laureates by concatenating their first (\"firstname\") and last (\"surname\") names. Fill in the blanks to save a list names of full names (\"firstname\" plus \"surname\") of laureates with initials G.S. (ignoring middles names/initials). You'll need to both filter on names as well as project out the fields required to collect the full names. # Collect a list of full names names = [ \" \" . join ([ doc [ ____ ], doc [ ____ ]]) for doc in db . laureates . find ( { ____ : { \"$regex\" : \"^G\" }, ____ : { \"$regex\" : \"^S\" }}, { ____ : 1 , ____ : 1 })] print ( names )","title":"Rounding up the G.S. crew"},{"location":"primer/04_MongoDB_part2/exercises/#sorting-together-mongodb-python","text":"You will print out the names of all physics laureates, with one line printed for each award year, in chronological order. Each line will list laureates for that year in alphabetical order by surname (\"last\" name). I encourage you to print intermediate results and understand the nested structure of prize documents. - Construct a sort specification sort_spec to fetch physics prizes by ascending year. from operator import itemgetter # Sort by ascending year sort_spec = [( ____ , ____ )] - Use <collection>.find to construct a cursor that fetches prizes with a \"category\" of \"physics\", sorts by ascending year, and projects the year and first laureate full name ( laureates.firstname and laureates.surname ). You should encounter an error at year 1916 . # Construct a cursor over physics prizes cursor = db . prizes . ____ ({ ____ : ____ }, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - The error is caused by the fact that the Nobel Prize in physics was not awarded in 1916 due to World War I. Supplement the cursor's filter to avoid the error: # Construct a fixed cursor over physics prizes cursor = db . prizes . ____ ({ ____ : ____ , ____ : { ____ : True }}, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - Complete the definition of the function names so that, given a prize document, it returns a list of formatted names, sorted by ascending \"surname\", for each of the \"laureates\" in that prize document. # Define a function names() to return a list of formatted names def names ( doc ): formatted_names = [ \" {firstname} {surname} \" . format ( ** laureate ) for laureate in sorted ( doc [ ____ ], key = itemgetter ( ____ ))] return formatted_names lines = [ \" {year} : {names} \" . format ( year = doc [ \"year\" ], names = \" and \" . join ( names ( doc ))) for doc in cursor ] for line in lines : print ( line )","title":"Sorting together: MongoDB + Python"},{"location":"primer/04_MongoDB_part2/exercises/#gap-years","text":"As we saw above, there have been years for which prizes in one or more of the original categories were not awarded. Sorting first by reverse chronological order and second by alphabetical order of category, collect and format prize documents to produce one formatted entry per year listing categories missing for that year. - Construct a set original_categories of prize categories awarded in 1901. import itertools from operator import itemgetter # Save the set of prize categories awarded in 1901 original_categories = set ( db . prizes . ____ ( \"category\" , { ____ : \"1901\" })) print ( original_categories ) - Use <collection>.find to construct a cursor that yields prize documents only for categories in the list of original categories which contain the laureates key and thus were awarded, sorted first by decreasing year and second by increasing category. # Construct a cursor over original-category prizes cursor = db . prizes . ____ ({ \"category\" : { ____ : list ( original_categories )}, ____ : { ____ : ____ }}, { \"category\" : 1 , \"year\" : 1 }, sort = [( ____ , ____ ), ( ____ , ____ )]) - Collect a list not_awarded of entries to be printed, one per line, that displays a year and the categories missing for that year. You will collect \"category\" values for each year and set-subtract them from the original categories. # Collect entries for missing prize categories not_awarded = [] for key , group in itertools . groupby ( cursor , key = itemgetter ( \"year\" )): year_categories = set ( prize [ ____ ] for prize in group ) missing = \", \" . join ( sorted ( ____ - ____ )) if missing : not_awarded . append ( \" {} : {} \" . format ( key , missing )) for line in not_awarded : print ( line )","title":"Gap years"},{"location":"primer/04_MongoDB_part2/exercises/#3-indexing","text":"","title":"3: Indexing"},{"location":"primer/04_MongoDB_part2/exercises/#an-index-for-high-share-categories","text":"We want to speed up the following operation: db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) - Confirm that the operation takes approximately 1 ms without an index. - Specify a compound index model index_model to pass to db.prizes.create_index . index_model = [( ____ , ____ ), ( ____ , ____ )] db . prizes . create_index ( index_model ) - Confirm that the execution time is now below 400 \u00b5s. # Drop the index for consistency db . prizes . drop_index ( index_model )","title":"An index for high-share categories"},{"location":"primer/04_MongoDB_part2/exercises/#recently-single","text":"A prize might be awarded to a single laureate or to several. For each prize category, report the most recent year that a single laureate -- rather than several -- received a prize in that category. Specify an index model index_model to pass to db.prizes.create_index that speeds up finding prizes by category and sorting results by decreasing year. That is, the model should index first on category (ascending) and second on year (descending). Save a string report for printing the last single-laureate year for each distinct category, one category per line. To do this, for each distinct prize category, find the latest-year prize of that category with a laureate share of \"1\". # Specify an index model for compound sorting index_model = [( ____ , 1 ), ( ____ , - 1 )] db . prizes . create_index ( index_model ) # Collect the last single-laureate year for each category report = \"\" for category in sorted ( db . prizes . ____ ( \"category\" )): doc = db . prizes . find_one ( { ____ : ____ , \"laureates.share\" : \"1\" }, sort = [( ____ , ____ )] ) report += \" {category} : {year} \\n \" . format ( ** doc ) print ( report ) # Drop the index for consistency db . prizes . drop_index ( index_model )","title":"Recently single?"},{"location":"primer/04_MongoDB_part2/exercises/#born-and-affiliated","text":"Some countries are, for one or more laureates, both their country of birth (\"bornCountry\") and a country of affiliation for one or more of their prizes (\"prizes.affiliations.country\"). You will find the five countries of birth with the highest counts of such laureates. Create an index on country of birth (\"bornCountry\") for db.laureates to ensure efficient gathering of distinct values and counting of documents Complete the skeleton dictionary comprehension to construct n_born_and_affiliated , the count of laureates as described above for each distinct country of birth. from collections import Counter # Ensure an index on country of birth db . laureates . create_index ([( ____ , 1 )]) # Collect a count of laureates for each country of birth n_born_and_affiliated = { country : db . laureates . count_documents ({ ____ : ____ , \"prizes.affiliations.country\" : ____ }) for ____ in db . laureates . distinct ( \"bornCountry\" ) } five_most_common = Counter ( n_born_and_affiliated ) . most_common ( 5 ) print ( five_most_common ) # Drop the index for consistency db . laureates . drop_index ([( ____ , 1 )])","title":"Born and affiliated"},{"location":"primer/04_MongoDB_part2/exercises_solved/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); MongoDB Part 2 Exercise Solutions \u00b6 1: Working with Distinct Values, $elemMatch, and Regex \u00b6 from pymongo import MongoClient client = MongoClient () db = client . nobel Never from there, but sometimes there at last \u00b6 There are some recorded countries of death ( \"diedCountry\" ) that do not appear as a country of birth ( \"bornCountry\" ) for laureates. One such country is \"East Germany\". Return a set of all such countries as countries . # Countries recorded as countries of death but not as countries of birth countries = set ( db . laureates . distinct ( \"diedCountry\" )) - set ( db . laureates . distinct ( \"bornCountry\" )) print ( countries ) Countries of affiliation \u00b6 We saw in the last exercise that countries can be associated with a laureate as their country of birth and as their country of death. For each prize a laureate received, they may also have been affiliated with an institution at the time, located in a country. Determine the number of distinct countries recorded as part of an affiliation for laureates' prizes. Save this as count . # The number of distinct countries of laureate affiliation for prizes count = len ( db . laureates . distinct ( \"prizes.affiliations.country\" )) print ( count ) Triple plays (mostly) all around \u00b6 All prize categories but one \u2013 literature \u2013 have had prizes shared by three or more laureates. Save a filter document criteria that, when passed to db.prizes.distinct , returns all prize categories shared by three or more laureates. That is, \"laureates.2\" must exist for such documents. Save these prize categories as a Python set called triple_play_categories . Confirm via an assertion that \"literature\" is the only prize category with no prizes shared by three or more laureates. # Save a filter for prize documents with three or more laureates criteria = { \"laureates.2\" : { \"$exists\" : True }} # Save the set of distinct prize categories in documents satisfying the criteria triple_play_categories = set ( db . prizes . distinct ( \"category\" , criteria )) # Confirm literature as the only category not satisfying the criteria. assert set ( db . prizes . distinct ( \"category\" )) - triple_play_categories == { \"literature\" } Other sharing after World War II \u00b6 Similar to the example in the lesson, what is the approximate ratio of the number of laureates who won an unshared prize in categories other than physics, chemistry, and medicine after World War II to the number of laureates who won a shared prize in categories other than physics, chemistry, and medicine after World War II? Save an $elemMatch filter unshared to count laureates with unshared prizes in categories other than (\"not in\") [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. Save an $elemMatch filter shared to count laureates with shared (i.e., \"share\" is not \"1\") prizes in categories other than [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. # Save a filter for laureates with unshared prizes unshared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : { \"$nin\" : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : \"1\" , \"year\" : { \"$gt\" : \"1945\" }, }}} # Save a filter for laureates with shared prizes shared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : { \"$nin\" : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : { \"$gt\" : \"1\" }, \"year\" : { \"$gt\" : \"1945\" }, }}} ratio = db . laureates . count_documents ( unshared ) / db . laureates . count_documents ( shared ) print ( ratio ) Organizations and prizes over time \u00b6 How many organizations won prizes before 1945 versus in or after 1945? - Save a filter before to count organization laureates with prizes won before 1945. Recall that organization status is encoded with the \"gender\" field, and that dot notation is needed to access a laureate's \"year\" field within its \"prizes\" array. - Save a filter in_or_after to count organization laureates with prizes won in or after 1945. # Save a filter for organization laureates with prizes won before 1945 before = { \"gender\" : \"org\" , \"prizes.year\" : { \"$lt\" : \"1945\" } } # Save a filter for organization laureates with prizes won in or after 1945 in_or_after = { \"gender\" : \"org\" , \"prizes.year\" : { \"$gte\" : \"1945\" } } n_before = db . laureates . count_documents ( before ) n_in_or_after = db . laureates . count_documents ( in_or_after ) ratio = n_in_or_after / ( n_in_or_after + n_before ) print ( ratio ) Germany, then and now \u00b6 Just as we saw with Poland, there are laureates who were born somewhere that was in Germany at the time but is now not, and others born somewhere that was not in Germany at the time but now is. - Use a regular expression object to filter for laureates with \"Germany\" in their \"bornCountry\" value. # Filter for laureates with \"Germany\" in their \"bornCountry\" value criteria = { \"bornCountry\" : { \"$regex\" : \"Germany\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates with a \"bornCountry\" value starting with \"Germany\". # Filter for laureates with a \"bornCountry\" value starting with \"Germany\" criteria = { \"bornCountry\" : { \"$regex\" : \"^Germany\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what was at the time Germany but is now another country. # Fill in a string value to be sandwiched between the strings \"^\" and \"now\" criteria = { \"bornCountry\" : { \"$regex\" : \"^\" + \"Germany \\(\" + \"now\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what is now Germany but at the time was another country. # Filter for currently-Germany countries of birth. # Fill in a string value to be sandwiched between the strings \"now\" and \"$\" criteria = { \"bornCountry\" : { \"$regex\" : \"now\" + \" Germany\\)\" + \"$\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) The prized transistor \u00b6 Three people shared a Nobel prize \"for their researches on semiconductors and their discovery of the transistor effect\". We can filter on \"transistor\" as a substring of a laureate's \"prizes.motivation\" field value to find these laureates. Save a filter criteria that finds laureates with prizes.motivation values containing \"transistor\" as a substring. The substring can appear anywhere within the value, so no anchoring characters are needed. Save to first and last the field names corresponding to a laureate's first name and last name (i.e. \"surname\") so that we can print out the names of these laureates. # Save a filter for laureates with prize motivation values containing \"transistor\" as a substring criteria = { \"prizes.motivation\" : { \"$regex\" : \"transistor\" }} # Save the field names corresponding to a laureate's first name and last name first , last = \"firstname\" , \"surname\" print ([( laureate [ first ], laureate [ last ]) for laureate in db . laureates . find ( criteria )]) 2: Projection and Sorting \u00b6 Rounding up the G.S. crew \u00b6 We can use the regular expression operator $regex to find laureates whose initials are G.S. Let's use projection and list comprehension to collect the full names of these laureates by concatenating their first (\"firstname\") and last (\"surname\") names. Fill in the blanks to save a list names of full names (\"firstname\" plus \"surname\") of laureates with initials G.S. (ignoring middles names/initials). You'll need to both filter on names as well as project out the fields required to collect the full names. # Collect a list of full names names = [ \" \" . join ([ doc [ \"firstname\" ], doc [ \"surname\" ]]) for doc in db . laureates . find ( { \"firstname\" : { \"$regex\" : \"^G\" }, \"surname\" : { \"$regex\" : \"^S\" }}, { \"firstname\" : 1 , \"surname\" : 1 })] print ( names ) Sorting together: MongoDB + Python \u00b6 You will print out the names of all physics laureates, with one line printed for each award year, in chronological order. Each line will list laureates for that year in alphabetical order by surname (\"last\" name). I encourage you to print intermediate results and understand the nested structure of prize documents. - Construct a sort specification sort_spec to fetch physics prizes by ascending year. from operator import itemgetter # Sort by ascending year sort_spec = [( \"year\" , 1 )] - Use <collection>.find to construct a cursor that fetches prizes with a \"category\" of \"physics\", sorts by ascending year, and projects the year and first laureate full name ( laureates.firstname and laureates.surname ). You should encounter an error at year 1916 . # Construct a cursor over physics prizes cursor = db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - The error is caused by the fact that the Nobel Prize in physics was not awarded in 1916 due to World War I. Supplement the cursor's filter to avoid the error: # Construct a fixed cursor over physics prizes cursor = db . prizes . find ({ \"category\" : \"physics\" , \"laureates\" : { \"$exists\" : True }}, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - Complete the definition of the function names so that, given a prize document, it returns a list of formatted names, sorted by ascending \"surname\", for each of the \"laureates\" in that prize document. # Define a function names() to return a list of formatted names def names ( doc ): formatted_names = [ \" {firstname} {surname} \" . format ( ** laureate ) for laureate in sorted ( doc [ \"laureates\" ], key = itemgetter ( \"surname\" ))] return formatted_names lines = [ \" {year} : {names} \" . format ( year = doc [ \"year\" ], names = \" and \" . join ( names ( doc ))) for doc in cursor ] for line in lines : print ( line ) Gap years \u00b6 As we saw above, there have been years for which prizes in one or more of the original categories were not awarded. Sorting first by reverse chronological order and second by alphabetical order of category, collect and format prize documents to produce one formatted entry per year listing categories missing for that year. - Construct a set original_categories of prize categories awarded in 1901. import itertools from operator import itemgetter # Save the set of prize categories awarded in 1901 original_categories = set ( db . prizes . distinct ( \"category\" , { \"year\" : \"1901\" })) print ( original_categories ) - Use <collection>.find to construct a cursor that yields prize documents only for categories in the list of original categories which contain the laureates key and thus were awarded, sorted first by decreasing year and second by increasing category. # Construct a cursor over original-category prizes cursor = db . prizes . find ({ \"category\" : { \"$in\" : list ( original_categories )}, \"laureates\" : { \"$exists\" : True }}, { \"category\" : 1 , \"year\" : 1 }, sort = [( \"year\" , - 1 ), ( \"category\" , 1 )]) - Collect a list not_awarded of entries to be printed, one per line, that displays a year and the categories missing for that year. You will collect \"category\" values for each year and set-subtract them from the original categories. # Collect entries for missing prize categories not_awarded = [] for key , group in itertools . groupby ( cursor , key = itemgetter ( \"year\" )): year_categories = set ( prize [ \"category\" ] for prize in group ) missing = \", \" . join ( sorted ( original_categories - year_categories )) if missing : not_awarded . append ( \" {} : {} \" . format ( key , missing )) for line in not_awarded : print ( line ) 3: Indexing \u00b6 An index for high-share categories \u00b6 We want to speed up the following operation: db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) - Confirm that the operation takes approximately 1 ms without an index. %% timeit db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) - Specify a compound index model index_model to pass to db.prizes.create_index . index_model = [( \"laureates.share\" , 1 ), ( \"category\" , 1 )] db . prizes . create_index ( index_model ) - Confirm that the execution time is now below 400 \u00b5s. %% timeit db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) # Drop the index for consistency db . prizes . drop_index ( index_model ) Recently single? \u00b6 A prize might be awarded to a single laureate or to several. For each prize category, report the most recent year that a single laureate -- rather than several -- received a prize in that category. Specify an index model index_model to pass to db.prizes.create_index that speeds up finding prizes by category and sorting results by decreasing year. That is, the model should index first on category (ascending) and second on year (descending). Save a string report for printing the last single-laureate year for each distinct category, one category per line. To do this, for each distinct prize category, find the latest-year prize of that category with a laureate share of \"1\". # Specify an index model for compound sorting index_model = [( \"category\" , 1 ), ( \"year\" , - 1 )] db . prizes . create_index ( index_model ) # Collect the last single-laureate year for each category report = \"\" for category in sorted ( db . prizes . distinct ( \"category\" )): doc = db . prizes . find_one ( { \"category\" : category , \"laureates.share\" : \"1\" }, sort = [( \"year\" , - 1 )] ) report += \" {category} : {year} \\n \" . format ( ** doc ) print ( report ) # Drop the index for consistency db . prizes . drop_index ( index_model ) Born and affiliated \u00b6 Some countries are, for one or more laureates, both their country of birth (\"bornCountry\") and a country of affiliation for one or more of their prizes (\"prizes.affiliations.country\"). You will find the five countries of birth with the highest counts of such laureates. Create an index on country of birth (\"bornCountry\") for db.laureates to ensure efficient gathering of distinct values and counting of documents Complete the skeleton dictionary comprehension to construct n_born_and_affiliated , the count of laureates as described above for each distinct country of birth. from collections import Counter # Ensure an index on country of birth db . laureates . create_index ([( \"bornCountry\" , 1 )]) # Collect a count of laureates for each country of birth n_born_and_affiliated = { country : db . laureates . count_documents ({ \"bornCountry\" : country , \"prizes.affiliations.country\" : country }) for country in db . laureates . distinct ( \"bornCountry\" ) } five_most_common = Counter ( n_born_and_affiliated ) . most_common ( 5 ) print ( five_most_common ) # Drop the index for consistency db . laureates . drop_index ([( \"bornCountry\" , 1 )])","title":"Exercises solved"},{"location":"primer/04_MongoDB_part2/exercises_solved/#mongodb-part-2-exercise-solutions","text":"","title":"MongoDB Part 2 Exercise Solutions"},{"location":"primer/04_MongoDB_part2/exercises_solved/#1-working-with-distinct-values-elemmatch-and-regex","text":"from pymongo import MongoClient client = MongoClient () db = client . nobel","title":"1: Working with Distinct Values, $elemMatch, and Regex"},{"location":"primer/04_MongoDB_part2/exercises_solved/#never-from-there-but-sometimes-there-at-last","text":"There are some recorded countries of death ( \"diedCountry\" ) that do not appear as a country of birth ( \"bornCountry\" ) for laureates. One such country is \"East Germany\". Return a set of all such countries as countries . # Countries recorded as countries of death but not as countries of birth countries = set ( db . laureates . distinct ( \"diedCountry\" )) - set ( db . laureates . distinct ( \"bornCountry\" )) print ( countries )","title":"Never from there, but sometimes there at last"},{"location":"primer/04_MongoDB_part2/exercises_solved/#countries-of-affiliation","text":"We saw in the last exercise that countries can be associated with a laureate as their country of birth and as their country of death. For each prize a laureate received, they may also have been affiliated with an institution at the time, located in a country. Determine the number of distinct countries recorded as part of an affiliation for laureates' prizes. Save this as count . # The number of distinct countries of laureate affiliation for prizes count = len ( db . laureates . distinct ( \"prizes.affiliations.country\" )) print ( count )","title":"Countries of affiliation"},{"location":"primer/04_MongoDB_part2/exercises_solved/#triple-plays-mostly-all-around","text":"All prize categories but one \u2013 literature \u2013 have had prizes shared by three or more laureates. Save a filter document criteria that, when passed to db.prizes.distinct , returns all prize categories shared by three or more laureates. That is, \"laureates.2\" must exist for such documents. Save these prize categories as a Python set called triple_play_categories . Confirm via an assertion that \"literature\" is the only prize category with no prizes shared by three or more laureates. # Save a filter for prize documents with three or more laureates criteria = { \"laureates.2\" : { \"$exists\" : True }} # Save the set of distinct prize categories in documents satisfying the criteria triple_play_categories = set ( db . prizes . distinct ( \"category\" , criteria )) # Confirm literature as the only category not satisfying the criteria. assert set ( db . prizes . distinct ( \"category\" )) - triple_play_categories == { \"literature\" }","title":"Triple plays (mostly) all around"},{"location":"primer/04_MongoDB_part2/exercises_solved/#other-sharing-after-world-war-ii","text":"Similar to the example in the lesson, what is the approximate ratio of the number of laureates who won an unshared prize in categories other than physics, chemistry, and medicine after World War II to the number of laureates who won a shared prize in categories other than physics, chemistry, and medicine after World War II? Save an $elemMatch filter unshared to count laureates with unshared prizes in categories other than (\"not in\") [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. Save an $elemMatch filter shared to count laureates with shared (i.e., \"share\" is not \"1\") prizes in categories other than [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. # Save a filter for laureates with unshared prizes unshared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : { \"$nin\" : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : \"1\" , \"year\" : { \"$gt\" : \"1945\" }, }}} # Save a filter for laureates with shared prizes shared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : { \"$nin\" : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : { \"$gt\" : \"1\" }, \"year\" : { \"$gt\" : \"1945\" }, }}} ratio = db . laureates . count_documents ( unshared ) / db . laureates . count_documents ( shared ) print ( ratio )","title":"Other sharing after World War II"},{"location":"primer/04_MongoDB_part2/exercises_solved/#organizations-and-prizes-over-time","text":"How many organizations won prizes before 1945 versus in or after 1945? - Save a filter before to count organization laureates with prizes won before 1945. Recall that organization status is encoded with the \"gender\" field, and that dot notation is needed to access a laureate's \"year\" field within its \"prizes\" array. - Save a filter in_or_after to count organization laureates with prizes won in or after 1945. # Save a filter for organization laureates with prizes won before 1945 before = { \"gender\" : \"org\" , \"prizes.year\" : { \"$lt\" : \"1945\" } } # Save a filter for organization laureates with prizes won in or after 1945 in_or_after = { \"gender\" : \"org\" , \"prizes.year\" : { \"$gte\" : \"1945\" } } n_before = db . laureates . count_documents ( before ) n_in_or_after = db . laureates . count_documents ( in_or_after ) ratio = n_in_or_after / ( n_in_or_after + n_before ) print ( ratio )","title":"Organizations and prizes over time"},{"location":"primer/04_MongoDB_part2/exercises_solved/#germany-then-and-now","text":"Just as we saw with Poland, there are laureates who were born somewhere that was in Germany at the time but is now not, and others born somewhere that was not in Germany at the time but now is. - Use a regular expression object to filter for laureates with \"Germany\" in their \"bornCountry\" value. # Filter for laureates with \"Germany\" in their \"bornCountry\" value criteria = { \"bornCountry\" : { \"$regex\" : \"Germany\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates with a \"bornCountry\" value starting with \"Germany\". # Filter for laureates with a \"bornCountry\" value starting with \"Germany\" criteria = { \"bornCountry\" : { \"$regex\" : \"^Germany\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what was at the time Germany but is now another country. # Fill in a string value to be sandwiched between the strings \"^\" and \"now\" criteria = { \"bornCountry\" : { \"$regex\" : \"^\" + \"Germany \\(\" + \"now\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what is now Germany but at the time was another country. # Filter for currently-Germany countries of birth. # Fill in a string value to be sandwiched between the strings \"now\" and \"$\" criteria = { \"bornCountry\" : { \"$regex\" : \"now\" + \" Germany\\)\" + \"$\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria )))","title":"Germany, then and now"},{"location":"primer/04_MongoDB_part2/exercises_solved/#the-prized-transistor","text":"Three people shared a Nobel prize \"for their researches on semiconductors and their discovery of the transistor effect\". We can filter on \"transistor\" as a substring of a laureate's \"prizes.motivation\" field value to find these laureates. Save a filter criteria that finds laureates with prizes.motivation values containing \"transistor\" as a substring. The substring can appear anywhere within the value, so no anchoring characters are needed. Save to first and last the field names corresponding to a laureate's first name and last name (i.e. \"surname\") so that we can print out the names of these laureates. # Save a filter for laureates with prize motivation values containing \"transistor\" as a substring criteria = { \"prizes.motivation\" : { \"$regex\" : \"transistor\" }} # Save the field names corresponding to a laureate's first name and last name first , last = \"firstname\" , \"surname\" print ([( laureate [ first ], laureate [ last ]) for laureate in db . laureates . find ( criteria )])","title":"The prized transistor"},{"location":"primer/04_MongoDB_part2/exercises_solved/#2-projection-and-sorting","text":"","title":"2: Projection and Sorting"},{"location":"primer/04_MongoDB_part2/exercises_solved/#rounding-up-the-gs-crew","text":"We can use the regular expression operator $regex to find laureates whose initials are G.S. Let's use projection and list comprehension to collect the full names of these laureates by concatenating their first (\"firstname\") and last (\"surname\") names. Fill in the blanks to save a list names of full names (\"firstname\" plus \"surname\") of laureates with initials G.S. (ignoring middles names/initials). You'll need to both filter on names as well as project out the fields required to collect the full names. # Collect a list of full names names = [ \" \" . join ([ doc [ \"firstname\" ], doc [ \"surname\" ]]) for doc in db . laureates . find ( { \"firstname\" : { \"$regex\" : \"^G\" }, \"surname\" : { \"$regex\" : \"^S\" }}, { \"firstname\" : 1 , \"surname\" : 1 })] print ( names )","title":"Rounding up the G.S. crew"},{"location":"primer/04_MongoDB_part2/exercises_solved/#sorting-together-mongodb-python","text":"You will print out the names of all physics laureates, with one line printed for each award year, in chronological order. Each line will list laureates for that year in alphabetical order by surname (\"last\" name). I encourage you to print intermediate results and understand the nested structure of prize documents. - Construct a sort specification sort_spec to fetch physics prizes by ascending year. from operator import itemgetter # Sort by ascending year sort_spec = [( \"year\" , 1 )] - Use <collection>.find to construct a cursor that fetches prizes with a \"category\" of \"physics\", sorts by ascending year, and projects the year and first laureate full name ( laureates.firstname and laureates.surname ). You should encounter an error at year 1916 . # Construct a cursor over physics prizes cursor = db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - The error is caused by the fact that the Nobel Prize in physics was not awarded in 1916 due to World War I. Supplement the cursor's filter to avoid the error: # Construct a fixed cursor over physics prizes cursor = db . prizes . find ({ \"category\" : \"physics\" , \"laureates\" : { \"$exists\" : True }}, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - Complete the definition of the function names so that, given a prize document, it returns a list of formatted names, sorted by ascending \"surname\", for each of the \"laureates\" in that prize document. # Define a function names() to return a list of formatted names def names ( doc ): formatted_names = [ \" {firstname} {surname} \" . format ( ** laureate ) for laureate in sorted ( doc [ \"laureates\" ], key = itemgetter ( \"surname\" ))] return formatted_names lines = [ \" {year} : {names} \" . format ( year = doc [ \"year\" ], names = \" and \" . join ( names ( doc ))) for doc in cursor ] for line in lines : print ( line )","title":"Sorting together: MongoDB + Python"},{"location":"primer/04_MongoDB_part2/exercises_solved/#gap-years","text":"As we saw above, there have been years for which prizes in one or more of the original categories were not awarded. Sorting first by reverse chronological order and second by alphabetical order of category, collect and format prize documents to produce one formatted entry per year listing categories missing for that year. - Construct a set original_categories of prize categories awarded in 1901. import itertools from operator import itemgetter # Save the set of prize categories awarded in 1901 original_categories = set ( db . prizes . distinct ( \"category\" , { \"year\" : \"1901\" })) print ( original_categories ) - Use <collection>.find to construct a cursor that yields prize documents only for categories in the list of original categories which contain the laureates key and thus were awarded, sorted first by decreasing year and second by increasing category. # Construct a cursor over original-category prizes cursor = db . prizes . find ({ \"category\" : { \"$in\" : list ( original_categories )}, \"laureates\" : { \"$exists\" : True }}, { \"category\" : 1 , \"year\" : 1 }, sort = [( \"year\" , - 1 ), ( \"category\" , 1 )]) - Collect a list not_awarded of entries to be printed, one per line, that displays a year and the categories missing for that year. You will collect \"category\" values for each year and set-subtract them from the original categories. # Collect entries for missing prize categories not_awarded = [] for key , group in itertools . groupby ( cursor , key = itemgetter ( \"year\" )): year_categories = set ( prize [ \"category\" ] for prize in group ) missing = \", \" . join ( sorted ( original_categories - year_categories )) if missing : not_awarded . append ( \" {} : {} \" . format ( key , missing )) for line in not_awarded : print ( line )","title":"Gap years"},{"location":"primer/04_MongoDB_part2/exercises_solved/#3-indexing","text":"","title":"3: Indexing"},{"location":"primer/04_MongoDB_part2/exercises_solved/#an-index-for-high-share-categories","text":"We want to speed up the following operation: db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) - Confirm that the operation takes approximately 1 ms without an index. %% timeit db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) - Specify a compound index model index_model to pass to db.prizes.create_index . index_model = [( \"laureates.share\" , 1 ), ( \"category\" , 1 )] db . prizes . create_index ( index_model ) - Confirm that the execution time is now below 400 \u00b5s. %% timeit db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) # Drop the index for consistency db . prizes . drop_index ( index_model )","title":"An index for high-share categories"},{"location":"primer/04_MongoDB_part2/exercises_solved/#recently-single","text":"A prize might be awarded to a single laureate or to several. For each prize category, report the most recent year that a single laureate -- rather than several -- received a prize in that category. Specify an index model index_model to pass to db.prizes.create_index that speeds up finding prizes by category and sorting results by decreasing year. That is, the model should index first on category (ascending) and second on year (descending). Save a string report for printing the last single-laureate year for each distinct category, one category per line. To do this, for each distinct prize category, find the latest-year prize of that category with a laureate share of \"1\". # Specify an index model for compound sorting index_model = [( \"category\" , 1 ), ( \"year\" , - 1 )] db . prizes . create_index ( index_model ) # Collect the last single-laureate year for each category report = \"\" for category in sorted ( db . prizes . distinct ( \"category\" )): doc = db . prizes . find_one ( { \"category\" : category , \"laureates.share\" : \"1\" }, sort = [( \"year\" , - 1 )] ) report += \" {category} : {year} \\n \" . format ( ** doc ) print ( report ) # Drop the index for consistency db . prizes . drop_index ( index_model )","title":"Recently single?"},{"location":"primer/04_MongoDB_part2/exercises_solved/#born-and-affiliated","text":"Some countries are, for one or more laureates, both their country of birth (\"bornCountry\") and a country of affiliation for one or more of their prizes (\"prizes.affiliations.country\"). You will find the five countries of birth with the highest counts of such laureates. Create an index on country of birth (\"bornCountry\") for db.laureates to ensure efficient gathering of distinct values and counting of documents Complete the skeleton dictionary comprehension to construct n_born_and_affiliated , the count of laureates as described above for each distinct country of birth. from collections import Counter # Ensure an index on country of birth db . laureates . create_index ([( \"bornCountry\" , 1 )]) # Collect a count of laureates for each country of birth n_born_and_affiliated = { country : db . laureates . count_documents ({ \"bornCountry\" : country , \"prizes.affiliations.country\" : country }) for country in db . laureates . distinct ( \"bornCountry\" ) } five_most_common = Counter ( n_born_and_affiliated ) . most_common ( 5 ) print ( five_most_common ) # Drop the index for consistency db . laureates . drop_index ([( \"bornCountry\" , 1 )])","title":"Born and affiliated"},{"location":"primer/04_MongoDB_part2/lesson/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); MongoDB Part 2 \u00b6 1: Working with Distinct Values, $elemMatch, and Regex \u00b6 An exceptional laureate \u00b6 from pymongo import MongoClient client = MongoClient () db = client . nobel db . laureates . find_one ({ \"prizes.2\" : { \"$exists\" : True }}) {'_id': ObjectId('5f1f4e418defad6d9f1cd070'), 'id': '482', 'firstname': 'International Committee of the Red Cross', 'born': '1863-00-00', 'died': '0000-00-00', 'gender': 'org', 'prizes': [{'year': '1917', 'category': 'peace', 'share': '1', 'motivation': '\"for the efforts to take care of wounded soldiers and prisoners of war and their families\"', 'affiliations': [[]]}, {'year': '1944', 'category': 'peace', 'share': '1', 'motivation': '\"for the great work it has performed during the war on behalf of humanity\"', 'affiliations': [[]]}, {'year': '1963', 'category': 'peace', 'share': '2', 'motivation': '\"for promoting the principles of the Geneva Convention and cooperation with the UN\"', 'affiliations': [[]]}]} Using .distinct() \u00b6 db . laureates . distinct ( \"gender\" ) ['female', 'male', 'org'] A convenience method for a common aggregation (like count_documents ) We will not cover custom aggregations in this lesson, but the aggregate method is powerful. distinct aggregation is efficient if there is a collection index on the field We will learn how to create an index later in this lesson No index needed here: collection fits in memory, has \u2272 1,000 documents All prize categories vs those with multi-winners \u00b6 db . laureates . distinct ( \"prizes.category\" ) ['chemistry', 'economics', 'literature', 'medicine', 'peace', 'physics'] db . laureates . distinct ( \"prizes.category\" ,{ \"prizes.1\" : { \"$exists\" : True }}) ['chemistry', 'peace', 'physics'] Distinct example: Born here, went there \u00b6 In which countries have USA-born laureates had affiliations for their prizes? db . laureates . distinct ( \"prizes.affiliations.country\" ,{ \"bornCountry\" : \"USA\" }) ['Australia', 'Denmark', 'USA', 'United Kingdom'] Enter $elemMatch \u00b6 db . laureates . count_documents ({ \"prizes\" : { \"category\" : \"physics\" , \"share\" : \"1\" } }) 0 Why is the above number zero? db . laureates . count_documents ({ \"prizes.category\" : \"physics\" , \"prizes.share\" : \"1\" }) 48 db . laureates . count_documents ({ \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"share\" : \"1\" } } }) 47 Why are these numbers different? db . laureates . find_one ({ \"firstname\" : \"Marie\" }) {'_id': ObjectId('5f1f4e418defad6d9f1cce9a'), 'id': '6', 'firstname': 'Marie', 'surname': 'Curie', 'born': '1867-11-07', 'died': '1934-07-04', 'bornCountry': 'Russian Empire (now Poland)', 'bornCountryCode': 'PL', 'bornCity': 'Warsaw', 'diedCountry': 'France', 'diedCountryCode': 'FR', 'diedCity': 'Sallanches', 'gender': 'female', 'prizes': [{'year': '1903', 'category': 'physics', 'share': '4', 'motivation': '\"in recognition of the extraordinary services they have rendered by their joint researches on the radiation phenomena discovered by Professor Henri Becquerel\"', 'affiliations': [[]]}, {'year': '1911', 'category': 'chemistry', 'share': '1', 'motivation': '\"in recognition of her services to the advancement of chemistry by the discovery of the elements radium and polonium, by the isolation of radium and the study of the nature and compounds of this remarkable element\"', 'affiliations': [{'name': 'Sorbonne University', 'city': 'Paris', 'country': 'France'}]}]} $elemMatch example: Sharing in physics after World War II \u00b6 What is the approximate ratio of the number of laureates who won an unshared , i.e. {\"share\": \"1\"} , prize in physics after World War II, i.e. {\"year\": {\"$gte\": \"1945\"}} , to the number of laureates who won a shared prize in physics after World War II? # Save a filter for laureates with unshared prizes unshared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"share\" : \"1\" , \"year\" : { \"$gte\" : \"1945\" }, }}} # Save a filter for laureates with shared prizes shared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"share\" : { \"$gt\" : \"1\" }, \"year\" : { \"$gte\" : \"1945\" }, }}} ratio = db . laureates . count_documents ( unshared ) / db . laureates . count_documents ( shared ) print ( ratio ) 0.1232876712328767 Finding a substring with $regex \u00b6 db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"Poland\" }}) ['Austria-Hungary (now Poland)', 'Free City of Danzig (now Poland)', 'German-occupied Poland (now Poland)', 'Germany (now Poland)', 'Poland', 'Poland (now Belarus)', 'Poland (now Lithuania)', 'Poland (now Ukraine)', 'Prussia (now Poland)', 'Russian Empire (now Poland)'] Beginning and ending \u00b6 db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"^Poland\" }}) ['Poland', 'Poland (now Belarus)', 'Poland (now Lithuania)', 'Poland (now Ukraine)'] db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"^Poland \\(now\" }}) ['Poland (now Belarus)', 'Poland (now Lithuania)', 'Poland (now Ukraine)'] db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"now Poland\\)$\" }}) ['Austria-Hungary (now Poland)', 'Free City of Danzig (now Poland)', 'German-occupied Poland (now Poland)', 'Germany (now Poland)', 'Prussia (now Poland)', 'Russian Empire (now Poland)'] Regex example: Glenn, George, and others in the G.S. crew \u00b6 There are two laureates with Berkeley, California as a prize affiliation city that have the initials G.S. - Glenn Seaborg and George Smoot. How many laureates in total have a first name beginning with \"G\" and a surname beginning with \"S\"? db . laureates . count_documents ({ \"firstname\" : { \"$regex\" : \"^G\" }, \"surname\" : { \"$regex\" : \"^S\" }}) 10 2: Projection and Sorting \u00b6 What is \"projection\"? \u00b6 reducing data to fewer dimensions Asking certain data to \"speak up\"! Projection in MongoDB \u00b6 When using db.collection.find() , the first argument is the filter and the second is the projection. db . laureates . find ({}, {}) <pymongo.cursor.Cursor at 0x7f8360632850> Since db.collection.find() returns a cursor, we need to make it into a list: list ( db . laureates . find ({},{}))[: 3 ] [{'_id': ObjectId('5f1f4e418defad6d9f1cce95')}, {'_id': ObjectId('5f1f4e418defad6d9f1cce96')}, {'_id': ObjectId('5f1f4e418defad6d9f1cce97')}] An empty projection dictionary by default only displays the entry \"_id\" field. To project out the prizes.affiliation field without the \"_id\" field, we would use a projection equal to {\"prizes.affiliations\": 1, \"_id\": 0} . list ( db . laureates . find ({},{ \"prizes.affiliations\" : 1 , \"_id\" : 0 }))[: 3 ] [{'prizes': [{'affiliations': [{'name': 'Munich University', 'city': 'Munich', 'country': 'Germany'}]}]}, {'prizes': [{'affiliations': [{'name': 'Leiden University', 'city': 'Leiden', 'country': 'the Netherlands'}]}]}, {'prizes': [{'affiliations': [{'name': 'Amsterdam University', 'city': 'Amsterdam', 'country': 'the Netherlands'}]}]}] where the 1 value turns on \"prizes.affiliations\" and the 0 value turns off \"_id\" . Missing fields \u00b6 list ( db . laureates . find ({ \"gender\" : \"org\" }, { \"firstname\" : 1 , \"born\" : 1 , \"_id\" : 0 })) [{'firstname': 'Institute of International Law', 'born': '1873-00-00'}, {'firstname': 'Permanent International Peace Bureau', 'born': '1891-00-00'}, {'firstname': 'International Committee of the Red Cross', 'born': '1863-00-00'}, {'firstname': 'Nansen International Office for Refugees', 'born': '1921-00-00'}, {'firstname': 'Friends Service Council', 'born': '1647-00-00'}, {'firstname': 'American Friends Service Committee', 'born': '1917-00-00'}, {'firstname': 'Office of the United Nations High Commissioner for Refugees', 'born': '1951-00-00'}, {'firstname': 'League of Red Cross Societies', 'born': '1919-00-00'}, {'firstname': \"United Nations Children's Fund\", 'born': '1946-00-00'}, {'firstname': 'International Labour Organization', 'born': '1919-00-00'}, {'firstname': 'Amnesty International', 'born': '1961-00-00'}, {'firstname': 'International Physicians for the Prevention of Nuclear War', 'born': '1980-00-00'}, {'firstname': 'United Nations Peacekeeping Forces', 'born': '1948-00-00'}, {'firstname': 'Pugwash Conferences on Science and World Affairs', 'born': '1957-00-00'}, {'firstname': 'International Campaign to Ban Landmines', 'born': '1992-00-00'}, {'firstname': 'M\u00e9decins Sans Fronti\u00e8res', 'born': '1971-00-00'}, {'firstname': 'United Nations', 'born': '1945-00-00'}, {'firstname': 'International Atomic Energy Agency', 'born': '1957-00-00'}, {'firstname': 'Grameen Bank', 'born': '1976-00-00'}, {'firstname': 'Intergovernmental Panel on Climate Change', 'born': '1988-00-00'}, {'firstname': 'European Union (EU)', 'born': '1952-00-00'}, {'firstname': 'Organisation for the Prohibition of Chemical Weapons', 'born': '1997-00-00'}, {'firstname': 'National Dialogue Quartet '}, {'firstname': 'International Campaign to Abolish Nuclear Weapons (ICAN)', 'born': '2007-00-00'}] Projection example: Shares of the 1963 prize in physics \u00b6 Let's examine the laureates of the 1963 prize in physics and how they split the prize. Here is a query without projection: db . laureates . find ({ \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"year\" : \"1963\" }}}) How would we fetch the laureates' full names and prize share info? projection = { \"firstname\" : 1 , \"surname\" : 1 , \"prizes.share\" : 1 , \"_id\" : 0 } list ( db . laureates . find ({ \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"year\" : \"1963\" }}}, projection )) [{'firstname': 'Eugene', 'surname': 'Wigner', 'prizes': [{'share': '2'}]}, {'firstname': 'Maria', 'surname': 'Goeppert Mayer', 'prizes': [{'share': '4'}]}, {'firstname': 'J. Hans D.', 'surname': 'Jensen', 'prizes': [{'share': '4'}]}] Sorting post-query with Python \u00b6 from operator import itemgetter docs = list ( db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 })) docs = sorted ( docs , key = itemgetter ( \"year\" )) print ([ doc [ \"year\" ] for doc in docs ][: 5 ]) ['1901', '1902', '1903', '1904', '1905'] docs = sorted ( docs , key = itemgetter ( \"year\" ), reverse = True ) print ([ doc [ \"year\" ] for doc in docs ][: 5 ]) ['2019', '2018', '2017', '2016', '2015'] Sorting in-query with MongoDB \u00b6 cursor = db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 }, sort = [( \"year\" , 1 )]) print ([ doc [ \"year\" ] for doc in cursor ][: 5 ]) ['1901', '1902', '1903', '1904', '1905'] cursor = db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 }, sort = [( \"year\" , - 1 )]) print ([ doc [ \"year\" ] for doc in cursor ][: 5 ]) ['2019', '2018', '2017', '2016', '2015'] Primary and secondary sorting \u00b6 for doc in db . prizes . find ( { \"year\" : { \"$gt\" : \"1966\" , \"$lt\" : \"1970\" }}, { \"category\" : 1 , \"year\" : 1 , \"_id\" : 0 }, sort = [( \"year\" , 1 ), ( \"category\" , - 1 )]): print ( doc [ \"year\" ], doc [ \"category\" ]) 1967 physics 1967 peace 1967 medicine 1967 literature 1967 chemistry 1968 physics 1968 peace 1968 medicine 1968 literature 1968 chemistry 1969 physics 1969 peace 1969 medicine 1969 literature 1969 economics 1969 chemistry Sorting example: What the sort? \u00b6 This block prints out the first five projections of a sorted query. What \"sort\" argument fills the blank? docs = list ( db . laureates . find ( { \"born\" : { \"$gte\" : \"1900\" }, \"prizes.year\" : { \"$gte\" : \"1954\" }, \"gender\" :{ \"$in\" :[ \"male\" , \"female\" ]}}, { \"born\" : 1 , \"prizes.year\" : 1 , \"_id\" : 0 }, sort = ____ )) for doc in docs [: 5 ]: print ( doc ) {'born': '1916-08-25', 'prizes': [{'year': '1954'}]} {'born': '1915-06-15', 'prizes': [{'year': '1954'}]} {'born': '1901-02-28', 'prizes': [{'year': '1954'}, {'year': '1962'}]} {'born': '1913-07-12', 'prizes': [{'year': '1955'}]} {'born': '1911-01-26', 'prizes': [{'year': '1955'}]} Primary sorting is ascending by \"prizes.year\" . Secondary sort is descending by \"born\" . Thus, sort= [(\"prizes.year\",1),(\"born\",-1)] . my_sort = [( \"prizes.year\" , 1 ),( \"born\" , - 1 )] docs = list ( db . laureates . find ( { \"born\" : { \"$gte\" : \"1900\" }, \"prizes.year\" : { \"$gte\" : \"1954\" }, \"gender\" :{ \"$in\" :[ \"male\" , \"female\" ]}}, { \"born\" : 1 , \"prizes.year\" : 1 , \"_id\" : 0 }, sort = my_sort )) for doc in docs [: 5 ]: print ( doc ) {'born': '1916-08-25', 'prizes': [{'year': '1954'}]} {'born': '1915-06-15', 'prizes': [{'year': '1954'}]} {'born': '1901-02-28', 'prizes': [{'year': '1962'}, {'year': '1954'}]} {'born': '1913-07-12', 'prizes': [{'year': '1955'}]} {'born': '1911-01-26', 'prizes': [{'year': '1955'}]} 3: Indexing \u00b6 What are indexes? \u00b6 When to use indexes? \u00b6 Queries with high specificity Large documents Large collections Getting index information \u00b6 db . prizes . index_information () {'_id_': {'v': 2, 'key': [('_id', 1)], 'ns': 'nobel.prizes'}} Gauging performance before indexing \u00b6 Jupyter Notebook %%timeit magic (same as python -m timeit \"[expression]\" ) %% timeit docs = list ( db . prizes . find ({ \"year\" : \"1901\" })) 577 \u00b5s \u00b1 22.4 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , 1 )])) 5 ms \u00b1 269 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , - 1 )])) 4.79 ms \u00b1 400 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) Adding a single-field index \u00b6 * index model: list of (field, direction) pairs. * directions: 1 (ascending) and -1 (descending) db . prizes . create_index ([( \"year\" , 1 )]) 'year_1' db . prizes . index_information () {'_id_': {'v': 2, 'key': [('_id', 1)], 'ns': 'nobel.prizes'}, 'year_1': {'v': 2, 'key': [('year', 1)], 'ns': 'nobel.prizes'}} %% timeit docs = list ( db . prizes . find ({ \"year\" : \"1901\" })) 330 \u00b5s \u00b1 12.1 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , 1 )])) 3.89 ms \u00b1 122 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , - 1 )])) 4.07 ms \u00b1 122 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) db . prizes . drop_index ([( \"year\" , 1 )]) db . prizes . create_index ([( \"year\" , - 1 )]) 'year_-1' %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , - 1 )])) 4.36 ms \u00b1 249 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) db . prizes . drop_index ([( \"year\" , - 1 )]) Adding a compound (multiple-field) index \u00b6 index \"covering\" a query with projection %% timeit list ( db . prizes . find ({ \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 })) 620 \u00b5s \u00b1 3.05 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . create_index ([( \"category\" , 1 ), ( \"year\" , 1 )]) 'category_1_year_1' %% timeit list ( db . prizes . find ({ \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 })) 435 \u00b5s \u00b1 12.3 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . drop_index ([( \"category\" , 1 ), ( \"year\" , 1 )]) * index \"covering\" a query with projection and sorting %% timeit db . prizes . find_one ( { \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 }, sort = [( \"year\" , 1 )] ) 698 \u00b5s \u00b1 62.2 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . create_index ([( \"category\" , 1 ), ( \"year\" , 1 )]) 'category_1_year_1' %% timeit db . prizes . find_one ( { \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 }, sort = [( \"year\" , 1 )] ) 504 \u00b5s \u00b1 17.7 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . drop_index ([( \"category\" , 1 ), ( \"year\" , 1 )])","title":"Advanced MongoDB"},{"location":"primer/04_MongoDB_part2/lesson/#mongodb-part-2","text":"","title":"MongoDB Part 2"},{"location":"primer/04_MongoDB_part2/lesson/#1-working-with-distinct-values-elemmatch-and-regex","text":"","title":"1: Working with Distinct Values, $elemMatch, and Regex"},{"location":"primer/04_MongoDB_part2/lesson/#an-exceptional-laureate","text":"from pymongo import MongoClient client = MongoClient () db = client . nobel db . laureates . find_one ({ \"prizes.2\" : { \"$exists\" : True }}) {'_id': ObjectId('5f1f4e418defad6d9f1cd070'), 'id': '482', 'firstname': 'International Committee of the Red Cross', 'born': '1863-00-00', 'died': '0000-00-00', 'gender': 'org', 'prizes': [{'year': '1917', 'category': 'peace', 'share': '1', 'motivation': '\"for the efforts to take care of wounded soldiers and prisoners of war and their families\"', 'affiliations': [[]]}, {'year': '1944', 'category': 'peace', 'share': '1', 'motivation': '\"for the great work it has performed during the war on behalf of humanity\"', 'affiliations': [[]]}, {'year': '1963', 'category': 'peace', 'share': '2', 'motivation': '\"for promoting the principles of the Geneva Convention and cooperation with the UN\"', 'affiliations': [[]]}]}","title":"An exceptional laureate"},{"location":"primer/04_MongoDB_part2/lesson/#using-distinct","text":"db . laureates . distinct ( \"gender\" ) ['female', 'male', 'org'] A convenience method for a common aggregation (like count_documents ) We will not cover custom aggregations in this lesson, but the aggregate method is powerful. distinct aggregation is efficient if there is a collection index on the field We will learn how to create an index later in this lesson No index needed here: collection fits in memory, has \u2272 1,000 documents","title":"Using .distinct()"},{"location":"primer/04_MongoDB_part2/lesson/#all-prize-categories-vs-those-with-multi-winners","text":"db . laureates . distinct ( \"prizes.category\" ) ['chemistry', 'economics', 'literature', 'medicine', 'peace', 'physics'] db . laureates . distinct ( \"prizes.category\" ,{ \"prizes.1\" : { \"$exists\" : True }}) ['chemistry', 'peace', 'physics']","title":"All prize categories vs those with multi-winners"},{"location":"primer/04_MongoDB_part2/lesson/#distinct-example-born-here-went-there","text":"In which countries have USA-born laureates had affiliations for their prizes? db . laureates . distinct ( \"prizes.affiliations.country\" ,{ \"bornCountry\" : \"USA\" }) ['Australia', 'Denmark', 'USA', 'United Kingdom']","title":"Distinct example: Born here, went there"},{"location":"primer/04_MongoDB_part2/lesson/#enter-elemmatch","text":"db . laureates . count_documents ({ \"prizes\" : { \"category\" : \"physics\" , \"share\" : \"1\" } }) 0 Why is the above number zero? db . laureates . count_documents ({ \"prizes.category\" : \"physics\" , \"prizes.share\" : \"1\" }) 48 db . laureates . count_documents ({ \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"share\" : \"1\" } } }) 47 Why are these numbers different? db . laureates . find_one ({ \"firstname\" : \"Marie\" }) {'_id': ObjectId('5f1f4e418defad6d9f1cce9a'), 'id': '6', 'firstname': 'Marie', 'surname': 'Curie', 'born': '1867-11-07', 'died': '1934-07-04', 'bornCountry': 'Russian Empire (now Poland)', 'bornCountryCode': 'PL', 'bornCity': 'Warsaw', 'diedCountry': 'France', 'diedCountryCode': 'FR', 'diedCity': 'Sallanches', 'gender': 'female', 'prizes': [{'year': '1903', 'category': 'physics', 'share': '4', 'motivation': '\"in recognition of the extraordinary services they have rendered by their joint researches on the radiation phenomena discovered by Professor Henri Becquerel\"', 'affiliations': [[]]}, {'year': '1911', 'category': 'chemistry', 'share': '1', 'motivation': '\"in recognition of her services to the advancement of chemistry by the discovery of the elements radium and polonium, by the isolation of radium and the study of the nature and compounds of this remarkable element\"', 'affiliations': [{'name': 'Sorbonne University', 'city': 'Paris', 'country': 'France'}]}]}","title":"Enter $elemMatch"},{"location":"primer/04_MongoDB_part2/lesson/#elemmatch-example-sharing-in-physics-after-world-war-ii","text":"What is the approximate ratio of the number of laureates who won an unshared , i.e. {\"share\": \"1\"} , prize in physics after World War II, i.e. {\"year\": {\"$gte\": \"1945\"}} , to the number of laureates who won a shared prize in physics after World War II? # Save a filter for laureates with unshared prizes unshared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"share\" : \"1\" , \"year\" : { \"$gte\" : \"1945\" }, }}} # Save a filter for laureates with shared prizes shared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"share\" : { \"$gt\" : \"1\" }, \"year\" : { \"$gte\" : \"1945\" }, }}} ratio = db . laureates . count_documents ( unshared ) / db . laureates . count_documents ( shared ) print ( ratio ) 0.1232876712328767","title":"$elemMatch example: Sharing in physics after World War II"},{"location":"primer/04_MongoDB_part2/lesson/#finding-a-substring-with-regex","text":"db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"Poland\" }}) ['Austria-Hungary (now Poland)', 'Free City of Danzig (now Poland)', 'German-occupied Poland (now Poland)', 'Germany (now Poland)', 'Poland', 'Poland (now Belarus)', 'Poland (now Lithuania)', 'Poland (now Ukraine)', 'Prussia (now Poland)', 'Russian Empire (now Poland)']","title":"Finding a substring with $regex"},{"location":"primer/04_MongoDB_part2/lesson/#beginning-and-ending","text":"db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"^Poland\" }}) ['Poland', 'Poland (now Belarus)', 'Poland (now Lithuania)', 'Poland (now Ukraine)'] db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"^Poland \\(now\" }}) ['Poland (now Belarus)', 'Poland (now Lithuania)', 'Poland (now Ukraine)'] db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"now Poland\\)$\" }}) ['Austria-Hungary (now Poland)', 'Free City of Danzig (now Poland)', 'German-occupied Poland (now Poland)', 'Germany (now Poland)', 'Prussia (now Poland)', 'Russian Empire (now Poland)']","title":"Beginning and ending"},{"location":"primer/04_MongoDB_part2/lesson/#regex-example-glenn-george-and-others-in-the-gs-crew","text":"There are two laureates with Berkeley, California as a prize affiliation city that have the initials G.S. - Glenn Seaborg and George Smoot. How many laureates in total have a first name beginning with \"G\" and a surname beginning with \"S\"? db . laureates . count_documents ({ \"firstname\" : { \"$regex\" : \"^G\" }, \"surname\" : { \"$regex\" : \"^S\" }}) 10","title":"Regex example: Glenn, George, and others in the G.S. crew"},{"location":"primer/04_MongoDB_part2/lesson/#2-projection-and-sorting","text":"","title":"2: Projection and Sorting"},{"location":"primer/04_MongoDB_part2/lesson/#what-is-projection","text":"reducing data to fewer dimensions Asking certain data to \"speak up\"!","title":"What is \"projection\"?"},{"location":"primer/04_MongoDB_part2/lesson/#projection-in-mongodb","text":"When using db.collection.find() , the first argument is the filter and the second is the projection. db . laureates . find ({}, {}) <pymongo.cursor.Cursor at 0x7f8360632850> Since db.collection.find() returns a cursor, we need to make it into a list: list ( db . laureates . find ({},{}))[: 3 ] [{'_id': ObjectId('5f1f4e418defad6d9f1cce95')}, {'_id': ObjectId('5f1f4e418defad6d9f1cce96')}, {'_id': ObjectId('5f1f4e418defad6d9f1cce97')}] An empty projection dictionary by default only displays the entry \"_id\" field. To project out the prizes.affiliation field without the \"_id\" field, we would use a projection equal to {\"prizes.affiliations\": 1, \"_id\": 0} . list ( db . laureates . find ({},{ \"prizes.affiliations\" : 1 , \"_id\" : 0 }))[: 3 ] [{'prizes': [{'affiliations': [{'name': 'Munich University', 'city': 'Munich', 'country': 'Germany'}]}]}, {'prizes': [{'affiliations': [{'name': 'Leiden University', 'city': 'Leiden', 'country': 'the Netherlands'}]}]}, {'prizes': [{'affiliations': [{'name': 'Amsterdam University', 'city': 'Amsterdam', 'country': 'the Netherlands'}]}]}] where the 1 value turns on \"prizes.affiliations\" and the 0 value turns off \"_id\" .","title":"Projection in MongoDB"},{"location":"primer/04_MongoDB_part2/lesson/#missing-fields","text":"list ( db . laureates . find ({ \"gender\" : \"org\" }, { \"firstname\" : 1 , \"born\" : 1 , \"_id\" : 0 })) [{'firstname': 'Institute of International Law', 'born': '1873-00-00'}, {'firstname': 'Permanent International Peace Bureau', 'born': '1891-00-00'}, {'firstname': 'International Committee of the Red Cross', 'born': '1863-00-00'}, {'firstname': 'Nansen International Office for Refugees', 'born': '1921-00-00'}, {'firstname': 'Friends Service Council', 'born': '1647-00-00'}, {'firstname': 'American Friends Service Committee', 'born': '1917-00-00'}, {'firstname': 'Office of the United Nations High Commissioner for Refugees', 'born': '1951-00-00'}, {'firstname': 'League of Red Cross Societies', 'born': '1919-00-00'}, {'firstname': \"United Nations Children's Fund\", 'born': '1946-00-00'}, {'firstname': 'International Labour Organization', 'born': '1919-00-00'}, {'firstname': 'Amnesty International', 'born': '1961-00-00'}, {'firstname': 'International Physicians for the Prevention of Nuclear War', 'born': '1980-00-00'}, {'firstname': 'United Nations Peacekeeping Forces', 'born': '1948-00-00'}, {'firstname': 'Pugwash Conferences on Science and World Affairs', 'born': '1957-00-00'}, {'firstname': 'International Campaign to Ban Landmines', 'born': '1992-00-00'}, {'firstname': 'M\u00e9decins Sans Fronti\u00e8res', 'born': '1971-00-00'}, {'firstname': 'United Nations', 'born': '1945-00-00'}, {'firstname': 'International Atomic Energy Agency', 'born': '1957-00-00'}, {'firstname': 'Grameen Bank', 'born': '1976-00-00'}, {'firstname': 'Intergovernmental Panel on Climate Change', 'born': '1988-00-00'}, {'firstname': 'European Union (EU)', 'born': '1952-00-00'}, {'firstname': 'Organisation for the Prohibition of Chemical Weapons', 'born': '1997-00-00'}, {'firstname': 'National Dialogue Quartet '}, {'firstname': 'International Campaign to Abolish Nuclear Weapons (ICAN)', 'born': '2007-00-00'}]","title":"Missing fields"},{"location":"primer/04_MongoDB_part2/lesson/#projection-example-shares-of-the-1963-prize-in-physics","text":"Let's examine the laureates of the 1963 prize in physics and how they split the prize. Here is a query without projection: db . laureates . find ({ \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"year\" : \"1963\" }}}) How would we fetch the laureates' full names and prize share info? projection = { \"firstname\" : 1 , \"surname\" : 1 , \"prizes.share\" : 1 , \"_id\" : 0 } list ( db . laureates . find ({ \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"year\" : \"1963\" }}}, projection )) [{'firstname': 'Eugene', 'surname': 'Wigner', 'prizes': [{'share': '2'}]}, {'firstname': 'Maria', 'surname': 'Goeppert Mayer', 'prizes': [{'share': '4'}]}, {'firstname': 'J. Hans D.', 'surname': 'Jensen', 'prizes': [{'share': '4'}]}]","title":"Projection example: Shares of the 1963 prize in physics"},{"location":"primer/04_MongoDB_part2/lesson/#sorting-post-query-with-python","text":"from operator import itemgetter docs = list ( db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 })) docs = sorted ( docs , key = itemgetter ( \"year\" )) print ([ doc [ \"year\" ] for doc in docs ][: 5 ]) ['1901', '1902', '1903', '1904', '1905'] docs = sorted ( docs , key = itemgetter ( \"year\" ), reverse = True ) print ([ doc [ \"year\" ] for doc in docs ][: 5 ]) ['2019', '2018', '2017', '2016', '2015']","title":"Sorting post-query with Python"},{"location":"primer/04_MongoDB_part2/lesson/#sorting-in-query-with-mongodb","text":"cursor = db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 }, sort = [( \"year\" , 1 )]) print ([ doc [ \"year\" ] for doc in cursor ][: 5 ]) ['1901', '1902', '1903', '1904', '1905'] cursor = db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 }, sort = [( \"year\" , - 1 )]) print ([ doc [ \"year\" ] for doc in cursor ][: 5 ]) ['2019', '2018', '2017', '2016', '2015']","title":"Sorting in-query with MongoDB"},{"location":"primer/04_MongoDB_part2/lesson/#primary-and-secondary-sorting","text":"for doc in db . prizes . find ( { \"year\" : { \"$gt\" : \"1966\" , \"$lt\" : \"1970\" }}, { \"category\" : 1 , \"year\" : 1 , \"_id\" : 0 }, sort = [( \"year\" , 1 ), ( \"category\" , - 1 )]): print ( doc [ \"year\" ], doc [ \"category\" ]) 1967 physics 1967 peace 1967 medicine 1967 literature 1967 chemistry 1968 physics 1968 peace 1968 medicine 1968 literature 1968 chemistry 1969 physics 1969 peace 1969 medicine 1969 literature 1969 economics 1969 chemistry","title":"Primary and secondary sorting"},{"location":"primer/04_MongoDB_part2/lesson/#sorting-example-what-the-sort","text":"This block prints out the first five projections of a sorted query. What \"sort\" argument fills the blank? docs = list ( db . laureates . find ( { \"born\" : { \"$gte\" : \"1900\" }, \"prizes.year\" : { \"$gte\" : \"1954\" }, \"gender\" :{ \"$in\" :[ \"male\" , \"female\" ]}}, { \"born\" : 1 , \"prizes.year\" : 1 , \"_id\" : 0 }, sort = ____ )) for doc in docs [: 5 ]: print ( doc ) {'born': '1916-08-25', 'prizes': [{'year': '1954'}]} {'born': '1915-06-15', 'prizes': [{'year': '1954'}]} {'born': '1901-02-28', 'prizes': [{'year': '1954'}, {'year': '1962'}]} {'born': '1913-07-12', 'prizes': [{'year': '1955'}]} {'born': '1911-01-26', 'prizes': [{'year': '1955'}]} Primary sorting is ascending by \"prizes.year\" . Secondary sort is descending by \"born\" . Thus, sort= [(\"prizes.year\",1),(\"born\",-1)] . my_sort = [( \"prizes.year\" , 1 ),( \"born\" , - 1 )] docs = list ( db . laureates . find ( { \"born\" : { \"$gte\" : \"1900\" }, \"prizes.year\" : { \"$gte\" : \"1954\" }, \"gender\" :{ \"$in\" :[ \"male\" , \"female\" ]}}, { \"born\" : 1 , \"prizes.year\" : 1 , \"_id\" : 0 }, sort = my_sort )) for doc in docs [: 5 ]: print ( doc ) {'born': '1916-08-25', 'prizes': [{'year': '1954'}]} {'born': '1915-06-15', 'prizes': [{'year': '1954'}]} {'born': '1901-02-28', 'prizes': [{'year': '1962'}, {'year': '1954'}]} {'born': '1913-07-12', 'prizes': [{'year': '1955'}]} {'born': '1911-01-26', 'prizes': [{'year': '1955'}]}","title":"Sorting example: What the sort?"},{"location":"primer/04_MongoDB_part2/lesson/#3-indexing","text":"","title":"3: Indexing"},{"location":"primer/04_MongoDB_part2/lesson/#what-are-indexes","text":"","title":"What are indexes?"},{"location":"primer/04_MongoDB_part2/lesson/#when-to-use-indexes","text":"Queries with high specificity Large documents Large collections","title":"When to use indexes?"},{"location":"primer/04_MongoDB_part2/lesson/#getting-index-information","text":"db . prizes . index_information () {'_id_': {'v': 2, 'key': [('_id', 1)], 'ns': 'nobel.prizes'}}","title":"Getting index information"},{"location":"primer/04_MongoDB_part2/lesson/#gauging-performance-before-indexing","text":"Jupyter Notebook %%timeit magic (same as python -m timeit \"[expression]\" ) %% timeit docs = list ( db . prizes . find ({ \"year\" : \"1901\" })) 577 \u00b5s \u00b1 22.4 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , 1 )])) 5 ms \u00b1 269 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , - 1 )])) 4.79 ms \u00b1 400 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)","title":"Gauging performance before indexing"},{"location":"primer/04_MongoDB_part2/lesson/#adding-a-single-field-index","text":"* index model: list of (field, direction) pairs. * directions: 1 (ascending) and -1 (descending) db . prizes . create_index ([( \"year\" , 1 )]) 'year_1' db . prizes . index_information () {'_id_': {'v': 2, 'key': [('_id', 1)], 'ns': 'nobel.prizes'}, 'year_1': {'v': 2, 'key': [('year', 1)], 'ns': 'nobel.prizes'}} %% timeit docs = list ( db . prizes . find ({ \"year\" : \"1901\" })) 330 \u00b5s \u00b1 12.1 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , 1 )])) 3.89 ms \u00b1 122 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , - 1 )])) 4.07 ms \u00b1 122 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) db . prizes . drop_index ([( \"year\" , 1 )]) db . prizes . create_index ([( \"year\" , - 1 )]) 'year_-1' %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , - 1 )])) 4.36 ms \u00b1 249 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) db . prizes . drop_index ([( \"year\" , - 1 )])","title":"Adding a single-field index"},{"location":"primer/04_MongoDB_part2/lesson/#adding-a-compound-multiple-field-index","text":"index \"covering\" a query with projection %% timeit list ( db . prizes . find ({ \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 })) 620 \u00b5s \u00b1 3.05 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . create_index ([( \"category\" , 1 ), ( \"year\" , 1 )]) 'category_1_year_1' %% timeit list ( db . prizes . find ({ \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 })) 435 \u00b5s \u00b1 12.3 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . drop_index ([( \"category\" , 1 ), ( \"year\" , 1 )]) * index \"covering\" a query with projection and sorting %% timeit db . prizes . find_one ( { \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 }, sort = [( \"year\" , 1 )] ) 698 \u00b5s \u00b1 62.2 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . create_index ([( \"category\" , 1 ), ( \"year\" , 1 )]) 'category_1_year_1' %% timeit db . prizes . find_one ( { \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 }, sort = [( \"year\" , 1 )] ) 504 \u00b5s \u00b1 17.7 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . drop_index ([( \"category\" , 1 ), ( \"year\" , 1 )])","title":"Adding a compound (multiple-field) index"}]}